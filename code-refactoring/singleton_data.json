[
  {
    "type": "EagerlyInitializedSingleton",
    "input": "public class EagerlyInitializedSingleton {\n\n    public EagerlyInitializedSingleton() {}\n\n}",
    "output": "public class EagerlyInitializedSingleton {\n\n    private EagerlyInitializedSingleton() {}\n\n    private static final EagerlyInitializedSingleton instance = new EagerlyInitializedSingleton();\n\n    public static EagerlyInitializedSingleton getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazyInitializedSingleton",
    "input": "public class LazyInitializedSingleton {\n\n    public LazyInitializedSingleton() {}\n\n}",
    "output": "public class LazyInitializedSingleton {\n\n    private static LazyInitializedSingleton instance;\n\n    private LazyInitializedSingleton() {}\n\n    public static LazyInitializedSingleton getInstance() {\n        if (instance == null) {\n            instance = new LazyInitializedSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "ThreadSafeSingleton",
    "input": "public class ThreadSafeSingleton {\n\n    public ThreadSafeSingleton() {}\n\n}",
    "output": "public class ThreadSafeSingleton {\n\n    private static ThreadSafeSingleton instance;\n\n    private ThreadSafeSingleton() {}\n\n    public static synchronized ThreadSafeSingleton getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "BillPughSingleton",
    "input": "public class BillPughSingleton {\n\n    public BillPughSingleton() {}\n\n}",
    "output": "public class BillPughSingleton {\n\n    private BillPughSingleton() {}\n\n    private static class SingletonHelper {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n\n    public static BillPughSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "EnumSingleton",
    "input": "public class EnumSingleton {\n\n    public EnumSingleton() {}\n\n}",
    "output": "public enum EnumSingleton {\n    INSTANCE;\n\n    public void someMethod() {\n        // Your method implementation\n    }\n}"
  },
  {
    "type": "EagerlyInitializedStaticBlockSingleton",
    "input": "public class EagerlyInitializedStaticBlockSingleton {\n\n    public EagerlyInitializedStaticBlockSingleton() {}\n\n}",
    "output": "public class EagerlyInitializedStaticBlockSingleton {\n\n    private static EagerlyInitializedStaticBlockSingleton instance;\n\n    private EagerlyInitializedStaticBlockSingleton() {}\n\n    static {\n        try {\n            instance = new EagerlyInitializedStaticBlockSingleton();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public static EagerlyInitializedStaticBlockSingleton getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "EnumSingleton",
    "input": "public class EnumSingleton {\n\n    public EnumSingleton() {}\n\n}",
    "output": "public enum EnumSingleton {\n\n    INSTANCE;\n\n    //other\n}"
  },
  {
    "type": "LazilyInitializedDoubleCheckedLockingSingleton",
    "input": "public class LazilyInitializedDoubleCheckedLockingSingleton {\n\n    public LazilyInitializedDoubleCheckedLockingSingleton() {}\n\n}",
    "output": "public class LazilyInitializedDoubleCheckedLockingSingleton {\n\n    private static volatile LazilyInitializedDoubleCheckedLockingSingleton instance;\n\n    private LazilyInitializedDoubleCheckedLockingSingleton() {}\n\n    public static LazilyInitializedDoubleCheckedLockingSingleton getInstance() {\n        if(instance == null) {\n            synchronized (LazilyInitializedDoubleCheckedLockingSingleton.class) {\n                if(instance == null) {\n                    instance = new LazilyInitializedDoubleCheckedLockingSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazilyInitializedInnerClassSingleton",
    "input": "public class LazilyInitializedInnerClassSingleton {\n\n    public LazilyInitializedInnerClassSingleton() {}\n\n}",
    "output": "public class LazilyInitializedInnerClassSingleton {\n\n    private LazilyInitializedInnerClassSingleton() {}\n\n    private static class InnerSingletonInitializer {\n        private static final LazilyInitializedInnerClassSingleton INSTANCE = new LazilyInitializedInnerClassSingleton();\n    }\n\n    public static LazilyInitializedInnerClassSingleton getInstance() {\n        return InnerSingletonInitializer.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "LazilyInitializedSingleton",
    "input": "public class LazilyInitializedSingleton {\n\n    public LazilyInitializedSingleton() {}\n\n}",
    "output": "public class LazilyInitializedSingleton {\n\n    private static LazilyInitializedSingleton instance;\n\n    private LazilyInitializedSingleton() {}\n\n    public static synchronized LazilyInitializedSingleton getInstance() {\n        if(instance == null) {\n            instance = new LazilyInitializedSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "ProtectionAgainstReflectionSingleton",
    "input": "public class ProtectionAgainstReflectionSingleton {\n\n    public ProtectionAgainstReflectionSingleton() {}\n\n}",
    "output": "public class ProtectionAgainstReflectionSingleton {\n\n    private ProtectionAgainstReflectionSingleton() {\n        if(instance != null) {\n            throw new IllegalStateException(\"Singleton already initialized\");\n        }\n    }\n\n    private static final ProtectionAgainstReflectionSingleton instance = new ProtectionAgainstReflectionSingleton();\n\n    public static ProtectionAgainstReflectionSingleton getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SerializableSingleton",
    "input": "public class SerializableSingleton {\n\n    public SerializableSingleton() {}\n\n}",
    "output": "public class SerializableSingleton implements Serializable {\n\n    private static final long serialVersionUID = -6265755052204900542L;\n\n    private static SerializableSingleton instance;\n\n    private SerializableSingleton() {}\n\n    public static synchronized SerializableSingleton getInstance() {\n        if(instance == null) {\n            instance = new SerializableSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SerializableWithReadResolveSingleton",
    "input": "public class SerializableWithReadResolveSingleton {\n\n    public SerializableWithReadResolveSingleton() {}\n\n}",
    "output": "public class SerializableWithReadResolveSingleton implements Serializable {\n\n    private static final long serialVersionUID = 1911904003687931976L;\n\n    private static SerializableWithReadResolveSingleton instance;\n\n    private SerializableWithReadResolveSingleton() {}\n\n    protected Object readResolve() {\n        return instance;\n    }\n\n    public static synchronized SerializableWithReadResolveSingleton getInstance() {\n        if(instance == null) {\n            instance = new SerializableWithReadResolveSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazilyInitializedSingleton",
    "input": "public class Universe {\n\n    private String name;\n    private int numberOfGalaxies;\n\n    public Universe(String name, int numberOfGalaxies) {\n        this.name = name;\n        this.numberOfGalaxies = numberOfGalaxies;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getNumberOfGalaxies() {\n        return this.numberOfGalaxies;\n    }\n\n    public void setName(String aNewName) {\n        this.name = aNewName;\n    }\n\n}\n\npublic class BigBang {\n\n    public BigBang() {}\n\n    public Universe makeUniverse(String name, int numberOfGalaxies) {\n        return new Universe(name, numberOfGalaxies);\n    }\n\n}",
    "output": "public class Universe {\n    private static Universe instance;\n\n    private String name;\n    private int numberOfGalaxies;\n\n    private Universe(String name, int numberOfGalaxies) {\n        this.name = name;\n        this.numberOfGalaxies = numberOfGalaxies;\n    }\n\n    public static Universe getInstance(String name, int numberOfGalaxies) {\n        if (instance == null) {\n            instance = new Universe(name, numberOfGalaxies);\n        }\n        return instance;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getNumberOfGalaxies() {\n        return this.numberOfGalaxies;\n    }\n\n    public void setName(String aNewName) {\n        this.name = aNewName;\n    }\n}\n\npublic class BigBang {\n    public BigBang() {}\n\n    public Universe makeUniverse(String name, int numberOfGalaxies) {\n        return Universe.getInstance(name, numberOfGalaxies);\n    }\n}"
  },
  {
    "type": "LazilyInitializedSingleton",
    "input": "public class MakeACaptain {\n\n    public MakeACaptain() {}\n\n    public static MakeACaptain getCaptain() {\n        return new MakeACaptain();\n    }\n\n    public static void main(String[] args) {\n        MakeACaptain c1 = new MakeACaptain();\n        MakeACaptain c2 = new MakeACaptain();\n\n        if (c1 == c2) {\n            System.out.println(\"c1 i c2 su iste instance\");\n        } else {\n            System.out.println(\"c1 i c2 nisu iste instance\");\n        }\n    }\n}",
    "output": "public class MakeACaptain {\n    private static MakeACaptain _captain;\n\n    private MakeACaptain() {}\n\n    public static MakeACaptain getCaptain() {\n        if (_captain == null) {\n            _captain = new MakeACaptain();\n            System.out.println(\"Izabran novi kapiten\");\n        } else {\n            System.out.println(\"Vec postoji kapiten\");\n        }\n        return _captain;\n    }\n\n    public static void main(String[] args) {\n        MakeACaptain c1 = MakeACaptain.getCaptain();\n        MakeACaptain c2 = MakeACaptain.getCaptain();\n\n        if (c1 == c2) {\n            System.out.println(\"c1 i c2 su iste instance\");\n        }\n    }\n}"
  },
  {
    "type": "DoubleCheckedLockingSingleton",
    "input": "public class printer {\n  public printer() {}\n\n  public static printer getPublicPrinter() {\n    return new printer();\n  }\n\n  public Connection getConnection() {\n    String url = \"jdbc:derby:memory:sample;create=true\";\n    Connection connection = null;\n    try {\n      connection = DriverManager.getConnection(url);\n    } catch (SQLException e) {\n      e.printStackTrace();\n    }\n    return connection;\n  }\n}",
    "output": "public class printer {\n  private static volatile printer publicPrinter;\n  private static volatile Connection connection;\n\n  private printer() {\n    if (publicPrinter != null) {\n      throw new RuntimeException(\"please use publicPrinter\");\n    }\n  }\n\n  public static printer getPublicPrinter() {\n    if (publicPrinter == null) {\n      synchronized (printer.class) {\n        if (publicPrinter == null) {\n          publicPrinter = new printer();\n        }\n      }\n    }\n    return publicPrinter;\n  }\n\n  public Connection getConnection() {\n    if (connection == null) {\n      synchronized (printer.class) {\n        if (connection == null) {\n          String url = \"jdbc:derby:memory:sample;create=true\";\n          try {\n            connection = DriverManager.getConnection(url);\n          } catch (SQLException e) {\n            e.printStackTrace();\n          }\n        }\n      }\n    }\n    return connection;\n  }\n}"
  },
  {
    "type": "LazilyInitializedSingleton",
    "input": "public class Singleton {\n\n    public String str;\n\n    public Singleton() {\n        str = \"This is a string of singleton\";\n    }\n\n    public static Singleton getInstance() {\n        return new Singleton();\n    }\n\n    public static void main(String[] args) {\n        Singleton s = new Singleton();\n\n        Singleton t = new Singleton();\n\n        Singleton u = new Singleton();\n\n        t.str = t.str.toUpperCase();\n\n        System.out.println(\"For Instance of 's': \" + s.str);\n        System.out.println(\"For Instance of 't': \" + t.str);\n        System.out.println(\"For Instance of 'u': \" + u.str);\n    }\n}",
    "output": "public class Singleton {\n\n    public String str;\n\n    private Singleton() {\n        str = \"This is a string of singleton\";\n    }\n\n    private static Singleton singleInstance = null;\n\n    public static Singleton getInstance() {\n        if (singleInstance == null) {\n            singleInstance = new Singleton();\n        }\n        return singleInstance;\n    }\n\n    public static void main(String[] args) {\n        Singleton s = Singleton.getInstance();\n\n        Singleton t = Singleton.getInstance();\n\n        Singleton u = Singleton.getInstance();\n\n        t.str = t.str.toUpperCase();\n\n        System.out.println(\"For Instance of 's': \" + s.str);\n        System.out.println(\"For Instance of 't': \" + t.str);\n        System.out.println(\"For Instance of 'u': \" + u.str);\n    }\n}"
  },
  {
    "type": "DoubleCheckedLockingSingleton",
    "input": "public class DoubleCheckLockSingleton {\n\n    public DoubleCheckLockSingleton() {\n        // public constructor\n    }\n\n    public static DoubleCheckLockSingleton getInstance() {\n        return new DoubleCheckLockSingleton();\n    }\n}",
    "output": "public class DoubleCheckLockSingleton {\n    private static volatile DoubleCheckLockSingleton instance = null;\n\n    private DoubleCheckLockSingleton() {\n        // private constructor\n    }\n\n    public static DoubleCheckLockSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckLockSingleton.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckLockSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}"
  },
  {
    "type": "EagerSingleton",
    "input": "public class EagerSingleton {\n    public EagerSingleton() {}\n    public static EagerSingleton getInstance() {\n        return new EagerSingleton();\n    }\n}",
    "output": "public class EagerSingleton {\n    private static final EagerSingleton instance = new EagerSingleton();\n\n    private EagerSingleton() {\n        // private constructor\n    }\n\n    public static EagerSingleton getInstance() {\n        return instance;\n    }\n}"
  },
  {
    "type": "EnumSingleton",
    "input": "public class EnumSingleton {\n\n    public EnumSingleton(String info) {\n        // constructor\n    }\n\n    public EnumSingleton getInstance() {\n        return new EnumSingleton(\"property want to initialize at once\");\n    }\n}",
    "output": "public enum EnumSingleton {\n\n    INSTANCE(\"property want to initialize at once\");\n\n    private String info;\n\n    private EnumSingleton(String info) {\n        this.info = info;\n    }\n\n    public EnumSingleton getInstance() {\n        return INSTANCE;\n    }\n}"
  },
  {
    "type": "LazySingleton",
    "input": "public class LazySingleton {\n    public LazySingleton() {}\n    public static LazySingleton getInstance() {\n        return new LazySingleton();\n    }\n}",
    "output": "public class LazySingleton {\n    private static LazySingleton instance;\n\n    private LazySingleton() {\n        // private constructor\n    }\n\n    public static LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}"
  },
  {
    "type": "BillPughSingleton",
    "input": "public class Singleton {\n    public Singleton() {}\n    public static Singleton getInstance() {\n        return new Singleton();\n    }\n}",
    "output": "public class Singleton {\n\n    private Singleton() {\n    }\n\n    private static class SingletonHelper {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}"
  },
  {
    "type": "StaticBlockSingleton",
    "input": "public class StaticBlockSingleton {\n    public StaticBlockSingleton() {}\n}",
    "output": "public class StaticBlockSingleton {\n    public static StaticBlockSingleton instance;\n\n    private StaticBlockSingleton() {\n        // private constructor\n    }\n\n    static {\n        instance = new StaticBlockSingleton();\n    }\n}"
  },
  {
    "type": "ThreadSafeDoubleCheckedLockingSingleton",
    "input": "public class ThreadSafeSingle {\n    public ThreadSafeSingle() {}\n    public static ThreadSafeSingle getInstance() {\n        return new ThreadSafeSingle();\n    }\n}",
    "output": "public class ThreadSafeSingle {\n    private static volatile ThreadSafeSingle instance = null;\n\n    private ThreadSafeSingle() {}\n\n    public static ThreadSafeSingle getInstance() {\n        if (instance == null) {\n            synchronized (ThreadSafeSingle.class) {\n                if (instance == null) {\n                    instance = new ThreadSafeSingle();\n                }\n            }\n        }\n        return instance;\n    }\n}"
  },
  {
    "type": "OptimizedLazySingleton",
    "input": "public class YourObject {\n    public YourObject() {}\n    public static YourObject getInstance() {\n        return new YourObject();\n    }\n}",
    "output": "public class YourObject {\n\n    private static final Object lock = new Object();\n    private static volatile YourObject instance;\n\n    public static YourObject getInstance() {\n        YourObject r = instance;\n        if (r == null) {\n            synchronized (lock) {\n                r = instance;\n                if (r == null) {\n                    r = new YourObject();\n                    instance = r;\n                }\n            }\n        }\n        return r;\n    }\n}"
  },
  {
    "type": "LazySingleton",
    "input": "public class Singleton {\n    \n    private Singleton() {\n        // private constructor\n    }\n\n    public void mostrarMensagem() {\n        System.out.println(\"Exemplo de Singleton!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Singleton instancia = new Singleton();\n        instancia.mostrarMensagem();\n    }\n}",
    "output": "public class Singleton {\n    \n    private static Singleton instanciaUnica;\n\n    private Singleton() {\n        // private constructor\n    }\n\n    public static Singleton getInstancia() {\n        if (instanciaUnica == null) {\n            instanciaUnica = new Singleton();\n        }\n        return instanciaUnica;\n    }\n\n    public void mostrarMensagem() {\n        System.out.println(\"Exemplo de Singleton!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Singleton instancia = Singleton.getInstancia();\n        instancia.mostrarMensagem();\n    }\n}"
  },
  {
    "type": "ThreadSafeSingletonWithInitializationOnDemand",
    "input": "public class ThreadSafeSingleton {\n\n    public ThreadSafeSingleton() {}\n\n}",
    "output": "public class ThreadSafeSingleton {\n\n    private ThreadSafeSingleton() {}\n\n    private static class SingletonHelper {\n        private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton();\n    }\n\n    public static ThreadSafeSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "SynchronizedSingleton",
    "input": "public class SynchronizedSingleton {\n\n    public SynchronizedSingleton() {}\n\n}",
    "output": "public class SynchronizedSingleton {\n\n    private static SynchronizedSingleton instance;\n\n    private SynchronizedSingleton() {}\n\n    public static synchronized SynchronizedSingleton getInstance() {\n        if (instance == null) {\n            instance = new SynchronizedSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithCounter",
    "input": "public class LazySingletonWithCounter {\n\n    public LazySingletonWithCounter() {}\n\n    public static LazySingletonWithCounter getInstance() {\n        return new LazySingletonWithCounter();\n    }\n\n    public int getInstanceCount() {\n        return 0;\n    }\n\n}",
    "output": "public class LazySingletonWithCounter {\n\n    private static LazySingletonWithCounter instance;\n    private static int counter;\n\n    private LazySingletonWithCounter() {\n        counter++;\n    }\n\n    public static LazySingletonWithCounter getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonWithCounter();\n        }\n        return instance;\n    }\n\n    public int getInstanceCount() {\n        return counter;\n    }\n\n}"
  },
  {
    "type": "EagerSingletonWithLogging",
    "input": "public class EagerSingletonWithLogging {\n\n    public EagerSingletonWithLogging() {}\n\n    public static EagerSingletonWithLogging getInstance() {\n        return new EagerSingletonWithLogging();\n    }\n\n}",
    "output": "public class EagerSingletonWithLogging {\n\n    private static final EagerSingletonWithLogging instance = new EagerSingletonWithLogging();\n\n    private EagerSingletonWithLogging() {\n        System.out.println(\"Singleton instance created\");\n    }\n\n    public static EagerSingletonWithLogging getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "EnumSingletonWithData",
    "input": "public class EnumSingletonWithData {\n\n    public EnumSingletonWithData(String data) {}\n\n    public static EnumSingletonWithData getInstance() {\n        return new EnumSingletonWithData(\"default\");\n    }\n\n}",
    "output": "public enum EnumSingletonWithData {\n\n    INSTANCE(\"default\");\n\n    private String data;\n\n    private EnumSingletonWithData(String data) {\n        this.data = data;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n    public void setData(String data) {\n        this.data = data;\n    }\n\n}"
  },
  {
    "type": "StaticBlockSingletonWithErrorHandling",
    "input": "public class StaticBlockSingletonWithErrorHandling {\n\n    public StaticBlockSingletonWithErrorHandling() {}\n\n}",
    "output": "public class StaticBlockSingletonWithErrorHandling {\n\n    private static StaticBlockSingletonWithErrorHandling instance;\n\n    private StaticBlockSingletonWithErrorHandling() {}\n\n    static {\n        try {\n            instance = new StaticBlockSingletonWithErrorHandling();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error creating singleton instance\", e);\n        }\n    }\n\n    public static StaticBlockSingletonWithErrorHandling getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithReadResolve",
    "input": "public class LazySingletonWithReadResolve {\n\n    public LazySingletonWithReadResolve() {}\n\n    public static LazySingletonWithReadResolve getInstance() {\n        return new LazySingletonWithReadResolve();\n    }\n\n}",
    "output": "public class LazySingletonWithReadResolve implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n    private static LazySingletonWithReadResolve instance;\n\n    private LazySingletonWithReadResolve() {}\n\n    public static LazySingletonWithReadResolve getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonWithReadResolve();\n        }\n        return instance;\n    }\n\n    protected Object readResolve() {\n        return getInstance();\n    }\n\n}"
  },
  {
    "type": "SingletonWithEnumAndMethod",
    "input": "public class SingletonWithEnumAndMethod {\n\n    public SingletonWithEnumAndMethod() {}\n\n    public static SingletonWithEnumAndMethod getInstance() {\n        return new SingletonWithEnumAndMethod();\n    }\n\n}",
    "output": "public enum SingletonWithEnumAndMethod {\n\n    INSTANCE;\n\n    public void performAction() {\n        System.out.println(\"Action performed by SingletonWithEnumAndMethod\");\n    }\n\n}"
  },
  {
    "type": "ThreadLocalSingleton",
    "input": "public class ThreadLocalSingleton {\n\n    public ThreadLocalSingleton() {}\n\n}",
    "output": "public class ThreadLocalSingleton {\n\n    private static final ThreadLocal<ThreadLocalSingleton> instance = ThreadLocal.withInitial(ThreadLocalSingleton::new);\n\n    private ThreadLocalSingleton() {}\n\n    public static ThreadLocalSingleton getInstance() {\n        return instance.get();\n    }\n\n}"
  },
  {
    "type": "ParameterizedLazySingleton",
    "input": "public class ParameterizedLazySingleton {\n\n    public ParameterizedLazySingleton(String param) {}\n\n    public static ParameterizedLazySingleton getInstance() {\n        return new ParameterizedLazySingleton(\"default\");\n    }\n\n}",
    "output": "public class ParameterizedLazySingleton {\n\n    private static ParameterizedLazySingleton instance;\n    private String param;\n\n    private ParameterizedLazySingleton(String param) {\n        this.param = param;\n    }\n\n    public static synchronized ParameterizedLazySingleton getInstance(String param) {\n        if (instance == null) {\n            instance = new ParameterizedLazySingleton(param);\n        }\n        return instance;\n    }\n\n    public String getParam() {\n        return param;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithInitializationCount",
    "input": "public class LazySingletonWithInitializationCount {\n\n    public LazySingletonWithInitializationCount() {}\n\n}",
    "output": "public class LazySingletonWithInitializationCount {\n\n    private static LazySingletonWithInitializationCount instance;\n    private static int initializationCount = 0;\n\n    private LazySingletonWithInitializationCount() {\n        initializationCount++;\n    }\n\n    public static LazySingletonWithInitializationCount getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonWithInitializationCount();\n        }\n        return instance;\n    }\n\n    public static int getInitializationCount() {\n        return initializationCount;\n    }\n\n}"
  },
  {
    "type": "MultithreadedLazySingleton",
    "input": "public class MultithreadedLazySingleton {\n\n    public MultithreadedLazySingleton() {}\n\n}",
    "output": "public class MultithreadedLazySingleton {\n\n    private static MultithreadedLazySingleton instance;\n\n    private MultithreadedLazySingleton() {}\n\n    public static MultithreadedLazySingleton getInstance() {\n        synchronized (MultithreadedLazySingleton.class) {\n            if (instance == null) {\n                instance = new MultithreadedLazySingleton();\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithOptionalInstance",
    "input": "public class LazySingletonWithOptionalInstance {\n\n    public LazySingletonWithOptionalInstance() {}\n\n}",
    "output": "import java.util.Optional;\n\npublic class LazySingletonWithOptionalInstance {\n\n    private static LazySingletonWithOptionalInstance instance;\n\n    private LazySingletonWithOptionalInstance() {}\n\n    public static Optional<LazySingletonWithOptionalInstance> getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonWithOptionalInstance();\n        }\n        return Optional.of(instance);\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithDynamicConfig",
    "input": "public class LazySingletonWithDynamicConfig {\n\n    public LazySingletonWithDynamicConfig(String config) {}\n\n}",
    "output": "public class LazySingletonWithDynamicConfig {\n\n    private static LazySingletonWithDynamicConfig instance;\n    private String config;\n\n    private LazySingletonWithDynamicConfig(String config) {\n        this.config = config;\n    }\n\n    public static LazySingletonWithDynamicConfig getInstance(String config) {\n        if (instance == null) {\n            instance = new LazySingletonWithDynamicConfig(config);\n        }\n        return instance;\n    }\n\n    public String getConfig() {\n        return config;\n    }\n\n}"
  },
  {
    "type": "EagerSingletonWithStartupLogging",
    "input": "public class EagerSingletonWithStartupLogging {\n\n    public EagerSingletonWithStartupLogging() {}\n\n}",
    "output": "public class EagerSingletonWithStartupLogging {\n\n    private static final EagerSingletonWithStartupLogging instance = new EagerSingletonWithStartupLogging();\n\n    private EagerSingletonWithStartupLogging() {\n        System.out.println(\"Singleton initialized during class loading\");\n    }\n\n    public static EagerSingletonWithStartupLogging getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "DoubleCheckedLockingWithLazyInitialization",
    "input": "public class DoubleCheckedLockingWithLazyInitialization {\n\n    public DoubleCheckedLockingWithLazyInitialization() {}\n\n}",
    "output": "public class DoubleCheckedLockingWithLazyInitialization {\n\n    private static volatile DoubleCheckedLockingWithLazyInitialization instance;\n\n    private DoubleCheckedLockingWithLazyInitialization() {}\n\n    public static DoubleCheckedLockingWithLazyInitialization getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckedLockingWithLazyInitialization.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckedLockingWithLazyInitialization();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SingletonWithWeakReference",
    "input": "public class SingletonWithWeakReference {\n\n    public SingletonWithWeakReference() {}\n\n}",
    "output": "import java.lang.ref.WeakReference;\n\npublic class SingletonWithWeakReference {\n\n    private static WeakReference<SingletonWithWeakReference> instance;\n\n    private SingletonWithWeakReference() {}\n\n    public static SingletonWithWeakReference getInstance() {\n        if (instance == null || instance.get() == null) {\n            instance = new WeakReference<>(new SingletonWithWeakReference());\n        }\n        return instance.get();\n    }\n\n}"
  },
  {
    "type": "StaticBlockWithInstanceValidation",
    "input": "public class StaticBlockWithInstanceValidation {\n\n    public StaticBlockWithInstanceValidation() {}\n\n}",
    "output": "public class StaticBlockWithInstanceValidation {\n\n    private static StaticBlockWithInstanceValidation instance;\n\n    private StaticBlockWithInstanceValidation() {}\n\n    static {\n        try {\n            instance = new StaticBlockWithInstanceValidation();\n        } catch (Exception e) {\n            System.err.println(\"Error during instance initialization: \" + e.getMessage());\n        }\n    }\n\n    public static StaticBlockWithInstanceValidation getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithPropertiesFile",
    "input": "public class LazySingletonWithPropertiesFile {\n\n    public LazySingletonWithPropertiesFile() {}\n\n}",
    "output": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class LazySingletonWithPropertiesFile {\n\n    private static LazySingletonWithPropertiesFile instance;\n    private Properties properties;\n\n    private LazySingletonWithPropertiesFile() {\n        properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"config.properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static LazySingletonWithPropertiesFile getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonWithPropertiesFile();\n        }\n        return instance;\n    }\n\n    public Properties getProperties() {\n        return properties;\n    }\n\n}"
  },
  {
    "type": "SingletonWithCache",
    "input": "public class SingletonWithCache {\n\n    public SingletonWithCache() {}\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SingletonWithCache {\n\n    private static SingletonWithCache instance;\n    private Map<String, String> cache;\n\n    private SingletonWithCache() {\n        cache = new HashMap<>();\n    }\n\n    public static SingletonWithCache getInstance() {\n        if (instance == null) {\n            instance = new SingletonWithCache();\n        }\n        return instance;\n    }\n\n    public void putInCache(String key, String value) {\n        cache.put(key, value);\n    }\n\n    public String getFromCache(String key) {\n        return cache.get(key);\n    }\n\n}"
  },
  {
    "type": "SingletonWithImmutableData",
    "input": "public class SingletonWithImmutableData {\n\n    public SingletonWithImmutableData(String data) {}\n\n}",
    "output": "public class SingletonWithImmutableData {\n\n    private static SingletonWithImmutableData instance;\n    private final String data;\n\n    private SingletonWithImmutableData(String data) {\n        this.data = data;\n    }\n\n    public static SingletonWithImmutableData getInstance(String data) {\n        if (instance == null) {\n            instance = new SingletonWithImmutableData(data);\n        }\n        return instance;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n}"
  },
  {
    "type": "SingletonWithBackgroundTask",
    "input": "public class SingletonWithBackgroundTask {\n\n    public SingletonWithBackgroundTask() {}\n\n}",
    "output": "import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class SingletonWithBackgroundTask {\n\n    private static SingletonWithBackgroundTask instance;\n    private ExecutorService executorService;\n\n    private SingletonWithBackgroundTask() {\n        executorService = Executors.newSingleThreadExecutor();\n    }\n\n    public static SingletonWithBackgroundTask getInstance() {\n        if (instance == null) {\n            instance = new SingletonWithBackgroundTask();\n        }\n        return instance;\n    }\n\n    public void runTask(Runnable task) {\n        executorService.submit(task);\n    }\n\n}"
  },
  {
    "type": "ClusteredSingleton",
    "input": "public class ClusteredSingleton {\n\n    public ClusteredSingleton() {}\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class ClusteredSingleton {\n\n    private static final ConcurrentMap<String, ClusteredSingleton> instances = new ConcurrentHashMap<>();\n\n    private ClusteredSingleton() {}\n\n    public static ClusteredSingleton getInstance(String clusterKey) {\n        return instances.computeIfAbsent(clusterKey, key -> new ClusteredSingleton());\n    }\n\n}"
  },
  {
    "type": "SingletonWithStateTracking",
    "input": "public class SingletonWithStateTracking {\n\n    public SingletonWithStateTracking() {}\n\n}",
    "output": "public class SingletonWithStateTracking {\n\n    private static SingletonWithStateTracking instance;\n    private int state;\n\n    private SingletonWithStateTracking() {\n        state = 0;\n    }\n\n    public static SingletonWithStateTracking getInstance() {\n        if (instance == null) {\n            instance = new SingletonWithStateTracking();\n        }\n        return instance;\n    }\n\n    public void incrementState() {\n        state++;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n}"
  },
  {
    "type": "EnvironmentBasedSingleton",
    "input": "public class EnvironmentBasedSingleton {\n\n    public EnvironmentBasedSingleton() {}\n\n}",
    "output": "public class EnvironmentBasedSingleton {\n\n    private static EnvironmentBasedSingleton instance;\n    private String environment;\n\n    private EnvironmentBasedSingleton(String environment) {\n        this.environment = environment;\n    }\n\n    public static EnvironmentBasedSingleton getInstance(String environment) {\n        if (instance == null) {\n            instance = new EnvironmentBasedSingleton(environment);\n        }\n        return instance;\n    }\n\n    public String getEnvironment() {\n        return environment;\n    }\n\n}"
  },
  {
    "type": "SingletonWithThreadPool",
    "input": "public class SingletonWithThreadPool {\n\n    public SingletonWithThreadPool() {}\n\n}",
    "output": "import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class SingletonWithThreadPool {\n\n    private static SingletonWithThreadPool instance;\n    private ExecutorService threadPool;\n\n    private SingletonWithThreadPool() {\n        threadPool = Executors.newFixedThreadPool(5);\n    }\n\n    public static SingletonWithThreadPool getInstance() {\n        if (instance == null) {\n            instance = new SingletonWithThreadPool();\n        }\n        return instance;\n    }\n\n    public ExecutorService getThreadPool() {\n        return threadPool;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMultitonSupport",
    "input": "public class SingletonWithMultitonSupport {\n\n    public SingletonWithMultitonSupport() {}\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SingletonWithMultitonSupport {\n\n    private static Map<String, SingletonWithMultitonSupport> instances = new HashMap<>();\n\n    private SingletonWithMultitonSupport() {}\n\n    public static SingletonWithMultitonSupport getInstance(String key) {\n        return instances.computeIfAbsent(key, k -> new SingletonWithMultitonSupport());\n    }\n\n}"
  },
  {
    "type": "SingletonWithObserverPattern",
    "input": "public class SingletonWithObserverPattern {\n\n    public SingletonWithObserverPattern() {}\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SingletonWithObserverPattern {\n\n    private static SingletonWithObserverPattern instance;\n    private List<Observer> observers;\n\n    private SingletonWithObserverPattern() {\n        observers = new ArrayList<>();\n    }\n\n    public static SingletonWithObserverPattern getInstance() {\n        if (instance == null) {\n            instance = new SingletonWithObserverPattern();\n        }\n        return instance;\n    }\n\n    public void addObserver(Observer observer) {\n        observers.add(observer);\n    }\n\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n\n}\n\ninterface Observer {\n    void update();\n}"
  },
  {
    "type": "SingletonWithLifecycleCallbacks",
    "input": "public class SingletonWithLifecycleCallbacks {\n\n    public SingletonWithLifecycleCallbacks() {}\n\n}",
    "output": "public class SingletonWithLifecycleCallbacks {\n\n    private static SingletonWithLifecycleCallbacks instance;\n\n    private SingletonWithLifecycleCallbacks() {}\n\n    public static SingletonWithLifecycleCallbacks getInstance() {\n        if (instance == null) {\n            instance = new SingletonWithLifecycleCallbacks();\n            onCreate();\n        }\n        return instance;\n    }\n\n    public static void onCreate() {\n        System.out.println(\"Singleton instance created\");\n    }\n\n    public static void onDestroy() {\n        System.out.println(\"Singleton instance destroyed\");\n    }\n\n}"
  },
  {
    "type": "DatabaseConnectionSingleton",
    "input": "public class DatabaseConnection {\n\n    public DatabaseConnection() {}\n\n    public Connection connect() {\n        return null;\n    }\n\n}",
    "output": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DatabaseConnection {\n\n    private static DatabaseConnection instance;\n    private Connection connection;\n\n    private DatabaseConnection() {\n        try {\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db\", \"user\", \"password\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n}"
  },
  {
    "type": "LoggingSingleton",
    "input": "public class Logger {\n\n    public Logger() {}\n\n    public void log(String message) {\n        System.out.println(message);\n    }\n\n}",
    "output": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Logger {\n\n    private static Logger instance;\n    private FileWriter fileWriter;\n\n    private Logger() {\n        try {\n            fileWriter = new FileWriter(\"app.log\", true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n\n    public void log(String message) {\n        try {\n            fileWriter.write(message + \"\\n\");\n            fileWriter.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}"
  },
  {
    "type": "ConfigurationSingleton",
    "input": "public class Configuration {\n\n    public Configuration() {}\n\n    public String getConfig(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Configuration {\n\n    private static Configuration instance;\n    private Properties properties;\n\n    private Configuration() {\n        properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"config.properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Configuration getInstance() {\n        if (instance == null) {\n            instance = new Configuration();\n        }\n        return instance;\n    }\n\n    public String getConfig(String key) {\n        return properties.getProperty(key);\n    }\n\n}"
  },
  {
    "type": "ThreadLocalSingleton",
    "input": "public class ThreadLocalInstance {\n\n    public ThreadLocalInstance() {}\n\n}",
    "output": "public class ThreadLocalInstance {\n\n    private static final ThreadLocal<ThreadLocalInstance> threadLocalInstance = ThreadLocal.withInitial(ThreadLocalInstance::new);\n\n    private ThreadLocalInstance() {}\n\n    public static ThreadLocalInstance getInstance() {\n        return threadLocalInstance.get();\n    }\n\n}"
  },
  {
    "type": "MultitonSingleton",
    "input": "public class Multiton {\n\n    public Multiton() {}\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Multiton {\n\n    private static final Map<String, Multiton> instances = new HashMap<>();\n\n    private Multiton() {}\n\n    public static Multiton getInstance(String key) {\n        return instances.computeIfAbsent(key, k -> new Multiton());\n    }\n\n}"
  },
  {
    "type": "SingletonWithSerialization",
    "input": "public class SerializableSingleton {\n\n    public SerializableSingleton() {}\n\n}",
    "output": "import java.io.Serializable;\n\npublic class SerializableSingleton implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n    private static SerializableSingleton instance;\n\n    private SerializableSingleton() {}\n\n    public static SerializableSingleton getInstance() {\n        if (instance == null) {\n            instance = new SerializableSingleton();\n        }\n        return instance;\n    }\n\n    protected Object readResolve() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "LazyLoadingSingleton",
    "input": "public class LazyLoadingSingleton {\n\n    public LazyLoadingSingleton() {}\n\n}",
    "output": "public class LazyLoadingSingleton {\n\n    private LazyLoadingSingleton() {}\n\n    private static class Holder {\n        private static final LazyLoadingSingleton INSTANCE = new LazyLoadingSingleton();\n    }\n\n    public static LazyLoadingSingleton getInstance() {\n        return Holder.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "SingletonWithObserverPattern",
    "input": "public class ObserverSingleton {\n\n    public ObserverSingleton() {}\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ObserverSingleton {\n\n    private static ObserverSingleton instance;\n    private List<Observer> observers;\n\n    private ObserverSingleton() {\n        observers = new ArrayList<>();\n    }\n\n    public static ObserverSingleton getInstance() {\n        if (instance == null) {\n            instance = new ObserverSingleton();\n        }\n        return instance;\n    }\n\n    public void addObserver(Observer observer) {\n        observers.add(observer);\n    }\n\n    public void notifyObservers(String message) {\n        for (Observer observer : observers) {\n            observer.update(message);\n        }\n    }\n\n}\n\ninterface Observer {\n    void update(String message);\n}"
  },
  {
    "type": "SingletonWithStateTracking",
    "input": "public class StatefulSingleton {\n\n    public StatefulSingleton() {}\n\n}",
    "output": "public class StatefulSingleton {\n\n    private static StatefulSingleton instance;\n    private int state;\n\n    private StatefulSingleton() {\n        state = 0;\n    }\n\n    public static StatefulSingleton getInstance() {\n        if (instance == null) {\n            instance = new StatefulSingleton();\n        }\n        return instance;\n    }\n\n    public void incrementState() {\n        state++;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n}"
  },
  {
    "type": "SingletonWithDynamicConfiguration",
    "input": "public class DynamicConfigSingleton {\n\n    public DynamicConfigSingleton() {}\n\n}",
    "output": "public class DynamicConfigSingleton {\n\n    private static DynamicConfigSingleton instance;\n    private String config;\n\n    private DynamicConfigSingleton(String config) {\n        this.config = config;\n    }\n\n    public static DynamicConfigSingleton getInstance(String config) {\n        if (instance == null) {\n            instance = new DynamicConfigSingleton(config);\n        }\n        return instance;\n    }\n\n    public String getConfig() {\n        return config;\n    }\n\n}"
  },
  {
    "type": "EventDrivenSingleton",
    "input": "public class EventHandler {\n\n    public EventHandler() {}\n\n    public void handleEvent(String event) {\n        System.out.println(event);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EventHandler {\n\n    private static EventHandler instance;\n    private List<String> eventQueue;\n\n    private EventHandler() {\n        eventQueue = new ArrayList<>();\n    }\n\n    public static EventHandler getInstance() {\n        if (instance == null) {\n            instance = new EventHandler();\n        }\n        return instance;\n    }\n\n    public void handleEvent(String event) {\n        eventQueue.add(event);\n        System.out.println(\"Event handled: \" + event);\n    }\n\n    public List<String> getEventQueue() {\n        return eventQueue;\n    }\n\n}"
  },
  {
    "type": "SessionManagerSingleton",
    "input": "public class SessionManager {\n\n    public SessionManager() {}\n\n    public void createSession(String user) {\n        System.out.println(\"Session created for: \" + user);\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n\n    private static SessionManager instance;\n    private Map<String, String> activeSessions;\n\n    private SessionManager() {\n        activeSessions = new HashMap<>();\n    }\n\n    public static SessionManager getInstance() {\n        if (instance == null) {\n            instance = new SessionManager();\n        }\n        return instance;\n    }\n\n    public void createSession(String user) {\n        activeSessions.put(user, \"SessionActive\");\n        System.out.println(\"Session created for: \" + user);\n    }\n\n    public boolean isSessionActive(String user) {\n        return activeSessions.containsKey(user);\n    }\n\n}"
  },
  {
    "type": "ConfigurationManagerSingleton",
    "input": "public class ConfigurationManager {\n\n    public ConfigurationManager() {}\n\n}",
    "output": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class ConfigurationManager {\n\n    private static ConfigurationManager instance;\n    private Properties properties;\n\n    private ConfigurationManager() {\n        properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"app_config.properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static ConfigurationManager getInstance() {\n        if (instance == null) {\n            instance = new ConfigurationManager();\n        }\n        return instance;\n    }\n\n    public String getConfigValue(String key) {\n        return properties.getProperty(key);\n    }\n\n}"
  },
  {
    "type": "ResourcePoolSingleton",
    "input": "public class ResourcePool {\n\n    public ResourcePool() {}\n\n    public void allocateResource(String resourceName) {\n        System.out.println(\"Allocated: \" + resourceName);\n    }\n\n}",
    "output": "import java.util.Queue;\nimport java.util.LinkedList;\n\npublic class ResourcePool {\n\n    private static ResourcePool instance;\n    private Queue<String> availableResources;\n\n    private ResourcePool() {\n        availableResources = new LinkedList<>();\n        availableResources.add(\"Resource1\");\n        availableResources.add(\"Resource2\");\n    }\n\n    public static ResourcePool getInstance() {\n        if (instance == null) {\n            instance = new ResourcePool();\n        }\n        return instance;\n    }\n\n    public String allocateResource() {\n        return availableResources.poll();\n    }\n\n    public void releaseResource(String resource) {\n        availableResources.add(resource);\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n\n    private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n    }\n\n    public List<String> getMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
  {
    "type": "LazyLoadedSingletonWithLogging",
    "input": "public class LoggingSingleton {\n\n    public LoggingSingleton() {}\n\n}",
    "output": "public class LoggingSingleton {\n\n    private LoggingSingleton() {\n        System.out.println(\"Singleton instance created\");\n    }\n\n    private static class SingletonHolder {\n        private static final LoggingSingleton INSTANCE = new LoggingSingleton();\n    }\n\n    public static LoggingSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "PriorityBasedSingleton",
    "input": "public class PrioritySingleton {\n\n    public PrioritySingleton() {}\n\n}",
    "output": "import java.util.PriorityQueue;\n\npublic class PrioritySingleton {\n\n    private static PrioritySingleton instance;\n    private PriorityQueue<Integer> priorityQueue;\n\n    private PrioritySingleton() {\n        priorityQueue = new PriorityQueue<>();\n    }\n\n    public static PrioritySingleton getInstance() {\n        if (instance == null) {\n            instance = new PrioritySingleton();\n        }\n        return instance;\n    }\n\n    public void addPriority(int priority) {\n        priorityQueue.add(priority);\n    }\n\n    public int getHighestPriority() {\n        return priorityQueue.poll();\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithOnDemandInitialization",
    "input": "public class OnDemandSingleton {\n\n    public OnDemandSingleton() {}\n\n}",
    "output": "public class OnDemandSingleton {\n\n    private static OnDemandSingleton instance;\n\n    private OnDemandSingleton() {}\n\n    public static OnDemandSingleton getInstance() {\n        if (instance == null) {\n            instance = new OnDemandSingleton();\n        }\n        return instance;\n    }\n\n    public String fetchData() {\n        return \"Fetched on-demand data\";\n    }\n\n}"
  },
  {
    "type": "SingletonWithLifecycleHooks",
    "input": "public class LifecycleSingleton {\n\n    public LifecycleSingleton() {}\n\n}",
    "output": "public class LifecycleSingleton {\n\n    private static LifecycleSingleton instance;\n\n    private LifecycleSingleton() {\n        onCreate();\n    }\n\n    public static LifecycleSingleton getInstance() {\n        if (instance == null) {\n            instance = new LifecycleSingleton();\n        }\n        return instance;\n    }\n\n    private void onCreate() {\n        System.out.println(\"LifecycleSingleton created\");\n    }\n\n    public void onDestroy() {\n        System.out.println(\"LifecycleSingleton destroyed\");\n        instance = null;\n    }\n\n}"
  },
  {
    "type": "LoggingManagerSingleton",
    "input": "public class LoggingManager {\n\n    public LoggingManager() {}\n\n    public void logMessage(String message) {\n        System.out.println(message);\n    }\n\n}",
    "output": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class LoggingManager {\n\n    private static LoggingManager instance;\n    private FileWriter fileWriter;\n\n    private LoggingManager() {\n        try {\n            fileWriter = new FileWriter(\"logfile.log\", true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static LoggingManager getInstance() {\n        if (instance == null) {\n            instance = new LoggingManager();\n        }\n        return instance;\n    }\n\n    public void logMessage(String message) {\n        try {\n            fileWriter.write(message + \"\\n\");\n            fileWriter.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}"
  },
  {
    "type": "ResourceTrackerSingleton",
    "input": "public class ResourceTracker {\n\n    public ResourceTracker() {}\n\n    public void track(String resource) {\n        System.out.println(\"Tracking: \" + resource);\n    }\n\n}",
    "output": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class ResourceTracker {\n\n    private static ResourceTracker instance;\n    private Set<String> trackedResources;\n\n    private ResourceTracker() {\n        trackedResources = new HashSet<>();\n    }\n\n    public static ResourceTracker getInstance() {\n        if (instance == null) {\n            instance = new ResourceTracker();\n        }\n        return instance;\n    }\n\n    public void track(String resource) {\n        trackedResources.add(resource);\n        System.out.println(\"Tracking: \" + resource);\n    }\n\n    public boolean isTracked(String resource) {\n        return trackedResources.contains(resource);\n    }\n\n}"
  },
  {
    "type": "TaskQueueSingleton",
    "input": "public class TaskQueue {\n\n    public TaskQueue() {}\n\n}",
    "output": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class TaskQueue {\n\n    private static TaskQueue instance;\n    private Queue<String> tasks;\n\n    private TaskQueue() {\n        tasks = new LinkedList<>();\n    }\n\n    public static TaskQueue getInstance() {\n        if (instance == null) {\n            instance = new TaskQueue();\n        }\n        return instance;\n    }\n\n    public void addTask(String task) {\n        tasks.add(task);\n    }\n\n    public String getNextTask() {\n        return tasks.poll();\n    }\n\n}"
  },
  {
    "type": "ThreadLocalLoggerSingleton",
    "input": "public class ThreadLocalLogger {\n\n    public ThreadLocalLogger() {}\n\n    public void log(String message) {\n        System.out.println(message);\n    }\n\n}",
    "output": "public class ThreadLocalLogger {\n\n    private static final ThreadLocal<ThreadLocalLogger> threadLocalInstance = ThreadLocal.withInitial(ThreadLocalLogger::new);\n\n    private ThreadLocalLogger() {}\n\n    public static ThreadLocalLogger getInstance() {\n        return threadLocalInstance.get();\n    }\n\n    public void log(String message) {\n        System.out.println(Thread.currentThread().getName() + \": \" + message);\n    }\n\n}"
  },
  {
    "type": "ConfigurationCacheSingleton",
    "input": "public class ConfigurationCache {\n\n    public ConfigurationCache() {}\n\n    public String get(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ConfigurationCache {\n\n    private static ConfigurationCache instance;\n    private Map<String, String> cache;\n\n    private ConfigurationCache() {\n        cache = new HashMap<>();\n    }\n\n    public static ConfigurationCache getInstance() {\n        if (instance == null) {\n            instance = new ConfigurationCache();\n        }\n        return instance;\n    }\n\n    public void put(String key, String value) {\n        cache.put(key, value);\n    }\n\n    public String get(String key) {\n        return cache.get(key);\n    }\n\n}"
  },
  {
    "type": "EventDispatcherSingleton",
    "input": "public class EventDispatcher {\n\n    public EventDispatcher() {}\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EventDispatcher {\n\n    private static EventDispatcher instance;\n    private List<String> events;\n\n    private EventDispatcher() {\n        events = new ArrayList<>();\n    }\n\n    public static EventDispatcher getInstance() {\n        if (instance == null) {\n            instance = new EventDispatcher();\n        }\n        return instance;\n    }\n\n    public void dispatch(String event) {\n        events.add(event);\n        System.out.println(\"Event dispatched: \" + event);\n    }\n\n    public List<String> getDispatchedEvents() {\n        return events;\n    }\n\n}"
  },
  {
    "type": "UserManagerSingleton",
    "input": "public class UserManager {\n\n    public UserManager() {}\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class UserManager {\n\n    private static UserManager instance;\n    private Map<String, String> users;\n\n    private UserManager() {\n        users = new HashMap<>();\n    }\n\n    public static UserManager getInstance() {\n        if (instance == null) {\n            instance = new UserManager();\n        }\n        return instance;\n    }\n\n    public void addUser(String id, String name) {\n        users.put(id, name);\n    }\n\n    public String getUser(String id) {\n        return users.get(id);\n    }\n\n}"
  },
  {
    "type": "StatefulLoggerSingleton",
    "input": "public class StatefulLogger {\n\n    public StatefulLogger() {}\n\n}",
    "output": "public class StatefulLogger {\n\n    private static StatefulLogger instance;\n    private int logCount;\n\n    private StatefulLogger() {\n        logCount = 0;\n    }\n\n    public static StatefulLogger getInstance() {\n        if (instance == null) {\n            instance = new StatefulLogger();\n        }\n        return instance;\n    }\n\n    public void log(String message) {\n        logCount++;\n        System.out.println(logCount + \": \" + message);\n    }\n\n    public int getLogCount() {\n        return logCount;\n    }\n\n}"
  },
  {
    "type": "NotificationManagerSingleton",
    "input": "public class NotificationManager {\n\n    public NotificationManager() {}\n\n    public void notify(String message) {\n        System.out.println(message);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NotificationManager {\n\n    private static NotificationManager instance;\n    private List<String> notifications;\n\n    private NotificationManager() {\n        notifications = new ArrayList<>();\n    }\n\n    public static NotificationManager getInstance() {\n        if (instance == null) {\n            instance = new NotificationManager();\n        }\n        return instance;\n    }\n\n    public void notify(String message) {\n        notifications.add(message);\n        System.out.println(\"Notification: \" + message);\n    }\n\n    public List<String> getNotifications() {\n        return notifications;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithRetry",
    "input": "public class RetryManager {\n\n    public RetryManager() {}\n\n    public void retry(String task) {\n        System.out.println(\"Retrying: \" + task);\n    }\n\n}",
    "output": "public class RetryManager {\n\n    private static RetryManager instance;\n    private int retryCount;\n\n    private RetryManager() {\n        retryCount = 0;\n    }\n\n    public static RetryManager getInstance() {\n        if (instance == null) {\n            instance = new RetryManager();\n        }\n        return instance;\n    }\n\n    public void retry(String task) {\n        retryCount++;\n        System.out.println(\"Retrying task: \" + task + \" - Retry Count: \" + retryCount);\n    }\n\n}"
  },
  {
    "type": "DatabaseConnectionPoolSingleton",
    "input": "public class ConnectionPool {\n\n    public ConnectionPool() {}\n\n    public void addConnection(String conn) {\n        System.out.println(\"Adding: \" + conn);\n    }\n\n}",
    "output": "import java.util.Queue;\nimport java.util.LinkedList;\n\npublic class ConnectionPool {\n\n    private static ConnectionPool instance;\n    private Queue<String> connectionPool;\n\n    private ConnectionPool() {\n        connectionPool = new LinkedList<>();\n        connectionPool.add(\"Connection1\");\n        connectionPool.add(\"Connection2\");\n    }\n\n    public static ConnectionPool getInstance() {\n        if (instance == null) {\n            instance = new ConnectionPool();\n        }\n        return instance;\n    }\n\n    public String getConnection() {\n        return connectionPool.poll();\n    }\n\n    public void releaseConnection(String connection) {\n        connectionPool.add(connection);\n    }\n\n}"
  },
  {
    "type": "CacheManagerSingleton",
    "input": "public class CacheManager {\n\n    public CacheManager() {}\n\n    public void put(String key, String value) {\n        System.out.println(\"Put: \" + key + \" -> \" + value);\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CacheManager {\n\n    private static CacheManager instance;\n    private Map<String, String> cache;\n\n    private CacheManager() {\n        cache = new HashMap<>();\n    }\n\n    public static CacheManager getInstance() {\n        if (instance == null) {\n            instance = new CacheManager();\n        }\n        return instance;\n    }\n\n    public void put(String key, String value) {\n        cache.put(key, value);\n    }\n\n    public String get(String key) {\n        return cache.get(key);\n    }\n\n}"
  },
  {
    "type": "MultithreadedTaskManagerSingleton",
    "input": "public class TaskManager {\n\n    public TaskManager() {}\n\n    public void addTask(String task) {\n        System.out.println(\"Task Added: \" + task);\n    }\n\n}",
    "output": "import java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\npublic class TaskManager {\n\n    private static TaskManager instance;\n    private Queue<String> taskQueue;\n\n    private TaskManager() {\n        taskQueue = new ConcurrentLinkedQueue<>();\n    }\n\n    public static synchronized TaskManager getInstance() {\n        if (instance == null) {\n            instance = new TaskManager();\n        }\n        return instance;\n    }\n\n    public void addTask(String task) {\n        taskQueue.add(task);\n    }\n\n    public String getTask() {\n        return taskQueue.poll();\n    }\n\n}"
  },
  {
    "type": "ThreadSafeConfigManagerSingleton",
    "input": "public class ConfigManager {\n\n    public ConfigManager() {}\n\n    public String getConfig(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\n\npublic class ConfigManager {\n\n    private static volatile ConfigManager instance;\n    private Map<String, String> config;\n\n    private ConfigManager() {\n        config = new ConcurrentHashMap<>();\n    }\n\n    public static ConfigManager getInstance() {\n        if (instance == null) {\n            synchronized (ConfigManager.class) {\n                if (instance == null) {\n                    instance = new ConfigManager();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public void setConfig(String key, String value) {\n        config.put(key, value);\n    }\n\n    public String getConfig(String key) {\n        return config.get(key);\n    }\n\n}"
  },
  {
    "type": "TokenBucketRateLimiterSingleton",
    "input": "public class RateLimiter {\n\n    public RateLimiter() {}\n\n    public boolean allowRequest() {\n        return true;\n    }\n\n}",
    "output": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class RateLimiter {\n\n    private static RateLimiter instance;\n    private AtomicInteger tokens;\n    private static final int MAX_TOKENS = 10;\n\n    private RateLimiter() {\n        tokens = new AtomicInteger(MAX_TOKENS);\n    }\n\n    public static RateLimiter getInstance() {\n        if (instance == null) {\n            instance = new RateLimiter();\n        }\n        return instance;\n    }\n\n    public boolean allowRequest() {\n        if (tokens.get() > 0) {\n            tokens.decrementAndGet();\n            return true;\n        } else {\n            System.out.println(\"Request denied: Rate limit exceeded\");\n            return false;\n        }\n    }\n\n    public void refillTokens() {\n        tokens.set(MAX_TOKENS);\n    }\n\n}"
  },
  {
    "type": "GlobalIdGeneratorSingleton",
    "input": "public class IdGenerator {\n\n    public IdGenerator() {}\n\n    public int generate() {\n        return 0;\n    }\n\n}",
    "output": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class IdGenerator {\n\n    private static IdGenerator instance;\n    private AtomicInteger counter;\n\n    private IdGenerator() {\n        counter = new AtomicInteger(0);\n    }\n\n    public static IdGenerator getInstance() {\n        if (instance == null) {\n            instance = new IdGenerator();\n        }\n        return instance;\n    }\n\n    public int generate() {\n        return counter.incrementAndGet();\n    }\n\n}"
  },
  {
    "type": "DistributedLockManagerSingleton",
    "input": "public class LockManager {\n\n    public LockManager() {}\n\n    public boolean acquireLock(String key) {\n        return true;\n    }\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class LockManager {\n\n    private static LockManager instance;\n    private ConcurrentHashMap<String, Boolean> locks;\n\n    private LockManager() {\n        locks = new ConcurrentHashMap<>();\n    }\n\n    public static synchronized LockManager getInstance() {\n        if (instance == null) {\n            instance = new LockManager();\n        }\n        return instance;\n    }\n\n    public boolean acquireLock(String key) {\n        return locks.putIfAbsent(key, true) == null;\n    }\n\n    public void releaseLock(String key) {\n        locks.remove(key);\n    }\n\n}"
  },
  {
    "type": "RealTimeEventPublisherSingleton",
    "input": "public class EventPublisher {\n\n    public EventPublisher() {}\n\n    public void publishEvent(String event) {\n        System.out.println(event);\n    }\n\n}",
    "output": "import java.util.concurrent.CopyOnWriteArrayList;\n\npublic class EventPublisher {\n\n    private static EventPublisher instance;\n    private CopyOnWriteArrayList<String> eventListeners;\n\n    private EventPublisher() {\n        eventListeners = new CopyOnWriteArrayList<>();\n    }\n\n    public static EventPublisher getInstance() {\n        if (instance == null) {\n            instance = new EventPublisher();\n        }\n        return instance;\n    }\n\n    public void addListener(String listener) {\n        eventListeners.add(listener);\n    }\n\n    public void publishEvent(String event) {\n        for (String listener : eventListeners) {\n            System.out.println(\"Notifying listener: \" + listener + \" of event: \" + event);\n        }\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n\n    private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n        System.out.println(\"Collected metric: \" + metric);\n    }\n\n    public List<String> getCollectedMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n\n    private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n        System.out.println(\"Collected metric: \" + metric);\n    }\n\n    public List<String> getCollectedMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n\n    private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n        System.out.println(\"Collected metric: \" + metric);\n    }\n\n    public List<String> getCollectedMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n\n    private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n        System.out.println(\"Collected metric: \" + metric);\n    }\n\n    public List<String> getCollectedMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n\n    private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n        System.out.println(\"Collected metric: \" + metric);\n    }\n\n    public List<String> getCollectedMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMetricsCollection",
    "input": "public class MetricsCollector {\n\n    public MetricsCollector() {}\n\n    public void collectMetric(String metric) {\n        System.out.println(metric);\n    }\n\n}",
    "output": "import java.util.ArrayList;\n   private static MetricsCollector instance;\n    private List<String> collectedMetrics;\n\n    private MetricsCollector() {\n        collectedMetrics = new ArrayList<>();\n    }\n\n    public static MetricsCollector getInstance() {\n        if (instance == null) {\n            instance = new MetricsCollector();\n        }\n        return instance;\n    }\n\n    public void collectMetric(String metric) {\n        collectedMetrics.add(metric);\n        System.out.println(\"Collected metric: \" + metric);\n    }\n\n    public List<String> getCollectedMetrics() {\n        return collectedMetrics;\n    }\n\n}"
  },
   {
    "type": "DatabasePoolSingleton",
    "input": "public class DatabasePoolSingleton {\n\n    public DatabasePoolSingleton() {}\n\n    public Connection getConnection() {\n        return null;\n    }\n\n    public void releaseConnection(Connection connection) {\n        System.out.println(\"Connection released\");\n    }\n\n}",
    "output": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\npublic class DatabasePoolSingleton {\n    private static DatabasePoolSingleton instance;\n    private BlockingQueue<Connection> connectionPool;\n\n    private DatabasePoolSingleton() {\n        connectionPool = new ArrayBlockingQueue<>(5);\n        try {\n            for (int i = 0; i < 5; i++) {\n                connectionPool.add(DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db\", \"user\", \"password\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized DatabasePoolSingleton getInstance() {\n        if (instance == null) {\n            instance = new DatabasePoolSingleton();\n        }\n        return instance;\n    }\n\n    public Connection getConnection() {\n        try {\n            return connectionPool.take();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"No connections available\");\n        }\n    }\n\n    public void releaseConnection(Connection connection) {\n        connectionPool.offer(connection);\n    }\n}"
  },
  {
    "type": "LoggerSingleton",
    "input": "public class LoggerSingleton {\n\n    public LoggerSingleton() {}\n\n    public void log(String level, String message) {\n        System.out.println(level + \": \" + message);\n    }\n\n}",
    "output": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class LoggerSingleton {\n    private static LoggerSingleton instance;\n    private FileWriter fileWriter;\n\n    private LoggerSingleton() {\n        try {\n            fileWriter = new FileWriter(\"application.log\", true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static LoggerSingleton getInstance() {\n        if (instance == null) {\n            synchronized (LoggerSingleton.class) {\n                if (instance == null) {\n                    instance = new LoggerSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public synchronized void log(String level, String message) {\n        try {\n            fileWriter.write(level + \": \" + message + \"\\n\");\n            fileWriter.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "type": "ConfigurationManager",
    "input": "public class ConfigurationManager {\n\n    public ConfigurationManager() {}\n\n    public String getConfig(String key) {\n        return null;\n    }\n\n    public void setConfig(String key, String value) {\n        System.out.println(key + \" -> \" + value);\n    }\n\n}",
    "output": "public enum ConfigurationManager {\n    INSTANCE;\n\n    private Map<String, String> config;\n\n    ConfigurationManager() {\n        config = new HashMap<>();\n        config.put(\"url\", \"http://example.com\");\n        config.put(\"timeout\", \"5000\");\n    }\n\n    public String getConfig(String key) {\n        return config.get(key);\n    }\n\n    public void setConfig(String key, String value) {\n        config.put(key, value);\n    }\n}"
  },
  {
    "type": "DoubleCheckedLockingSingleton",
    "input": "public class DoubleCheckedLockingSingleton {\n\n    public DoubleCheckedLockingSingleton() {}\n\n    public static DoubleCheckedLockingSingleton getInstance() {\n        return new DoubleCheckedLockingSingleton();\n    }\n\n}",
    "output": "public class DoubleCheckedLockingSingleton {\n    private static volatile DoubleCheckedLockingSingleton instance;\n\n    private DoubleCheckedLockingSingleton() {\n    }\n\n    public static DoubleCheckedLockingSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckedLockingSingleton.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckedLockingSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}"
  },
  {
    "type": "ThreadLocalSingleton",
    "input": "public class ThreadLocalSingleton {\n\n    public ThreadLocalSingleton() {}\n\n    public static ThreadLocalSingleton getInstance() {\n        return new ThreadLocalSingleton();\n    }\n\n}",
    "output": "public class ThreadLocalSingleton {\n    private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance =\n            ThreadLocal.withInitial(ThreadLocalSingleton::new);\n\n    private ThreadLocalSingleton() {\n    }\n\n    public static ThreadLocalSingleton getInstance() {\n        return threadLocalInstance.get();\n    }\n}"
  },
  {
    "type": "ExpiringSingleton",
    "input": "public class ExpiringSingleton {\n\n    public ExpiringSingleton() {}\n\n    public String getCreationTime() {\n        return null;\n    }\n\n}",
    "output": "import java.time.Instant;\n\npublic class ExpiringSingleton {\n    private static ExpiringSingleton instance;\n    private Instant creationTime;\n\n    private ExpiringSingleton() {\n        creationTime = Instant.now();\n    }\n\n    public static ExpiringSingleton getInstance() {\n        if (instance == null || Instant.now().isAfter(instance.creationTime.plusSeconds(60))) {\n            synchronized (ExpiringSingleton.class) {\n                if (instance == null || Instant.now().isAfter(instance.creationTime.plusSeconds(60))) {\n                    instance = new ExpiringSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public String getCreationTime() {\n        return creationTime.toString();\n    }\n}"
  },
    {
    "type": "CurrencyConverterSingleton",
    "input": "public class CurrencyConverter {\n\n    public CurrencyConverter() {}\n\n    public double convert(String from, String to, double amount) {\n        return 0.0;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CurrencyConverter {\n\n    private static CurrencyConverter instance;\n    private Map<String, Double> exchangeRates;\n\n    private CurrencyConverter() {\n        exchangeRates = new HashMap<>();\n        exchangeRates.put(\"USD_EUR\", 0.85);\n        exchangeRates.put(\"EUR_USD\", 1.18);\n    }\n\n    public static CurrencyConverter getInstance() {\n        if (instance == null) {\n            synchronized (CurrencyConverter.class) {\n                if (instance == null) {\n                    instance = new CurrencyConverter();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public double convert(String from, String to, double amount) {\n        String key = from + \"_\" + to;\n        return amount * exchangeRates.getOrDefault(key, 1.0);\n    }\n\n}"
  },
  {
    "type": "FileSystemCacheSingleton",
    "input": "public class FileSystemCache {\n\n    public FileSystemCache() {}\n\n    public void cacheFile(String path) {\n        System.out.println(\"Caching file: \" + path);\n    }\n\n}",
    "output": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class FileSystemCache {\n\n    private static FileSystemCache instance;\n    private Set<String> cachedFiles;\n\n    private FileSystemCache() {\n        cachedFiles = new HashSet<>();\n    }\n\n    public static synchronized FileSystemCache getInstance() {\n        if (instance == null) {\n            instance = new FileSystemCache();\n        }\n        return instance;\n    }\n\n    public void cacheFile(String path) {\n        cachedFiles.add(path);\n        System.out.println(\"Caching file: \" + path);\n    }\n\n    public boolean isFileCached(String path) {\n        return cachedFiles.contains(path);\n    }\n\n}"
  },
  {
    "type": "NotificationServiceSingleton",
    "input": "public class NotificationService {\n\n    public NotificationService() {}\n\n    public void sendNotification(String user, String message) {\n        System.out.println(\"Notification sent to \" + user + \": \" + message);\n    }\n\n}",
    "output": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class NotificationService {\n\n    private static NotificationService instance;\n    private Set<String> registeredUsers;\n\n    private NotificationService() {\n        registeredUsers = new HashSet<>();\n    }\n\n    public static synchronized NotificationService getInstance() {\n        if (instance == null) {\n            instance = new NotificationService();\n        }\n        return instance;\n    }\n\n    public void registerUser(String user) {\n        registeredUsers.add(user);\n    }\n\n    public void sendNotification(String user, String message) {\n        if (registeredUsers.contains(user)) {\n            System.out.println(\"Notification sent to \" + user + \": \" + message);\n        } else {\n            System.out.println(\"User not registered: \" + user);\n        }\n    }\n\n}"
  },
  {
    "type": "SessionManagerSingleton",
    "input": "public class SessionManager {\n\n    public SessionManager() {}\n\n    public void createSession(String user) {\n        System.out.println(\"Session created for: \" + user);\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n\n    private static SessionManager instance;\n    private Map<String, String> sessions;\n\n    private SessionManager() {\n        sessions = new HashMap<>();\n    }\n\n    public static SessionManager getInstance() {\n        if (instance == null) {\n            synchronized (SessionManager.class) {\n                if (instance == null) {\n                    instance = new SessionManager();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public void createSession(String user) {\n        sessions.put(user, \"Active\");\n        System.out.println(\"Session created for: \" + user);\n    }\n\n    public boolean isSessionActive(String user) {\n        return sessions.containsKey(user);\n    }\n\n}"
  },
  {
    "type": "ApplicationSettingsSingleton",
    "input": "public class ApplicationSettings {\n\n    public ApplicationSettings() {}\n\n    public String getSetting(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class ApplicationSettings {\n\n    private static ApplicationSettings instance;\n    private Properties properties;\n\n    private ApplicationSettings() {\n        properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"appsettings.properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized ApplicationSettings getInstance() {\n        if (instance == null) {\n            instance = new ApplicationSettings();\n        }\n        return instance;\n    }\n\n    public String getSetting(String key) {\n        return properties.getProperty(key);\n    }\n\n}"
  },
    {
    "type": "LoggerSingleton",
    "input": "public class Logger {\n\n    public Logger() {}\n\n    public void log(String message) {\n        System.out.println(message);\n    }\n\n}",
    "output": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Logger {\n\n    private static Logger instance;\n    private FileWriter fileWriter;\n\n    private Logger() {\n        try {\n            fileWriter = new FileWriter(\"log.txt\", true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n\n    public void log(String message) {\n        try {\n            fileWriter.write(message + \"\\n\");\n            fileWriter.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}"
  },
  {
    "type": "DatabaseConnectionPoolSingleton",
    "input": "public class DatabaseConnectionPool {\n\n    public DatabaseConnectionPool() {}\n\n    public void addConnection(String conn) {\n        System.out.println(\"Adding connection: \" + conn);\n    }\n\n}",
    "output": "import java.util.Queue;\nimport java.util.LinkedList;\n\npublic class DatabaseConnectionPool {\n\n    private static DatabaseConnectionPool instance;\n    private Queue<String> connectionPool;\n\n    private DatabaseConnectionPool() {\n        connectionPool = new LinkedList<>();\n        connectionPool.add(\"Connection1\");\n        connectionPool.add(\"Connection2\");\n    }\n\n    public static synchronized DatabaseConnectionPool getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnectionPool();\n        }\n        return instance;\n    }\n\n    public String getConnection() {\n        return connectionPool.poll();\n    }\n\n    public void releaseConnection(String connection) {\n        connectionPool.add(connection);\n    }\n\n}"
  },
  {
    "type": "APIRequestRateLimiterSingleton",
    "input": "public class RateLimiter {\n\n    public RateLimiter() {}\n\n    public boolean allowRequest() {\n        return true;\n    }\n\n}",
    "output": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class RateLimiter {\n\n    private static RateLimiter instance;\n    private AtomicInteger tokenCount;\n    private static final int MAX_TOKENS = 100;\n\n    private RateLimiter() {\n        tokenCount = new AtomicInteger(MAX_TOKENS);\n    }\n\n    public static synchronized RateLimiter getInstance() {\n        if (instance == null) {\n            instance = new RateLimiter();\n        }\n        return instance;\n    }\n\n    public boolean allowRequest() {\n        if (tokenCount.get() > 0) {\n            tokenCount.decrementAndGet();\n            return true;\n        }\n        return false;\n    }\n\n    public void refillTokens() {\n        tokenCount.set(MAX_TOKENS);\n    }\n\n}"
  },
  {
    "type": "ConfigurationCacheSingleton",
    "input": "public class ConfigurationCache {\n\n    public ConfigurationCache() {}\n\n    public String getConfig(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ConfigurationCache {\n\n    private static ConfigurationCache instance;\n    private Map<String, String> cache;\n\n    private ConfigurationCache() {\n        cache = new HashMap<>();\n    }\n\n    public static synchronized ConfigurationCache getInstance() {\n        if (instance == null) {\n            instance = new ConfigurationCache();\n        }\n        return instance;\n    }\n\n    public void put(String key, String value) {\n        cache.put(key, value);\n    }\n\n    public String get(String key) {\n        return cache.get(key);\n    }\n\n}"
  },
  {
    "type": "TaskSchedulerSingleton",
    "input": "public class TaskScheduler {\n\n    public TaskScheduler() {}\n\n    public void scheduleTask(Runnable task) {\n        System.out.println(\"Task scheduled.\");\n    }\n\n}",
    "output": "import java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class TaskScheduler {\n\n    private static TaskScheduler instance;\n    private ScheduledExecutorService scheduler;\n\n    private TaskScheduler() {\n        scheduler = Executors.newScheduledThreadPool(1);\n    }\n\n    public static synchronized TaskScheduler getInstance() {\n        if (instance == null) {\n            instance = new TaskScheduler();\n        }\n        return instance;\n    }\n\n    public void scheduleTask(Runnable task, long delay, TimeUnit unit) {\n        scheduler.schedule(task, delay, unit);\n    }\n\n}"
  },
  {
    "type": "AuthenticationManagerSingleton",
    "input": "public class AuthenticationManager {\n\n    public AuthenticationManager() {}\n\n    public boolean authenticate(String user, String password) {\n        return false;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationManager {\n\n    private static AuthenticationManager instance;\n    private Map<String, String> userDatabase;\n\n    private AuthenticationManager() {\n        userDatabase = new HashMap<>();\n        userDatabase.put(\"admin\", \"password123\");\n        userDatabase.put(\"user\", \"pass\");\n    }\n\n    public static synchronized AuthenticationManager getInstance() {\n        if (instance == null) {\n            instance = new AuthenticationManager();\n        }\n        return instance;\n    }\n\n    public boolean authenticate(String user, String password) {\n        return password.equals(userDatabase.get(user));\n    }\n\n}"
  },
  {
    "type": "EmailSenderSingleton",
    "input": "public class EmailSender {\n\n    public EmailSender() {}\n\n    public void sendEmail(String recipient, String subject, String body) {\n        System.out.println(\"Email sent to: \" + recipient);\n    }\n\n}",
    "output": "public class EmailSender {\n\n    private static EmailSender instance;\n\n    private EmailSender() {}\n\n    public static synchronized EmailSender getInstance() {\n        if (instance == null) {\n            instance = new EmailSender();\n        }\n        return instance;\n    }\n\n    public void sendEmail(String recipient, String subject, String body) {\n        System.out.println(\"Email sent to: \" + recipient + \" | Subject: \" + subject);\n    }\n\n}"
  },
  {
    "type": "ThreadLocalSessionManagerSingleton",
    "input": "public class ThreadLocalSessionManager {\n\n    public ThreadLocalSessionManager() {}\n\n}",
    "output": "public class ThreadLocalSessionManager {\n\n    private static final ThreadLocal<ThreadLocalSessionManager> threadLocalInstance = ThreadLocal.withInitial(ThreadLocalSessionManager::new);\n\n    private ThreadLocalSessionManager() {}\n\n    public static ThreadLocalSessionManager getInstance() {\n        return threadLocalInstance.get();\n    }\n\n    public void createSession(String sessionId) {\n        System.out.println(Thread.currentThread().getName() + \" - Session Created: \" + sessionId);\n    }\n\n}"
  },
    {
    "type": "SessionTrackerSingleton",
    "input": "public class SessionTracker {\n\n    public SessionTracker() {}\n\n    public void trackSession(String sessionId) {\n        System.out.println(\"Tracking session: \" + sessionId);\n    }\n\n}",
    "output": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class SessionTracker {\n\n    private static SessionTracker instance;\n    private Set<String> activeSessions;\n\n    private SessionTracker() {\n        activeSessions = new HashSet<>();\n    }\n\n    public static synchronized SessionTracker getInstance() {\n        if (instance == null) {\n            instance = new SessionTracker();\n        }\n        return instance;\n    }\n\n    public void trackSession(String sessionId) {\n        activeSessions.add(sessionId);\n        System.out.println(\"Session tracked: \" + sessionId);\n    }\n\n    public boolean isSessionActive(String sessionId) {\n        return activeSessions.contains(sessionId);\n    }\n\n}"
  },
  {
    "type": "NotificationCenterSingleton",
    "input": "public class NotificationCenter {\n\n    public NotificationCenter() {}\n\n    public void sendNotification(String message) {\n        System.out.println(\"Notification: \" + message);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NotificationCenter {\n\n    private static NotificationCenter instance;\n    private List<String> notifications;\n\n    private NotificationCenter() {\n        notifications = new ArrayList<>();\n    }\n\n    public static synchronized NotificationCenter getInstance() {\n        if (instance == null) {\n            instance = new NotificationCenter();\n        }\n        return instance;\n    }\n\n    public void sendNotification(String message) {\n        notifications.add(message);\n        System.out.println(\"Notification sent: \" + message);\n    }\n\n    public List<String> getNotifications() {\n        return notifications;\n    }\n\n}"
  },
  {
    "type": "ResourceAllocatorSingleton",
    "input": "public class ResourceAllocator {\n\n    public ResourceAllocator() {}\n\n    public void allocateResource(String resourceName) {\n        System.out.println(\"Allocated resource: \" + resourceName);\n    }\n\n}",
    "output": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class ResourceAllocator {\n\n    private static ResourceAllocator instance;\n    private Queue<String> resources;\n\n    private ResourceAllocator() {\n        resources = new LinkedList<>();\n        resources.add(\"Resource1\");\n        resources.add(\"Resource2\");\n    }\n\n    public static synchronized ResourceAllocator getInstance() {\n        if (instance == null) {\n            instance = new ResourceAllocator();\n        }\n        return instance;\n    }\n\n    public String allocateResource() {\n        return resources.poll();\n    }\n\n    public void releaseResource(String resourceName) {\n        resources.add(resourceName);\n    }\n\n}"
  },
  {
    "type": "GlobalEventBusSingleton",
    "input": "public class EventBus {\n\n    public EventBus() {}\n\n    public void postEvent(String event) {\n        System.out.println(\"Event posted: \" + event);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EventBus {\n\n    private static EventBus instance;\n    private List<String> events;\n\n    private EventBus() {\n        events = new ArrayList<>();\n    }\n\n    public static synchronized EventBus getInstance() {\n        if (instance == null) {\n            instance = new EventBus();\n        }\n        return instance;\n    }\n\n    public void postEvent(String event) {\n        events.add(event);\n        System.out.println(\"Event posted: \" + event);\n    }\n\n    public List<String> getPostedEvents() {\n        return events;\n    }\n\n}"
  },
  {
    "type": "FileStorageManagerSingleton",
    "input": "public class FileStorageManager {\n\n    public FileStorageManager() {}\n\n    public void saveFile(String fileName) {\n        System.out.println(\"File saved: \" + fileName);\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class FileStorageManager {\n\n    private static FileStorageManager instance;\n    private Map<String, byte[]> fileStorage;\n\n    private FileStorageManager() {\n        fileStorage = new HashMap<>();\n    }\n\n    public static synchronized FileStorageManager getInstance() {\n        if (instance == null) {\n            instance = new FileStorageManager();\n        }\n        return instance;\n    }\n\n    public void saveFile(String fileName, byte[] data) {\n        fileStorage.put(fileName, data);\n        System.out.println(\"File saved: \" + fileName);\n    }\n\n    public byte[] getFile(String fileName) {\n        return fileStorage.get(fileName);\n    }\n\n}"
  },
  {
    "type": "LocalizationManagerSingleton",
    "input": "public class LocalizationManager {\n\n    public LocalizationManager() {}\n\n    public String getTranslation(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class LocalizationManager {\n\n    private static LocalizationManager instance;\n    private Map<String, String> translations;\n\n    private LocalizationManager() {\n        translations = new HashMap<>();\n        translations.put(\"hello\", \"Hello\");\n        translations.put(\"goodbye\", \"Goodbye\");\n    }\n\n    public static synchronized LocalizationManager getInstance() {\n        if (instance == null) {\n            instance = new LocalizationManager();\n        }\n        return instance;\n    }\n\n    public String getTranslation(String key) {\n        return translations.getOrDefault(key, \"Translation not found\");\n    }\n\n}"
  },
  {
    "type": "AnalyticsTrackerSingleton",
    "input": "public class AnalyticsTracker {\n\n    public AnalyticsTracker() {}\n\n    public void trackEvent(String eventName) {\n        System.out.println(\"Event tracked: \" + eventName);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AnalyticsTracker {\n\n    private static AnalyticsTracker instance;\n    private List<String> trackedEvents;\n\n    private AnalyticsTracker() {\n        trackedEvents = new ArrayList<>();\n    }\n\n    public static synchronized AnalyticsTracker getInstance() {\n        if (instance == null) {\n            instance = new AnalyticsTracker();\n        }\n        return instance;\n    }\n\n    public void trackEvent(String eventName) {\n        trackedEvents.add(eventName);\n        System.out.println(\"Event tracked: \" + eventName);\n    }\n\n    public List<String> getTrackedEvents() {\n        return trackedEvents;\n    }\n\n}"
  },
  {
    "type": "SchedulerWithCronJobsSingleton",
    "input": "public class Scheduler {\n\n    public Scheduler() {}\n\n    public void addJob(String job) {\n        System.out.println(\"Job added: \" + job);\n    }\n\n}",
    "output": "import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class Scheduler {\n\n    private static Scheduler instance;\n    private Timer timer;\n\n    private Scheduler() {\n        timer = new Timer(true);\n    }\n\n    public static synchronized Scheduler getInstance() {\n        if (instance == null) {\n            instance = new Scheduler();\n        }\n        return instance;\n    }\n\n    public void addJob(String job, long delay) {\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"Executing job: \" + job);\n            }\n        }, delay);\n    }\n\n}"
  },
  {
    "type": "GlobalConfigurationSingleton",
    "input": "public class GlobalConfig {\n\n    public GlobalConfig() {}\n\n    public String getSetting(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class GlobalConfig {\n\n    private static GlobalConfig instance;\n    private Properties properties;\n\n    private GlobalConfig() {\n        properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"global_config.properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized GlobalConfig getInstance() {\n        if (instance == null) {\n            instance = new GlobalConfig();\n        }\n        return instance;\n    }\n\n    public String getSetting(String key) {\n        return properties.getProperty(key);\n    }\n\n}"
  },
    {
    "type": "EventLoggerSingleton",
    "input": "public class EventLogger {\n\n    public EventLogger() {}\n\n    public void logEvent(String event) {\n        System.out.println(event);\n    }\n\n}",
    "output": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class EventLogger {\n\n    private static EventLogger instance;\n    private FileWriter writer;\n\n    private EventLogger() {\n        try {\n            writer = new FileWriter(\"events.log\", true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized EventLogger getInstance() {\n        if (instance == null) {\n            instance = new EventLogger();\n        }\n        return instance;\n    }\n\n    public void logEvent(String event) {\n        try {\n            writer.write(event + \"\\n\");\n            writer.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}"
  },
  {
    "type": "ImageCacheSingleton",
    "input": "public class ImageCache {\n\n    public ImageCache() {}\n\n    public void addImage(String imageName, byte[] imageData) {\n        System.out.println(\"Image added: \" + imageName);\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ImageCache {\n\n    private static ImageCache instance;\n    private Map<String, byte[]> cache;\n\n    private ImageCache() {\n        cache = new HashMap<>();\n    }\n\n    public static synchronized ImageCache getInstance() {\n        if (instance == null) {\n            instance = new ImageCache();\n        }\n        return instance;\n    }\n\n    public void addImage(String imageName, byte[] imageData) {\n        cache.put(imageName, imageData);\n    }\n\n    public byte[] getImage(String imageName) {\n        return cache.get(imageName);\n    }\n\n}"
  },
  {
    "type": "AppConfigManagerSingleton",
    "input": "public class AppConfig {\n\n    public AppConfig() {}\n\n    public String getConfig(String key) {\n        return null;\n    }\n\n}",
    "output": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class AppConfig {\n\n    private static AppConfig instance;\n    private Properties config;\n\n    private AppConfig() {\n        config = new Properties();\n        try {\n            config.load(new FileInputStream(\"app_config.properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static synchronized AppConfig getInstance() {\n        if (instance == null) {\n            instance = new AppConfig();\n        }\n        return instance;\n    }\n\n    public String getConfig(String key) {\n        return config.getProperty(key);\n    }\n\n}"
  },
  {
    "type": "DatabaseMigrationManagerSingleton",
    "input": "public class MigrationManager {\n\n    public MigrationManager() {}\n\n    public void migrateDatabase(String migrationScript) {\n        System.out.println(\"Migration executed: \" + migrationScript);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MigrationManager {\n\n    private static MigrationManager instance;\n    private List<String> executedMigrations;\n\n    private MigrationManager() {\n        executedMigrations = new ArrayList<>();\n    }\n\n    public static synchronized MigrationManager getInstance() {\n        if (instance == null) {\n            instance = new MigrationManager();\n        }\n        return instance;\n    }\n\n    public void migrateDatabase(String migrationScript) {\n        if (!executedMigrations.contains(migrationScript)) {\n            executedMigrations.add(migrationScript);\n            System.out.println(\"Migration executed: \" + migrationScript);\n        } else {\n            System.out.println(\"Migration already executed: \" + migrationScript);\n        }\n    }\n\n}"
  },
  {
    "type": "TaskQueueManagerSingleton",
    "input": "public class TaskQueueManager {\n\n    public TaskQueueManager() {}\n\n    public void addTask(String task) {\n        System.out.println(\"Task added: \" + task);\n    }\n\n}",
    "output": "import java.util.concurrent.LinkedBlockingQueue;\n\npublic class TaskQueueManager {\n\n    private static TaskQueueManager instance;\n    private LinkedBlockingQueue<String> taskQueue;\n\n    private TaskQueueManager() {\n        taskQueue = new LinkedBlockingQueue<>();\n    }\n\n    public static synchronized TaskQueueManager getInstance() {\n        if (instance == null) {\n            instance = new TaskQueueManager();\n        }\n        return instance;\n    }\n\n    public void addTask(String task) {\n        try {\n            taskQueue.put(task);\n            System.out.println(\"Task added: \" + task);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public String getNextTask() {\n        return taskQueue.poll();\n    }\n\n}"
  },
  {
    "type": "FeatureFlagManagerSingleton",
    "input": "public class FeatureFlagManager {\n\n    public FeatureFlagManager() {}\n\n    public boolean isFeatureEnabled(String feature) {\n        return false;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class FeatureFlagManager {\n\n    private static FeatureFlagManager instance;\n    private Map<String, Boolean> featureFlags;\n\n    private FeatureFlagManager() {\n        featureFlags = new HashMap<>();\n        featureFlags.put(\"DarkMode\", true);\n        featureFlags.put(\"BetaFeatures\", false);\n    }\n\n    public static synchronized FeatureFlagManager getInstance() {\n        if (instance == null) {\n            instance = new FeatureFlagManager();\n        }\n        return instance;\n    }\n\n    public boolean isFeatureEnabled(String feature) {\n        return featureFlags.getOrDefault(feature, false);\n    }\n\n}"
  },
  {
    "type": "GlobalThemeManagerSingleton",
    "input": "public class ThemeManager {\n\n    public ThemeManager() {}\n\n    public String getCurrentTheme() {\n        return null;\n    }\n\n}",
    "output": "public class ThemeManager {\n\n    private static ThemeManager instance;\n    private String currentTheme;\n\n    private ThemeManager() {\n        currentTheme = \"Light\";\n    }\n\n    public static synchronized ThemeManager getInstance() {\n        if (instance == null) {\n            instance = new ThemeManager();\n        }\n        return instance;\n    }\n\n    public String getCurrentTheme() {\n        return currentTheme;\n    }\n\n    public void setTheme(String theme) {\n        currentTheme = theme;\n        System.out.println(\"Theme updated to: \" + theme);\n    }\n\n}"
  },
  {
    "type": "SecurityManagerSingleton",
    "input": "public class SecurityManager {\n\n    public SecurityManager() {}\n\n    public boolean hasPermission(String user, String resource) {\n        return false;\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SecurityManager {\n\n    private static SecurityManager instance;\n    private Map<String, String> permissions;\n\n    private SecurityManager() {\n        permissions = new HashMap<>();\n        permissions.put(\"admin\", \"*:*\" );\n        permissions.put(\"user\", \"read:resources\");\n    }\n\n    public static synchronized SecurityManager getInstance() {\n        if (instance == null) {\n            instance = new SecurityManager();\n        }\n        return instance;\n    }\n\n    public boolean hasPermission(String user, String resource) {\n        String allowedPermissions = permissions.get(user);\n        return allowedPermissions != null && (allowedPermissions.equals(\"*:*\") || allowedPermissions.contains(resource));\n    }\n\n}"
  },
    {
    "type": "DistributedCacheSingleton",
    "input": "public class DistributedCache {\n\n    public DistributedCache() {}\n\n    public void addCacheEntry(String key, String value) {\n        System.out.println(\"Added to cache: \" + key);\n    }\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class DistributedCache {\n\n    private static DistributedCache instance;\n    private ConcurrentHashMap<String, String> cache;\n\n    private DistributedCache() {\n        cache = new ConcurrentHashMap<>();\n    }\n\n    public static synchronized DistributedCache getInstance() {\n        if (instance == null) {\n            instance = new DistributedCache();\n        }\n        return instance;\n    }\n\n    public void addCacheEntry(String key, String value) {\n        cache.put(key, value);\n    }\n\n    public String getCacheEntry(String key) {\n        return cache.get(key);\n    }\n\n}"
  },
  {
    "type": "LazyLoadedResourceManagerSingleton",
    "input": "public class ResourceManager {\n\n    public ResourceManager() {}\n\n    public void allocateResource(String resource) {\n        System.out.println(\"Allocating resource: \" + resource);\n    }\n\n}",
    "output": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class ResourceManager {\n\n    private static ResourceManager instance;\n    private Queue<String> availableResources;\n\n    private ResourceManager() {\n        availableResources = new LinkedList<>();\n        availableResources.add(\"Resource1\");\n        availableResources.add(\"Resource2\");\n    }\n\n    public static synchronized ResourceManager getInstance() {\n        if (instance == null) {\n            instance = new ResourceManager();\n        }\n        return instance;\n    }\n\n    public String allocateResource() {\n        return availableResources.poll();\n    }\n\n    public void releaseResource(String resource) {\n        availableResources.add(resource);\n    }\n\n}"
  },
  {
    "type": "ThreadSafeFeatureToggleSingleton",
    "input": "public class FeatureToggle {\n\n    public FeatureToggle() {}\n\n    public boolean isFeatureEnabled(String feature) {\n        return false;\n    }\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class FeatureToggle {\n\n    private static FeatureToggle instance;\n    private ConcurrentHashMap<String, Boolean> toggles;\n\n    private FeatureToggle() {\n        toggles = new ConcurrentHashMap<>();\n        toggles.put(\"NewFeature\", true);\n        toggles.put(\"BetaMode\", false);\n    }\n\n    public static synchronized FeatureToggle getInstance() {\n        if (instance == null) {\n            instance = new FeatureToggle();\n        }\n        return instance;\n    }\n\n    public boolean isFeatureEnabled(String feature) {\n        return toggles.getOrDefault(feature, false);\n    }\n\n    public void setFeature(String feature, boolean isEnabled) {\n        toggles.put(feature, isEnabled);\n    }\n\n}"
  },
  {
    "type": "ConnectionPoolManagerSingleton",
    "input": "public class ConnectionPoolManager {\n\n    public ConnectionPoolManager() {}\n\n    public void addConnection(String connection) {\n        System.out.println(\"Added connection: \" + connection);\n    }\n\n}",
    "output": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class ConnectionPoolManager {\n\n    private static ConnectionPoolManager instance;\n    private Queue<String> connectionPool;\n\n    private ConnectionPoolManager() {\n        connectionPool = new LinkedList<>();\n        connectionPool.add(\"Connection1\");\n        connectionPool.add(\"Connection2\");\n    }\n\n    public static synchronized ConnectionPoolManager getInstance() {\n        if (instance == null) {\n            instance = new ConnectionPoolManager();\n        }\n        return instance;\n    }\n\n    public String getConnection() {\n        return connectionPool.poll();\n    }\n\n    public void releaseConnection(String connection) {\n        connectionPool.add(connection);\n    }\n\n}"
  },
  {
    "type": "NotificationServiceSingleton",
    "input": "public class NotificationService {\n\n    public NotificationService() {}\n\n    public void sendNotification(String message) {\n        System.out.println(message);\n    }\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NotificationService {\n\n    private static NotificationService instance;\n    private List<String> notifications;\n\n    private NotificationService() {\n        notifications = new ArrayList<>();\n    }\n\n    public static synchronized NotificationService getInstance() {\n        if (instance == null) {\n            instance = new NotificationService();\n        }\n        return instance;\n    }\n\n    public void sendNotification(String message) {\n        notifications.add(message);\n        System.out.println(\"Notification sent: \" + message);\n    }\n\n    public List<String> getNotifications() {\n        return notifications;\n    }\n\n}"
  },
  {
    "type": "EventBusSingleton",
    "input": "public class EventBus {\n\n    public EventBus() {}\n\n    public void postEvent(String event) {\n        System.out.println(event);\n    }\n\n}",
    "output": "import java.util.concurrent.CopyOnWriteArrayList;\n\npublic class EventBus {\n\n    private static EventBus instance;\n    private CopyOnWriteArrayList<String> subscribers;\n\n    private EventBus() {\n        subscribers = new CopyOnWriteArrayList<>();\n    }\n\n    public static synchronized EventBus getInstance() {\n        if (instance == null) {\n            instance = new EventBus();\n        }\n        return instance;\n    }\n\n    public void subscribe(String subscriber) {\n        subscribers.add(subscriber);\n    }\n\n    public void postEvent(String event) {\n        for (String subscriber : subscribers) {\n            System.out.println(\"Event sent to \" + subscriber + \": \" + event);\n        }\n    }\n\n}"
  },
    {
    "type": "ThreadLocalCounterSingleton",
    "input": "public class ThreadLocalCounter {\n\n    public ThreadLocalCounter() {}\n\n    public int incrementAndGet() {\n        return 0;\n    }\n\n}",
    "output": "public class ThreadLocalCounter {\n\n    private static final ThreadLocal<ThreadLocalCounter> threadLocalInstance = ThreadLocal.withInitial(ThreadLocalCounter::new);\n    private int counter;\n\n    private ThreadLocalCounter() {\n        counter = 0;\n    }\n\n    public static ThreadLocalCounter getInstance() {\n        return threadLocalInstance.get();\n    }\n\n    public int incrementAndGet() {\n        return ++counter;\n    }\n\n}"
  },
  {
    "type": "GlobalRateLimiterSingleton",
    "input": "public class RateLimiter {\n\n    public RateLimiter() {}\n\n    public boolean allowRequest(String clientId) {\n        return false;\n    }\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RateLimiter {\n\n    private static RateLimiter instance;\n    private ConcurrentHashMap<String, AtomicInteger> clientRequests;\n    private static final int MAX_REQUESTS = 5;\n\n    private RateLimiter() {\n        clientRequests = new ConcurrentHashMap<>();\n    }\n\n    public static synchronized RateLimiter getInstance() {\n        if (instance == null) {\n            instance = new RateLimiter();\n        }\n        return instance;\n    }\n\n    public boolean allowRequest(String clientId) {\n        clientRequests.putIfAbsent(clientId, new AtomicInteger(0));\n        AtomicInteger requestCount = clientRequests.get(clientId);\n        if (requestCount.get() < MAX_REQUESTS) {\n            requestCount.incrementAndGet();\n            return true;\n        } else {\n            System.out.println(\"Rate limit exceeded for: \" + clientId);\n            return false;\n        }\n    }\n\n}"
  },
  {
    "type": "SingletonWithTimeoutInitialization",
    "input": "public class TimedInitializer {\n\n    public TimedInitializer() {}\n\n    public void initialize() {\n        System.out.println(\"Initialized\");\n    }\n\n}",
    "output": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class TimedInitializer {\n\n    private static TimedInitializer instance;\n    private static final Lock lock = new ReentrantLock();\n\n    private TimedInitializer() {}\n\n    public static TimedInitializer getInstance() {\n        if (instance == null) {\n            try {\n                if (lock.tryLock()) {\n                    try {\n                        if (instance == null) {\n                            instance = new TimedInitializer();\n                        }\n                    } finally {\n                        lock.unlock();\n                    }\n                }\n            } catch (Exception e) {\n                System.out.println(\"Timeout during initialization\");\n            }\n        }\n        return instance;\n    }\n\n    public void initialize() {\n        System.out.println(\"Initialized\");\n    }\n\n}"
  },
  {
    "type": "SingletonWithCyclicDependencyGuard",
    "input": "public class CyclicDependencySingleton {\n\n    public CyclicDependencySingleton() {}\n\n}",
    "output": "public class CyclicDependencySingleton {\n\n    private static CyclicDependencySingleton instance;\n    private static boolean isCreating;\n\n    private CyclicDependencySingleton() {\n        if (isCreating) {\n            throw new IllegalStateException(\"Cyclic dependency detected!\");\n        }\n        isCreating = true;\n    }\n\n    public static synchronized CyclicDependencySingleton getInstance() {\n        if (instance == null) {\n            instance = new CyclicDependencySingleton();\n            isCreating = false;\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SingletonWithFallbackInstance",
    "input": "public class FallbackSingleton {\n\n    public FallbackSingleton() {}\n\n}",
    "output": "public class FallbackSingleton {\n\n    private static FallbackSingleton instance;\n    private static final FallbackSingleton fallbackInstance = new FallbackSingleton(\"fallback\");\n\n    private String mode;\n\n    private FallbackSingleton(String mode) {\n        this.mode = mode;\n    }\n\n    public static FallbackSingleton getInstance(boolean useFallback) {\n        if (useFallback) {\n            return fallbackInstance;\n        }\n        if (instance == null) {\n            instance = new FallbackSingleton(\"primary\");\n        }\n        return instance;\n    }\n\n    public String getMode() {\n        return mode;\n    }\n\n}"
  },
  {
    "type": "SelfDestructingSingleton",
    "input": "public class SelfDestructingInstance {\n\n    public SelfDestructingInstance() {}\n\n}",
    "output": "public class SelfDestructingInstance {\n\n    private static SelfDestructingInstance instance;\n    private static long lastAccessed;\n    private static final long TIMEOUT = 3000; // milliseconds\n\n    private SelfDestructingInstance() {}\n\n    public static synchronized SelfDestructingInstance getInstance() {\n        if (instance == null || (System.currentTimeMillis() - lastAccessed) > TIMEOUT) {\n            instance = new SelfDestructingInstance();\n        }\n        lastAccessed = System.currentTimeMillis();\n        return instance;\n    }\n\n}"
  },
  {
    "type": "DistributedLockingSingleton",
    "input": "public class DistributedLockManager {\n\n    public DistributedLockManager() {}\n\n    public boolean acquireLock(String key) {\n        return false;\n    }\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class DistributedLockManager {\n\n    private static DistributedLockManager instance;\n    private ConcurrentHashMap<String, Boolean> lockMap;\n\n    private DistributedLockManager() {\n        lockMap = new ConcurrentHashMap<>();\n    }\n\n    public static synchronized DistributedLockManager getInstance() {\n        if (instance == null) {\n            instance = new DistributedLockManager();\n        }\n        return instance;\n    }\n\n    public boolean acquireLock(String key) {\n        return lockMap.putIfAbsent(key, true) == null;\n    }\n\n    public void releaseLock(String key) {\n        lockMap.remove(key);\n    }\n\n}"
  },
  {
    "type": "SingletonWithObserverLifecycle",
    "input": "public class ObserverLifecycleManager {\n\n    public ObserverLifecycleManager() {}\n\n}",
    "output": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ObserverLifecycleManager {\n\n    private static ObserverLifecycleManager instance;\n    private List<String> events;\n\n    private ObserverLifecycleManager() {\n        events = new ArrayList<>();\n        onStart();\n    }\n\n    public static synchronized ObserverLifecycleManager getInstance() {\n        if (instance == null) {\n            instance = new ObserverLifecycleManager();\n        }\n        return instance;\n    }\n\n    public void onStart() {\n        System.out.println(\"Singleton started\");\n    }\n\n    public void onEvent(String event) {\n        events.add(event);\n        System.out.println(\"Event captured: \" + event);\n    }\n\n    public void onStop() {\n        events.clear();\n        System.out.println(\"Singleton stopped\");\n    }\n\n}"
  },
    {
    "type": "SynchronizedMethodSingleton",
    "input": "public class SynchronizedMethodSingleton {\n\n    public SynchronizedMethodSingleton() {}\n\n}",
    "output": "public class SynchronizedMethodSingleton {\n\n    private static SynchronizedMethodSingleton instance;\n\n    private SynchronizedMethodSingleton() {}\n\n    public static synchronized SynchronizedMethodSingleton getInstance() {\n        if (instance == null) {\n            instance = new SynchronizedMethodSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "DoubleCheckedLockingSingleton",
    "input": "public class DoubleCheckedLockingSingleton {\n\n    public DoubleCheckedLockingSingleton() {}\n\n}",
    "output": "public class DoubleCheckedLockingSingleton {\n\n    private static volatile DoubleCheckedLockingSingleton instance;\n\n    private DoubleCheckedLockingSingleton() {}\n\n    public static DoubleCheckedLockingSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DoubleCheckedLockingSingleton.class) {\n                if (instance == null) {\n                    instance = new DoubleCheckedLockingSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "BillPughSingleton",
    "input": "public class BillPughSingleton {\n\n    public BillPughSingleton() {}\n\n}",
    "output": "public class BillPughSingleton {\n\n    private BillPughSingleton() {}\n\n    private static class SingletonHelper {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n\n    public static BillPughSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "ThreadLocalSingleton",
    "input": "public class ThreadLocalSingleton {\n\n    public ThreadLocalSingleton() {}\n\n}",
    "output": "public class ThreadLocalSingleton {\n\n    private static final ThreadLocal<ThreadLocalSingleton> instance = ThreadLocal.withInitial(ThreadLocalSingleton::new);\n\n    private ThreadLocalSingleton() {}\n\n    public static ThreadLocalSingleton getInstance() {\n        return instance.get();\n    }\n\n}"
  },
  {
    "type": "EnumBasedSingleton",
    "input": "public class EnumBasedSingleton {\n\n    public EnumBasedSingleton() {}\n\n}",
    "output": "public enum EnumBasedSingleton {\n\n    INSTANCE;\n\n    public void performAction() {\n        System.out.println(\"Action performed by Singleton\");\n    }\n\n}"
  },
  {
    "type": "StaticBlockInitializationSingleton",
    "input": "public class StaticBlockInitializationSingleton {\n\n    public StaticBlockInitializationSingleton() {}\n\n}",
    "output": "public class StaticBlockInitializationSingleton {\n\n    private static StaticBlockInitializationSingleton instance;\n\n    static {\n        try {\n            instance = new StaticBlockInitializationSingleton();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error initializing singleton\", e);\n        }\n    }\n\n    private StaticBlockInitializationSingleton() {}\n\n    public static StaticBlockInitializationSingleton getInstance() {\n        return instance;\n    }\n\n}"
  },
  {
    "type": "VolatileLazyInitializationSingleton",
    "input": "public class VolatileLazyInitializationSingleton {\n\n    public VolatileLazyInitializationSingleton() {}\n\n}",
    "output": "public class VolatileLazyInitializationSingleton {\n\n    private static volatile VolatileLazyInitializationSingleton instance;\n\n    private VolatileLazyInitializationSingleton() {}\n\n    public static VolatileLazyInitializationSingleton getInstance() {\n        if (instance == null) {\n            synchronized (VolatileLazyInitializationSingleton.class) {\n                if (instance == null) {\n                    instance = new VolatileLazyInitializationSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "ThreadSafeLazyHolderSingleton",
    "input": "public class ThreadSafeLazyHolderSingleton {\n\n    public ThreadSafeLazyHolderSingleton() {}\n\n}",
    "output": "public class ThreadSafeLazyHolderSingleton {\n\n    private ThreadSafeLazyHolderSingleton() {}\n\n    private static class LazyHolder {\n        private static final ThreadSafeLazyHolderSingleton INSTANCE = new ThreadSafeLazyHolderSingleton();\n    }\n\n    public static ThreadSafeLazyHolderSingleton getInstance() {\n        return LazyHolder.INSTANCE;\n    }\n\n}"
  },
  {
    "type": "SynchronizedBlockSingleton",
    "input": "public class SynchronizedBlockSingleton {\n\n    public SynchronizedBlockSingleton() {}\n\n}",
    "output": "public class SynchronizedBlockSingleton {\n\n    private static SynchronizedBlockSingleton instance;\n\n    private SynchronizedBlockSingleton() {}\n\n    public static SynchronizedBlockSingleton getInstance() {\n        if (instance == null) {\n            synchronized (SynchronizedBlockSingleton.class) {\n                if (instance == null) {\n                    instance = new SynchronizedBlockSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "ThreadSafeInitializationOnDemandHolder",
    "input": "public class InitializationOnDemandHolderSingleton {\n\n    public InitializationOnDemandHolderSingleton() {}\n\n}",
    "output": "public class InitializationOnDemandHolderSingleton {\n\n    private InitializationOnDemandHolderSingleton() {}\n\n    private static class Holder {\n        private static final InitializationOnDemandHolderSingleton INSTANCE = new InitializationOnDemandHolderSingleton();\n    }\n\n    public static InitializationOnDemandHolderSingleton getInstance() {\n        return Holder.INSTANCE;\n    }\n\n}"
  },
    {
    "type": "EagerThreadSafeSingleton",
    "input": "public class EagerThreadSafeSingleton {\n\n    public EagerThreadSafeSingleton() {}\n\n}",
    "output": "public class EagerThreadSafeSingleton {\n\n    private static final EagerThreadSafeSingleton INSTANCE = new EagerThreadSafeSingleton();\n\n    private EagerThreadSafeSingleton() {}\n\n    public static EagerThreadSafeSingleton getInstance() {\n        return INSTANCE;\n    }\n\n}"
  },
  {
    "type": "SynchronizedDoubleCheckSingleton",
    "input": "public class SynchronizedDoubleCheckSingleton {\n\n    public SynchronizedDoubleCheckSingleton() {}\n\n}",
    "output": "public class SynchronizedDoubleCheckSingleton {\n\n    private static volatile SynchronizedDoubleCheckSingleton instance;\n\n    private SynchronizedDoubleCheckSingleton() {}\n\n    public static SynchronizedDoubleCheckSingleton getInstance() {\n        if (instance == null) {\n            synchronized (SynchronizedDoubleCheckSingleton.class) {\n                if (instance == null) {\n                    instance = new SynchronizedDoubleCheckSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SynchronizedAccessSingleton",
    "input": "public class SynchronizedAccessSingleton {\n\n    public SynchronizedAccessSingleton() {}\n\n}",
    "output": "public class SynchronizedAccessSingleton {\n\n    private static SynchronizedAccessSingleton instance;\n\n    private SynchronizedAccessSingleton() {}\n\n    public static SynchronizedAccessSingleton getInstance() {\n        synchronized (SynchronizedAccessSingleton.class) {\n            if (instance == null) {\n                instance = new SynchronizedAccessSingleton();\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "ConcurrentMapSingleton",
    "input": "public class ConcurrentMapSingleton {\n\n    public ConcurrentMapSingleton() {}\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentMapSingleton {\n\n    private static final ConcurrentHashMap<String, ConcurrentMapSingleton> instances = new ConcurrentHashMap<>();\n\n    private ConcurrentMapSingleton() {}\n\n    public static ConcurrentMapSingleton getInstance(String key) {\n        return instances.computeIfAbsent(key, k -> new ConcurrentMapSingleton());\n    }\n\n}"
  },
  {
    "type": "AtomicReferenceSingleton",
    "input": "public class AtomicReferenceSingleton {\n\n    public AtomicReferenceSingleton() {}\n\n}",
    "output": "import java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicReferenceSingleton {\n\n    private static final AtomicReference<AtomicReferenceSingleton> INSTANCE = new AtomicReference<>();\n\n    private AtomicReferenceSingleton() {}\n\n    public static AtomicReferenceSingleton getInstance() {\n        if (INSTANCE.get() == null) {\n            INSTANCE.compareAndSet(null, new AtomicReferenceSingleton());\n        }\n        return INSTANCE.get();\n    }\n\n}"
  },
  {
    "type": "ThreadSafeSingletonWithCounter",
    "input": "public class ThreadSafeSingletonWithCounter {\n\n    public ThreadSafeSingletonWithCounter() {}\n\n}",
    "output": "public class ThreadSafeSingletonWithCounter {\n\n    private static ThreadSafeSingletonWithCounter instance;\n    private int counter;\n\n    private ThreadSafeSingletonWithCounter() {\n        counter = 0;\n    }\n\n    public static synchronized ThreadSafeSingletonWithCounter getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingletonWithCounter();\n        }\n        return instance;\n    }\n\n    public synchronized void incrementCounter() {\n        counter++;\n    }\n\n    public synchronized int getCounter() {\n        return counter;\n    }\n\n}"
  },
  {
    "type": "ThreadSafeSingletonWithThreadPool",
    "input": "public class ThreadSafeSingletonWithThreadPool {\n\n    public ThreadSafeSingletonWithThreadPool() {}\n\n}",
    "output": "import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ThreadSafeSingletonWithThreadPool {\n\n    private static ThreadSafeSingletonWithThreadPool instance;\n    private ExecutorService executorService;\n\n    private ThreadSafeSingletonWithThreadPool() {\n        executorService = Executors.newFixedThreadPool(5);\n    }\n\n    public static synchronized ThreadSafeSingletonWithThreadPool getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingletonWithThreadPool();\n        }\n        return instance;\n    }\n\n    public ExecutorService getExecutorService() {\n        return executorService;\n    }\n\n}"
  },
  {
    "type": "ThreadSafeSingletonWithCache",
    "input": "public class ThreadSafeSingletonWithCache {\n\n    public ThreadSafeSingletonWithCache() {}\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\n\npublic class ThreadSafeSingletonWithCache {\n\n    private static ThreadSafeSingletonWithCache instance;\n    private Map<String, String> cache;\n\n    private ThreadSafeSingletonWithCache() {\n        cache = new ConcurrentHashMap<>();\n    }\n\n    public static synchronized ThreadSafeSingletonWithCache getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingletonWithCache();\n        }\n        return instance;\n    }\n\n    public synchronized void addToCache(String key, String value) {\n        cache.put(key, value);\n    }\n\n    public synchronized String getFromCache(String key) {\n        return cache.get(key);\n    }\n\n}"
  },
  {
    "type": "ThreadSafeSingletonWithLifecycle",
    "input": "public class ThreadSafeSingletonWithLifecycle {\n\n    public ThreadSafeSingletonWithLifecycle() {}\n\n}",
    "output": "public class ThreadSafeSingletonWithLifecycle {\n\n    private static ThreadSafeSingletonWithLifecycle instance;\n\n    private ThreadSafeSingletonWithLifecycle() {\n        onCreate();\n    }\n\n    public static synchronized ThreadSafeSingletonWithLifecycle getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingletonWithLifecycle();\n        }\n        return instance;\n    }\n\n    private void onCreate() {\n        System.out.println(\"Singleton created\");\n    }\n\n    public void onDestroy() {\n        System.out.println(\"Singleton destroyed\");\n        instance = null;\n    }\n\n}"
  },
  {
    "type": "SynchronizedWeakReferenceSingleton",
    "input": "public class SynchronizedWeakReferenceSingleton {\n\n    public SynchronizedWeakReferenceSingleton() {}\n\n}",
    "output": "import java.lang.ref.WeakReference;\n\npublic class SynchronizedWeakReferenceSingleton {\n\n    private static WeakReference<SynchronizedWeakReferenceSingleton> instance;\n\n    private SynchronizedWeakReferenceSingleton() {}\n\n    public static synchronized SynchronizedWeakReferenceSingleton getInstance() {\n        if (instance == null || instance.get() == null) {\n            instance = new WeakReference<>(new SynchronizedWeakReferenceSingleton());\n        }\n        return instance.get();\n    }\n\n}"
  },
    {
    "type": "SingletonWithRetryPolicy",
    "input": "public class RetryPolicy {\n\n    public RetryPolicy() {}\n\n    public void retry(String task) {\n        System.out.println(\"Retrying: \" + task);\n    }\n\n}",
    "output": "public class RetryPolicy {\n\n    private static RetryPolicy instance;\n    private int retryCount;\n\n    private RetryPolicy() {\n        retryCount = 0;\n    }\n\n    public static synchronized RetryPolicy getInstance() {\n        if (instance == null) {\n            instance = new RetryPolicy();\n        }\n        return instance;\n    }\n\n    public void retry(String task) {\n        retryCount++;\n        System.out.println(\"Retrying task: \" + task + \" - Retry Count: \" + retryCount);\n    }\n\n    public int getRetryCount() {\n        return retryCount;\n    }\n\n}"
  },
  {
    "type": "LazySingletonWithInitializationCheck",
    "input": "public class LazySingletonCheck {\n\n    public LazySingletonCheck() {}\n\n}",
    "output": "public class LazySingletonCheck {\n\n    private static LazySingletonCheck instance;\n\n    private LazySingletonCheck() {}\n\n    public static synchronized LazySingletonCheck getInstance() {\n        if (instance == null) {\n            instance = new LazySingletonCheck();\n        }\n        return instance;\n    }\n\n    public boolean isInitialized() {\n        return instance != null;\n    }\n\n}"
  },
  {
    "type": "SingletonWithSessionTimeout",
    "input": "public class SessionManager {\n\n    public SessionManager() {}\n\n    public void createSession(String user) {\n        System.out.println(\"Session created for: \" + user);\n    }\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class SessionManager {\n\n    private static SessionManager instance;\n    private Map<String, Long> sessions;\n    private ScheduledExecutorService scheduler;\n\n    private SessionManager() {\n        sessions = new HashMap<>();\n        scheduler = Executors.newScheduledThreadPool(1);\n        scheduler.scheduleAtFixedRate(() -> {\n            long currentTime = System.currentTimeMillis();\n            sessions.entrySet().removeIf(entry -> currentTime - entry.getValue() > 30000);\n        }, 0, 10, TimeUnit.SECONDS);\n    }\n\n    public static synchronized SessionManager getInstance() {\n        if (instance == null) {\n            instance = new SessionManager();\n        }\n        return instance;\n    }\n\n    public void createSession(String user) {\n        sessions.put(user, System.currentTimeMillis());\n        System.out.println(\"Session created for: \" + user);\n    }\n\n    public boolean isSessionActive(String user) {\n        return sessions.containsKey(user);\n    }\n\n}"
  },
  {
    "type": "SingletonWithDynamicResourcePool",
    "input": "public class ResourcePool {\n\n    public ResourcePool() {}\n\n}",
    "output": "import java.util.concurrent.ConcurrentLinkedQueue;\n\npublic class ResourcePool {\n\n    private static ResourcePool instance;\n    private ConcurrentLinkedQueue<String> resources;\n\n    private ResourcePool() {\n        resources = new ConcurrentLinkedQueue<>();\n    }\n\n    public static synchronized ResourcePool getInstance() {\n        if (instance == null) {\n            instance = new ResourcePool();\n        }\n        return instance;\n    }\n\n    public void addResource(String resource) {\n        resources.add(resource);\n    }\n\n    public String getResource() {\n        return resources.poll();\n    }\n\n}"
  },
  {
    "type": "DistributedSingleton",
    "input": "public class DistributedSingleton {\n\n    public DistributedSingleton() {}\n\n}",
    "output": "import java.util.concurrent.ConcurrentHashMap;\n\npublic class DistributedSingleton {\n\n    private static ConcurrentHashMap<String, DistributedSingleton> instances = new ConcurrentHashMap<>();\n\n    private DistributedSingleton() {}\n\n    public static DistributedSingleton getInstance(String region) {\n        return instances.computeIfAbsent(region, k -> new DistributedSingleton());\n    }\n\n}"
  },
  {
    "type": "SingletonWithPreloadedData",
    "input": "public class PreloadedDataSingleton {\n\n    public PreloadedDataSingleton() {}\n\n}",
    "output": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PreloadedDataSingleton {\n\n    private static PreloadedDataSingleton instance;\n    private Map<String, String> data;\n\n    private PreloadedDataSingleton() {\n        data = new HashMap<>();\n        data.put(\"Key1\", \"Value1\");\n        data.put(\"Key2\", \"Value2\");\n    }\n\n    public static synchronized PreloadedDataSingleton getInstance() {\n        if (instance == null) {\n            instance = new PreloadedDataSingleton();\n        }\n        return instance;\n    }\n\n    public String getData(String key) {\n        return data.get(key);\n    }\n\n}"
  },
  {
    "type": "SingletonWithRuntimeExceptionProtection",
    "input": "public class ProtectedSingleton {\n\n    public ProtectedSingleton() {}\n\n}",
    "output": "public class ProtectedSingleton {\n\n    private static ProtectedSingleton instance;\n\n    private ProtectedSingleton() {\n        if (instance != null) {\n            throw new RuntimeException(\"Instance already created\");\n        }\n    }\n\n    public static synchronized ProtectedSingleton getInstance() {\n        if (instance == null) {\n            instance = new ProtectedSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SingletonWithInitializationHooks",
    "input": "public class HookedSingleton {\n\n    public HookedSingleton() {}\n\n}",
    "output": "public class HookedSingleton {\n\n    private static HookedSingleton instance;\n\n    private HookedSingleton() {\n        initialize();\n    }\n\n    public static synchronized HookedSingleton getInstance() {\n        if (instance == null) {\n            instance = new HookedSingleton();\n        }\n        return instance;\n    }\n\n    private void initialize() {\n        System.out.println(\"Singleton Initialized\");\n    }\n\n}"
  },
  {
    "type": "SingletonWithOptionalInstance",
    "input": "public class OptionalSingleton {\n\n    public OptionalSingleton() {}\n\n}",
    "output": "import java.util.Optional;\n\npublic class OptionalSingleton {\n\n    private static OptionalSingleton instance;\n\n    private OptionalSingleton() {}\n\n    public static Optional<OptionalSingleton> getInstance() {\n        if (instance == null) {\n            instance = new OptionalSingleton();\n        }\n        return Optional.of(instance);\n    }\n\n}"
  },
    {
    "type": "ParameterizedLazySingleton",
    "input": "public class LazySingletonWithParameter {\n\n    public LazySingletonWithParameter(String config) {}\n\n}",
    "output": "public class LazySingletonWithParameter {\n\n    private static LazySingletonWithParameter instance;\n    private String config;\n\n    private LazySingletonWithParameter(String config) {\n        this.config = config;\n    }\n\n    public static LazySingletonWithParameter getInstance(String config) {\n        if (instance == null) {\n            instance = new LazySingletonWithParameter(config);\n        }\n        return instance;\n    }\n\n    public String getConfig() {\n        return config;\n    }\n\n}"
  },
  {
    "type": "ThreadSafeLazySingleton",
    "input": "public class ThreadSafeLazySingleton {\n\n    public ThreadSafeLazySingleton() {}\n\n}",
    "output": "public class ThreadSafeLazySingleton {\n\n    private static volatile ThreadSafeLazySingleton instance;\n\n    private ThreadSafeLazySingleton() {}\n\n    public static ThreadSafeLazySingleton getInstance() {\n        if (instance == null) {\n            synchronized (ThreadSafeLazySingleton.class) {\n                if (instance == null) {\n                    instance = new ThreadSafeLazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SingletonWithDynamicConfiguration",
    "input": "public class DynamicConfigSingleton {\n\n    public DynamicConfigSingleton(String environment) {}\n\n}",
    "output": "public class DynamicConfigSingleton {\n\n    private static DynamicConfigSingleton instance;\n    private String environment;\n\n    private DynamicConfigSingleton(String environment) {\n        this.environment = environment;\n    }\n\n    public static DynamicConfigSingleton getInstance(String environment) {\n        if (instance == null) {\n            instance = new DynamicConfigSingleton(environment);\n        }\n        return instance;\n    }\n\n    public String getEnvironment() {\n        return environment;\n    }\n\n}"
  },
  {
    "type": "SingletonWithMultipleConstructors",
    "input": "public class MultiConstructorSingleton {\n\n    public MultiConstructorSingleton() {}\n    public MultiConstructorSingleton(String config) {}\n\n}",
    "output": "public class MultiConstructorSingleton {\n\n    private static MultiConstructorSingleton instance;\n    private String config;\n\n    private MultiConstructorSingleton(String config) {\n        this.config = config;\n    }\n\n    private MultiConstructorSingleton() {}\n\n    public static MultiConstructorSingleton getInstance(String config) {\n        if (instance == null) {\n            instance = new MultiConstructorSingleton(config);\n        }\n        return instance;\n    }\n\n    public String getConfig() {\n        return config;\n    }\n\n}"
  },
  {
    "type": "SingletonWithInheritance",
    "input": "public class BaseClass {\n\n    public BaseClass() {}\n\n}\n\npublic class DerivedSingleton extends BaseClass {\n\n    public DerivedSingleton() {}\n\n}",
    "output": "public class BaseClass {\n\n    public BaseClass() {}\n\n}\n\npublic class DerivedSingleton extends BaseClass {\n\n    private static DerivedSingleton instance;\n\n    private DerivedSingleton() {}\n\n    public static DerivedSingleton getInstance() {\n        if (instance == null) {\n            instance = new DerivedSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SingletonWithInitializationLogging",
    "input": "public class LoggingSingleton {\n\n    public LoggingSingleton() {}\n\n}",
    "output": "public class LoggingSingleton {\n\n    private static LoggingSingleton instance;\n\n    private LoggingSingleton() {\n        System.out.println(\"LoggingSingleton initialized\");\n    }\n\n    public static LoggingSingleton getInstance() {\n        if (instance == null) {\n            instance = new LoggingSingleton();\n        }\n        return instance;\n    }\n\n}"
  },
  {
    "type": "SingletonWithImmutableState",
    "input": "public class ImmutableSingleton {\n\n    public ImmutableSingleton(String state) {}\n\n}",
    "output": "public class ImmutableSingleton {\n\n    private static ImmutableSingleton instance;\n    private final String state;\n\n    private ImmutableSingleton(String state) {\n        this.state = state;\n    }\n\n    public static ImmutableSingleton getInstance(String state) {\n        if (instance == null) {\n            instance = new ImmutableSingleton(state);\n        }\n        return instance;\n    }\n\n    public String getState() {\n        return state;\n    }\n\n}"
  },
  {
    "type": "ThreadLocalSingleton",
    "input": "public class ThreadLocalSingleton {\n\n    public ThreadLocalSingleton() {}\n\n}",
    "output": "public class ThreadLocalSingleton {\n\n    private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance = ThreadLocal.withInitial(ThreadLocalSingleton::new);\n\n    private ThreadLocalSingleton() {}\n\n    public static ThreadLocalSingleton getInstance() {\n        return threadLocalInstance.get();\n    }\n\n}"
  },
  {
    "type": "SingletonWithFallbackInstance",
    "input": "public class FallbackSingleton {\n\n    public FallbackSingleton() {}\n\n}",
    "output": "public class FallbackSingleton {\n\n    private static FallbackSingleton instance;\n\n    private FallbackSingleton() {}\n\n    public static FallbackSingleton getInstance() {\n        if (instance == null) {\n            try {\n                instance = new FallbackSingleton();\n            } catch (Exception e) {\n                instance = new FallbackSingleton(); // Fallback logic\n            }\n        }\n        return instance;\n    }\n\n}"
  }
]
