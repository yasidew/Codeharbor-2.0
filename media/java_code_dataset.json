[
    {
        "file_name": "EmployeeServiceImp1.java",
        "java_code": "package com.ishan.spa_techgig.service;\r\nimport java.util.*;\r\n\r\nimport com.ishan.spa_techgig.model.Employee;\r\nimport com.ishan.spa_techgig.repository.EmployeeRepository;\r\nimport org.springframework.beans.factory.annotation.*;\r\nimport org.springframework.data.domain.*;\r\nimport org.springframework.stereotype.*;\r\n\r\n//Service to fetch data and display including sorting function\r\n@Service\r\npublic class EmployeeServiceImp1 implements EmployeeService {\r\n    @Autowired\r\n    private EmployeeRepository employeeRepository;\r\n    @Override\r\n    public List<Employee> getAllEmployees() {\r\n        // TODO Auto-generated method stub\r\n        return employeeRepository.findAll();\r\n    }\r\n\r\n    @Override\r\n    public void saveEmployee(Employee employee) {\r\n        // TODO Auto-generated method stub\r\n        this.employeeRepository.save(employee);\r\n\r\n    }\r\n\r\n    @Override\r\n    public Employee getEmployeeById(Long id) {\r\n        // TODO Auto-generated method stub\r\n        Optional<Employee> optional = employeeRepository.findById(id);\r\n        Employee employee = null;\r\n        if (optional.isPresent()) {\r\n            employee = optional.get();\r\n        } else {\r\n            throw new RuntimeException(\"Employee not found by id: \" + id);\r\n        }\r\n        return employee;\r\n    }\r\n\r\n    @Override\r\n    public void deleteEmployeeById(Long id) {\r\n        // TODO Auto-generated method stub\r\n        this.employeeRepository.deleteById(id);\r\n    }\r\n\r\n    @Override\r\n    public Page<Employee> findPaginated(int pageNo, int pageSize, String sortField, String sortDirection) {\r\n        // TODO Auto-generated method stub\r\n        Sort sort = sortDirection.equalsIgnoreCase(Sort.Direction.ASC.name()) ? Sort.by(sortField).ascending()\r\n                : Sort.by(sortField).descending();\r\n        Pageable pageable = PageRequest.of(pageNo - 1, pageSize, sort);\r\n        return this.employeeRepository.findAll(pageable);\r\n    }\r\n\r\n}"
    },
    {
        "file_name": "10.ExceptionExamples.java",
        "java_code": "/*Question-\nCreate a program to take input from user as 1 /2 /3, if\nuser enters 1, display info about Arithmetic Exception, 2\nand 3 for Null pointer exception and Array index out of\nbound exception, respectively. Use, Try, Catch block for\neach exception individually.*/\n\n//Code-\nimport java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    String s=null;\n    int i=0;\n    while(i<3) {\n      System.out.println(\"Enter Value 1/2/3: \");\n      int n = sc.nextInt();\n      switch (n) {\n          //Arithmetic Exception\n        case 1:\n          try {\n            int data = 5 / 0;\n          }\n          catch (ArithmeticException e) {\n            System.out.println(e);\n          }\n          System.out.println(\"rest of the code\");\n          break;\n        case 2:\n          //Nullpointer Exception\n          try {\n            int m = s.length();\n          } \n          catch (NullPointerException f) {\n            System.out.println(f);\n          }\n          System.out.println(\"rest of code\");\n          break;\n        case 3:\n          try {\n            int arr[] = {1, 3, 5, 7};\n            System.out.println(arr[10]);\n          } catch (ArrayIndexOutOfBoundsException g) {\n            System.out.println(g);\n          }\n          System.out.println(\"rest of the code\");\n      }\n      i++;\n    }\n  }\n}\n"
    },
    {
        "file_name": "10.ExceptionExamples.java",
        "java_code": "/*Question-\nCreate a program to take input from user as 1 /2 /3, if\nuser enters 1, display info about Arithmetic Exception, 2\nand 3 for Null pointer exception and Array index out of\nbound exception, respectively. Use, Try, Catch block for\neach exception individually.*/\n\n//Code-\nimport java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    String s=null;\n    int i=0;\n    while(i<3) {\n      System.out.println(\"Enter Value 1/2/3: \");\n      int n = sc.nextInt();\n      switch (n) {\n          //Arithmetic Exception\n        case 1:\n          try {\n            int data = 5 / 0;\n          } catch (ArithmeticException e) {\n            System.out.println(e);\n          }\n          System.out.println(\"rest of the code\");\n          break;\n        case 2:\n          //Nullpointer Exception\n          try {\n            int m = s.length();\n          } catch (NullPointerException f) {\n            System.out.println(f);\n          }\n          System.out.println(\"rest of code\");\n          break;\n        case 3:\n          try {\n            int arr[] = {1, 3, 5, 7};\n            System.out.println(arr[10]);\n          } catch (ArrayIndexOutOfBoundsException g) {\n            System.out.println(g);\n          }\n          System.out.println(\"rest of the code\");\n      }\n      i++;\n    }\n  }\n}\n"
    },
    {
        "file_name": "10.ExceptionExamples.java",
        "java_code": "/*Question-\nCreate a program to take input from user as 1 /2 /3, if\nuser enters 1, display info about Arithmetic Exception, 2\nand 3 for Null pointer exception and Array index out of\nbound exception, respectively. Use, Try, Catch block for\neach exception individually.*/\n\n//Code-\nimport java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    String s=null;\n    int i=0;\n    while(i<3) {\n      System.out.println(\"Enter Value 1/2/3: \");\n      int n = sc.nextInt();\n      switch (n) {\n          //Arithmetic Exception\n        case 1:\n          try {\n            int data = 5 / 0;\n          } \n          catch (ArithmeticException e) {\n            System.out.println(e);\n          }\n          System.out.println(\"rest of the code\");\n          break;\n        case 2:\n          //Nullpointer Exception\n          try {\n            int m = s.length();\n          } \n          catch (NullPointerException f) {\n            System.out.println(f);\n          }\n          System.out.println(\"rest of code\");\n          break;\n        case 3:\n          try {\n            int arr[] = {1, 3, 5, 7};\n            System.out.println(arr[10]);\n          } \n          catch (ArrayIndexOutOfBoundsException g) {\n            System.out.println(g);\n          }\n          System.out.println(\"rest of the code\");\n      }\n      i++;\n    }\n  }\n}\n"
    },
    {
        "file_name": "10.ExceptionExamples.java",
        "java_code": "\nimport java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    String s=null;\n    int i=0;\n    while(i<3) {\n      System.out.println(\"Enter Value 1/2/3: \");\n      int n = sc.nextInt();\n      switch (n) {\n          //Arithmetic Exception\n        case 1:\n          try {\n            int data = 5 / 0;\n          } \n          catch (ArithmeticException e) {\n            System.out.println(e);\n          }\n          System.out.println(\"rest of the code\");\n          break;\n        case 2:\n          //Nullpointer Exception\n          try {\n            int m = s.length();\n          } \n          catch (NullPointerException f) {\n            System.out.println(f);\n          }\n          System.out.println(\"rest of code\");\n          break;\n        case 3:\n          try {\n            int arr[] = {1, 3, 5, 7};\n            System.out.println(arr[10]);\n          } \n          catch (ArrayIndexOutOfBoundsException g) {\n            System.out.println(g);\n          }\n          System.out.println(\"rest of the code\");\n      }\n      i++;\n    }\n  }\n}\n"
    },
    {
        "file_name": "2.BMIcalculator.java",
        "java_code": "//Question - BMI calculator using Java \n\n//Code - \n// Calculate BMI using Math function in Java\n// Find BMI of a person by getting weight and\n//height in kg and cm respectively from user. [Formula BMI = kg/m2]\n\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        \n        // Scanner function \n        Scanner test=new Scanner(System.in);\n        System.out.println(\"Enter your weight in kg:\");\n        \n        float weight=test.nextFloat(); // Input weight\n        System.out.println(\"Enter your height in cm:\");\n        \n        float height=test.nextFloat(); // Input height\n        System.out.println(\"Your weight is \"+weight+\" kg\");\n        \n        float height_m=height/100; // Convert height in meter\n        System.out.println(\"Your height is in meter is : \"+height_m+\" m\");\n       \n        double m=Math.pow(height_m,height_m); // Applying formula\n        double BMI=weight/m;\n        \n        //Output BMI \n        System.out.println(\"Your BMI is \"+BMI);\n    }\n}\n"
    },
    {
        "file_name": "3.Vowelgram.java",
        "java_code": "//Question - Vowelgram program using Java\n\n//Code -\nimport java.util.Scanner;\n\npublic class vowelgram {\n\n    public static void main(String[] args) {\n        vowelgram.check();\n    }\n    static void check(){\n        int a = 0,e=0,i=0,o=0,u=0;\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter string:\");\n        String sen = sc.nextLine();\n        sen = sen.toLowerCase();\n        char ch = 0;\n        for (int j = 0; j < sen.length(); ++j) {\n            ch = sen.charAt(j);\n\n            switch (ch) {\n                case 'a':\n                    a = a + 1;\n                    break;\n                case 'e':\n                    e = e + 1;\n                    break;\n                case 'i':\n                    i = i + 1;\n                    break;\n                case 'o':\n                    o = o + 1;\n                    break;\n                case 'u':\n                    u = u + 1;\n                    break;\n            }\n        }\n            if(a>=1 && e>=1 && i>=1 && o>=1 && u>=1){\n                System.out.println(\"Sentence is Vowelgram\");\n            }\n            else{\n                System.out.println(\"Sentence is Not vowelgram\");\n            }\n        }\n    }\n"
    },
    {
        "file_name": "4.Hostel_registration.java",
        "java_code": "package Reg;\n\n//Hostel Class\nclass Hostel implements Serializable {\n    String BlockName;\n    room r[] = new room[2];\n    static int booking;\n\n    Hostel(String BlockName, int n) {\n        this.BlockName = BlockName;\n        for (int i = 0; i < n; i++) {\n            r[i] = new room();\n        }\n        r[0] = new room(101, 2);\n        r[1] = new room(102, 2);\n    }\n\n    synchronized int Book(student[] sortedCGPA) throws InterruptedException {\n        for (student sortedCGPA1 : sortedCGPA) {\n            if (sortedCGPA1.allocatedroom == 0) {\n                for (room r1 : r) {\n                    if ((sortedCGPA1.prefroom == r1.roomno) && (r1.allotedno < r1.Size)) {\n                        sortedCGPA1.allocatedroom = sortedCGPA1.prefroom;\n                        r1.allotedno = r1.allotedno + 1;\n                        booking=booking+1;\n                        if(booking==1){\n                            wait(); }}\n                        if(booking>1&&booking<sortedCGPA.length-2){\n                            notifyAll();\n                            wait(); }}\n                        for (student o1:sortedCGPA){\n                            System.out.println(\"Details: \"+\" \"+o1.Regno+\" \"+o1.Name+\" \"+o1.CGPA+\" \"+o1.prefroom);\n                        }\n                    }\n                }\n                if(booking==sortedCGPA.length-1){\n                    return 1;\n                }\n                return 0;\n            }\n        }\n"
    },
    {
        "file_name": "11.Throwexample.java",
        "java_code": "\nimport java.util.Scanner;\n\npublic class throwexample {\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    System.out.println(\"Enter a number :\");\n    try\n    {\n      int num = sc.nextInt();\n      try\n      {\n        if(num < 0)\n        {\n          throw new UserDefinedException(\"Number is negative\");\n        }\n        else if(num >= 0 && num <= 25)\n        {\n          throw new UserDefinedException(\"Number is in the range of 0-25\");\n        }\n      }\n      catch (UserDefinedException e){System.out.println(e);}\n      finally\n      {\n        System.out.println(\"The number entered by the user is: \" + num); //this code is always executed\n      }\n    }\n    catch (Exception e)\n    {\n      System.out.println(e);\n    }\n  }\n}\n"
    },
    {
        "file_name": "13.Rotiproblem.java",
        "java_code": "\n//MOM Class\npackage pack1;\nimport pack1.stackvessel;\npublic class MOM implements Runnable {\n  private final stackvessel<Integer> SizedStack;\n  public MOM(stackvessel<Integer> mySizedStack) {\n    this.SizedStack = mySizedStack;\n  }\n  @Override\n  public void run() {\n    try {\n      for(int i = 1 ; i < 11 ; i++) {\n        insertAnElement(i);\n      }\n    } catch (InterruptedException ex) {System.out.println(ex);}\n  }\n  public void insertAnElement(int number) throws InterruptedException\n  {\n    while(SizedStack.size() == 5) {\n      synchronized (SizedStack) {\n        System.out.println(\"Vessel is full. MOM is waiting...\");\n        SizedStack.wait();\n      }\n    }\n    synchronized (SizedStack) {\n      SizedStack.push(number);\n      SizedStack.notifyAll();\n      System.out.println(\"MOM put Roti in vessel: \" + number + \" to queue.\");\n    }\n  }\n}\n"
    },
    {
        "file_name": "15.Count_word_in_file.java",
        "java_code": "/*Question - Traverse a file and count the words \u201cCSE1007\u201d and \u201cJAVA\u201d, print the counts in the console.*/\n//Ans:\nimport java.io.*;\nimport java.util.regex.*;\npublic class Traverse_File_19BCE2250 {\n    public static void main(String[] args) {\n        String w = \"\";\n        try {\n            FileReader fileR = new FileReader(\"File_Location\");\n            int num;\n            while ((num = fileR.read()) != -1) {\n                w = w + (char) num;\n            }\n        } catch (Exception e) {\n            System.out.print(\"error in reading the file\");\n        }\n        Pattern C1 = Pattern.compile(\"CSE1007\");\n        Matcher M1 = C1.matcher(w);\n        int CSE1007_count = 0;\n        while (M1.find()){\n            CSE1007_count++;\n        }\n        Pattern C2 = Pattern.compile(\"JAVA\");\n        Matcher M2 = C2.matcher(w);\n        int JAVA_count = 0;\n        while (M2.find()){\n            JAVA_count++;\n        }\n        System.out.println(w);\n        System.out.println(\"the total number of words CSE1007 is \" + CSE1007_count);\n        System.out.println(\"the total number of words JAVA is \" + JAVA_count);\n    }\n}\n"
    },
    {
        "file_name": "24.smallest_largest_digit.java",
        "java_code": "import java.util.Scanner;\n/*\nDeveloped By Ishan\nFind smallest and largest digit in number using Math package\n */\npublic class smallest_largest_digit {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter number:\");\n        int n = sc.nextInt();\n        int smallest = 9;\n        int largest = 0;\n        while(n != 0)\n        {\n            int r = n % 10;\n            largest = Math.max(r,largest);\n            smallest = Math.min(r, smallest);\n            n = n / 10;\n        }\n        System.out.println(\"Smallest no:\"+smallest);\n        System.out.println(\"Largest no:\"+largest);\n    }\n}\n"
    },
    {
        "file_name": "25.sort_hashmap.java",
        "java_code": "//Sort Hashmap based on key values using Treemap\nimport java.util.*;\npublic class sort_hashmap {\n    public static void main(String[] args) {\n        HashMap<Integer,String> hash_map  = new HashMap<>();\n        int n;\n        String map_value;\n        int map_key;\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter size of Hash map: \");\n        n = sc.nextInt();\n        //User-input and put function to insert into hashmap\n        for(int i=0;i<n;i++){\n            System.out.println(\"Enter key in hash-map at \"+(i+1));\n            map_key = sc.nextInt();\n            System.out.println(\"Enter value in hash-map at \"+(i+1));\n            map_value = sc.next();\n            hash_map.put(map_key,map_value);\n        }\n        System.out.println(\"Sorting Hash map based on key \");\n        TreeMap<Integer, String> tree_map = new TreeMap<>(hash_map);\n        for (Integer integer : tree_map.keySet()) {\n            int key = integer;\n            System.out.println(key + \": \" + hash_map.get(key));\n        }\n    }\n}\n"
    },
    {
        "file_name": "registration.java",
        "java_code": "public class registration  {\r\n    public static void main(String[] args) throws FileNotFoundException,IOException,ClassNotFoundException {\r\n       \r\n        //ArrayList\r\n        List<student> stuList=new ArrayList<student>();\r\n        stuList.add(new student(\"19BCE2010\",\"Rahul\",8.62f,101));\r\n        stuList.add(new student(\"19BCE0210\",\"Ram\",9.62f,102));  //Inserting Data\r\n        stuList.add(new student(\"19BCE1200\",\"Arjun\",7.62f,102));\r\n\r\n\r\n\r\n        // Input in file\r\n        FileOutputStream fout=new FileOutputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\Reg.txt\");\r\n        ObjectOutputStream ob1=new ObjectOutputStream(fout);\r\n        ob1.writeObject(stuList);\r\n        ob1.close();\r\n        System.out.println(\"Done Writing\");\r\n\r\n        //Output of file\r\n        FileInputStream fin=new FileInputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\Reg.txt\");\r\n        ObjectInputStream i1=new ObjectInputStream(fin);\r\n        ArrayList<student> Nlist =new ArrayList<student>();\r\n\r\n        //Traversing through List\r\n        while (fin.available()!=0){\r\n            Nlist=(ArrayList<student>)i1.readObject();\r\n        }\r\n        Nlist.sort((o1,o2)->{\r\n            return (int)(o1.CGPA-o2.CGPA);});\r\n            \r\n        Collections.reverse(Nlist);\r\n        Nlist.forEach(o->System.out.println(\"Details: \"+\" \"+o.Regno+\" \"+o.Name+\" \"+o.CGPA+\" \"+o.prefroom));\r\n        i1.close();\r\n        student[] sortedCGPA=Nlist.toArray(new student[Nlist.size()] );\r\n        //System.out.println(student[0].R);\r\n        Hostel B1=new Hostel (\"Block\",2);\r\n        warden w1=new warden(B1,sortedCGPA);\r\n        warden w2=new warden(B1,sortedCGPA);\r\n        w1.start();\r\n        w2.start();\r\n        System.out.println(\"\\n\");\r\n        System.out.println(\"Proceeding for result >>.... \");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "registration.java",
        "java_code": "public class registration  {\r\n    public static void main(String[] args) {\r\n       \r\n        //ArrayList\r\n        List<student> stuList=new ArrayList<student>();\r\n        stuList.add(new student(\"19BCE2010\",\"Rahul\",8.62f,101));\r\n        stuList.add(new student(\"19BCE0210\",\"Ram\",9.62f,102));  //Inserting Data\r\n        stuList.add(new student(\"19BCE1200\",\"Arjun\",7.62f,102));\r\n\r\n\r\n\r\n        // Input in file\r\n        FileOutputStream fout=new FileOutputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\Reg.txt\");\r\n        ObjectOutputStream ob1=new ObjectOutputStream(fout);\r\n        ob1.writeObject(stuList);\r\n        ob1.close();\r\n        System.out.println(\"Done Writing\");\r\n\r\n        //Output of file\r\n        FileInputStream fin=new FileInputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\Reg.txt\");\r\n        ObjectInputStream i1=new ObjectInputStream(fin);\r\n        ArrayList<student> Nlist =new ArrayList<student>();\r\n\r\n        //Traversing through List\r\n        while (fin.available()!=0){\r\n            Nlist=(ArrayList<student>)i1.readObject();\r\n        }\r\n        Nlist.sort((o1,o2)->{\r\n            return (int)(o1.CGPA-o2.CGPA);});\r\n            \r\n        Collections.reverse(Nlist);\r\n        Nlist.forEach(o->System.out.println(\"Details: \"+\" \"+o.Regno+\" \"+o.Name+\" \"+o.CGPA+\" \"+o.prefroom));\r\n        i1.close();\r\n        student[] sortedCGPA=Nlist.toArray(new student[Nlist.size()] );\r\n        //System.out.println(student[0].R);\r\n        Hostel B1=new Hostel (\"Block\",2);\r\n        warden w1=new warden(B1,sortedCGPA);\r\n        warden w2=new warden(B1,sortedCGPA);\r\n        w1.start();\r\n        w2.start();\r\n        System.out.println(\"\\n\");\r\n        System.out.println(\"Proceeding for result >>.... \");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "FirstDerivedClass.java",
        "java_code": "public class FirstDerivedClass extends BaseClass {\r\n    public void firstDerivedMethod() {\r\n        System.out.println(\"FirstDerivedClass method.\");\r\n    }\r\n    public void checkConditions(int x, int y) {\r\n        if (x > 0 && y > 0) {\r\n            System.out.println(\"Both x and y are positive.\");\r\n        }else if (x > 0 || y > 0) {\r\n            System.out.println(\"Either x or y is positive.\");\r\n        }else {\r\n            System.out.println(\"Neither x nor y is positive.\");\r\n        }\r\n    }\r\n    public void ttttt(int[] arr) {\r\n        try {\r\n            System.out.println(arr[5]);\r\n        } catch (ArrayIndexOutOfBoundsException e) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + e.getMessage());\r\n        } finally {\r\n            System.out.println(\"Finally block executed.\");\r\n        }\r\n    }\r\n    public class yyy{\r\n        public void nestedMethod() {\r\n            System.out.println(\"Nested class method in FirstDerivedClass.\");\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "SecondDerivedClass.java",
        "java_code": "public class SecondDerivedClass extends FirstDerivedClass {\r\n    // Second derived class content\r\n    public void secondDerivedMethod() {\r\n        System.out.println(\"SecondDerivedClass method.\");\r\n    }\r\n\r\n    // Example of a loop\r\n    public void loopExample() {\r\n        for (int i = 0; i < 5; i++) {\r\n            System.out.println(\"Loop iteration: \" + i);\r\n        }\r\n    }\r\n\r\n    // Creating a thread using Runnable\r\n    public void threadExample() {\r\n        Thread thread = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(\"Thread is running...\");\r\n                for (int i = 1; i <= 5; i++) {\r\n                    System.out.println(\"Thread loop count: \" + i);\r\n                }\r\n            }\r\n        });\r\n        thread.start();\r\n    }\r\n\r\n    // Nested method calls\r\n    public void nestedMethodCalls() {\r\n        baseMethod();              // Call method from BaseClass\r\n        firstDerivedMethod();       // Call method from FirstDerivedClass\r\n        secondDerivedMethod();      // Call method from SecondDerivedClass\r\n    }\r\n\r\n    // Compound condition inside a loop\r\n    public void compoundConditionLoop() {\r\n        for (int i = 0; i < 10; i++) {\r\n            if (i % 2 == 0 && i > 5) {\r\n                System.out.println(\"Even number greater than 5: \" + i);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        SecondDerivedClass obj = new SecondDerivedClass();\r\n\r\n        // Method calls\r\n        obj.loopExample();\r\n        obj.threadExample();\r\n        obj.nestedMethodCalls();\r\n        obj.checkConditions(5, -1);\r\n        obj.tryCatchExample(new int[] {1, 2, 3});\r\n        obj.compoundConditionLoop();\r\n\r\n        // Using nested class\r\n        FirstDerivedClass.NestedClass nestedObj = obj.new NestedClass();\r\n        nestedObj.nestedMethod();\r\n    }\r\n}"
    },
    {
        "file_name": "Engine.java",
        "java_code": "class Engine {\r\n    void start() {\r\n        System.out.println(\"Engine starts\");\r\n    }\r\n}\r\n\r\nclass Car {\r\n    Engine engine;                         // Aggregation: declared but not initialized\r\n    Engine engine2 = new Engine();         // Composition: initialized with `new`\r\n\r\n    Car() {\r\n        engine = new Engine();             // Composition: initialized in the constructor\r\n    }\r\n\r\n    void startCar() {\r\n        Engine engine1 = new Engine();     // Composition: local variable instantiated\r\n    }\r\n}"
    },
    {
        "file_name": "Example1.java",
        "java_code": "public class Example {\r\n    private Service service;\r\n    private Repository repository;\r\n\r\n    \r\n    public Example(Service service, Repository repository) {\r\n        this.service = service;\r\n        this.repository = repository;\r\n    }\r\n    public void performAction() {\r\n        service.performService();\r\n        repository.save();\r\n    }\r\n\r\n    public void setDepartment(Service service) {\r\n        this.service = service; // Dependency Injection\r\n    }\r\n\r\n    public void createDepartment() {\r\n        Department dept = new Department(); // Direct Object Instantiation\r\n        Database.connect();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "file_name": "HighCBOExample.java",
        "java_code": "public class HighCBOExample implements DataService, Logger, ReportGenerator {\r\n\r\n    private DatabaseConnection dbConnection;\r\n    private FileLogger fileLogger;\r\n    private ReportService reportService;\r\n\r\n    // Constructor injection (increases CBO)\r\n    public HighCBOExample(DatabaseConnection dbConnection, FileLogger fileLogger, ReportService reportService) {\r\n        this.dbConnection = dbConnection;\r\n        this.fileLogger = fileLogger;\r\n        this.reportService = reportService;\r\n    }\r\n\r\n    // Setter injection (increases CBO)\r\n    public void setDbConnection(DatabaseConnection dbConnection) {\r\n        this.dbConnection = dbConnection;\r\n    }\r\n\r\n    public void setFileLogger(FileLogger fileLogger) {\r\n        this.fileLogger = fileLogger;\r\n    }\r\n\r\n    public void setReportService(ReportService reportService) {\r\n        this.reportService = reportService;\r\n    }\r\n\r\n    @Override\r\n    public void fetchData() {\r\n        dbConnection.connect();\r\n        List<String> data = dbConnection.getData();\r\n        System.out.println(\"Data fetched: \" + data);\r\n    }\r\n\r\n    @Override\r\n    public void log(String message) {\r\n        fileLogger.writeLog(message);\r\n    }\r\n\r\n    @Override\r\n    public void generateReport() {\r\n        List<String> data = dbConnection.getData();\r\n        String report = reportService.createReport(data);\r\n        System.out.println(\"Generated Report: \" + report);\r\n    }\r\n\r\n    // Static method calls (increases CBO)\r\n    public void performStaticOperations() {\r\n        UtilityClass.printMessage(\"Performing static operations...\");\r\n        int result = MathHelper.add(5, 10);\r\n        System.out.println(\"Math result: \" + result);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        DatabaseConnection db = new DatabaseConnection();\r\n        FileLogger logger = new FileLogger();\r\n        ReportService reportService = new ReportService();\r\n\r\n        HighCBOExample example = new HighCBOExample(db, logger, reportService);\r\n        example.fetchData();\r\n        example.log(\"Sample log message.\");\r\n        example.generateReport();\r\n        example.performStaticOperations();\r\n    }\r\n}"
    },
    {
        "file_name": "HighCouplingExample.java",
        "java_code": "class HighCouplingExample {\r\n    private static int counter; // Static variable\r\n    private List<String> items;\r\n    private Map<String, Integer> dataMap;\r\n    private DatabaseService dbService;\r\n    private Logger logger;\r\n\r\n    public void processData() {\r\n        Logger.log(\"Processing data...\"); // Static method call\r\n        dbService.connect(); // Directly calling external class method\r\n        dbService.executeQuery(\"SELECT * FROM users\");\r\n        System.out.println(\"Data processed.\");\r\n    }\r\n\r\n    public void addItem(String item) {\r\n        items.add(item);\r\n    }\r\n\r\n    public void setDbService(DatabaseService dbService) {\r\n        this.dbService = dbService;\r\n    }\r\n\r\n    public void setLogger(Logger logger) { \r\n        this.logger = logger;\r\n    }\r\n\r\n    public void incrementCounter() { \r\n        counter++;\r\n    }\r\n}"
    },
    {
        "file_name": "MyApplication.java",
        "java_code": "package com.journaldev.java.legacy;\r\n\r\npublic class MyApplication {\r\n\r\n\tprivate EmailService email = null;\r\n\t\r\n\tpublic MyApplication(EmailService svc){\r\n\t\tthis.email=svc;\r\n\t}\r\n\t\r\n\tpublic void processMessages(String msg, String rec){\r\n\t\t//do some msg validation, manipulation logic etc\r\n\t\tthis.email.sendEmail(msg, rec);\r\n\t}\r\n}"
    },
    {
        "file_name": "BaseClass.java",
        "java_code": "public class BaseClass {\r\n   public void baseMethod() {\r\n        System.out.println(\"BaseClass method.\");\r\n    }\r\n}"
    },
    {
        "file_name": "HighCouplingExample.java",
        "java_code": "class HighCouplingExample {\r\n    private static int counter; // Static variable\r\n    private List<String> items;\r\n    private Map<String, Integer> dataMap;\r\n    private DatabaseService dbService;\r\n    private Logger logger;\r\n\r\n    public void processData() {\r\n        logger.log(\"Processing data...\"); // Static method call\r\n        dbService.connect(); // Directly calling external class method\r\n        dbService.executeQuery(\"SELECT * FROM users\");\r\n        System.out.println(\"Data processed.\");\r\n    }\r\n\r\n    public void addItem(String item) {\r\n        items.add(item);\r\n    }\r\n\r\n    public void setDbService(DatabaseService dbService) {\r\n        this.dbService = dbService;\r\n    }\r\n\r\n    public void setLogger(Logger logger) { \r\n        this.logger = logger;\r\n    }\r\n\r\n    public void incrementCounter() { \r\n        counter++;\r\n    }\r\n}"
    },
    {
        "file_name": "Order.java",
        "java_code": "class Order {\r\n    private DatabaseConnection dbConnection; // Constructor Injection\r\n    private PaymentGateway paymentGateway;\r\n    private EmailService emailService;\r\n    private List<String> items;\r\n\r\n    public Order(DatabaseConnection dbConnection, PaymentGateway paymentGateway, EmailService emailService) {\r\n        this.dbConnection = dbConnection;\r\n        this.paymentGateway = paymentGateway;\r\n        this.emailService = emailService;\r\n        this.items = new ArrayList<>();\r\n    }\r\n\r\n    public void addItem(String item) {\r\n        items.add(item);\r\n        Logger.log(\"Added item: \" + item);\r\n    }\r\n\r\n    public void checkout(double totalAmount, String email) {\r\n        dbConnection.connect(); // Direct Instance Call\r\n        paymentGateway.processPayment(totalAmount); // Calling another class method\r\n        emailService.sendEmail(email, \"Order Confirmation\", \"Your order has been placed.\");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TestDeadlockExample1.java",
        "java_code": "public class TestDeadlockExample1 {  \r\n  public static void main(String[] args) {  \r\n    final String resource1 = \"ratan jaiswal\";  \r\n    final String resource2 = \"vimal jaiswal\";  \r\n\r\n    Thread t1 = new Thread() {  \r\n      public void run() {  \r\n          synchronized (resource1) {  \r\n           System.out.println(\"Thread 1: locked resource 1\");  \r\n  \r\n           synchronized (resource2) {  \r\n            System.out.println(\"Thread 1: locked resource 2\");  \r\n           }  \r\n         }  \r\n      }  \r\n    };  \r\n   \r\n    Thread t2 = new Thread() {  \r\n      public void run() {  \r\n        synchronized (resource2) {  \r\n          System.out.println(\"Thread 2: locked resource 2\");  \r\n  \r\n          try { \r\n            Thread.sleep(100);\r\n            } catch (Exception e) {}  \r\n  \r\n          synchronized (resource1) {  \r\n            System.out.println(\"Thread 2: locked resource 1\");  \r\n          }  \r\n        }  \r\n      }  \r\n    };  \r\n  \r\n      \r\n    t1.start();  \r\n    t2.start();  \r\n  }  \r\n}     "
    },
    {
        "file_name": "TransactionProcessor.java",
        "java_code": "public class TransactionProcessor {\r\n    private static final int MAX_ATTEMPTS = 3;\r\n    private final ExternalService externalService;\r\n    private final PaymentGateway paymentGateway;\r\n    public TransactionProcessor(ExternalService externalService, PaymentGateway paymentGateway) {\r\n        this.externalService = externalService;\r\n        this.paymentGateway = paymentGateway;\r\n    }\r\n    public void processTransaction(Transaction tx) {\r\n        if (tx == null) {\r\n            throw new IllegalArgumentException(\"Transaction cannot be null\");\r\n        }\r\n        int attempts = 0;\r\n        boolean success = false;\r\n        while (attempts < MAX_ATTEMPTS && !success) {\r\n            attempts++;\r\n            try {\r\n                if (!paymentGateway.charge(tx.getCardInfo(), tx.getAmount())) {\r\n                    System.out.println(\"Payment failed. Attempt #\" + attempts);\r\n                    continue;  \r\n                }\r\n            } catch (InsufficientFundsException e) {\r\n                System.err.println(\"Insufficient funds: \" + e.getMessage());\r\n                break;\r\n            } catch (ServiceUnavailableException e) {\r\n                System.err.println(\"Service unavailable, retrying... \" + e.getMessage());\r\n            } catch (Exception e) {\r\n                System.err.println(\"Unexpected error: \" + e.getMessage());\r\n            }\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "VariedExample6.java",
        "java_code": "public class VariedExample6 {\r\n    public void execute() {\r\n        for (int i = 0; i < 5; i++) { \r\n            for (int j = 0; j < 5; j++) { \r\n                try { \r\n                    if (i + j > 3) { \r\n                        System.out.println(\"High complexity logic\"); \r\n                    } \r\n                } catch (Exception e) { \r\n                    e.printStackTrace(); \r\n                } \r\n            } \r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "BankingSystem.java",
        "java_code": "class User implements TransactionObserver {\r\n    private String name;\r\n\r\n    public User(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public void update(String message) {\r\n        System.out.println(name + \" received notification: \" + message);\r\n    }\r\n}\r\n\r\npublic class BankingSystem {\r\n    private final List<TransactionObserver> observers = new ArrayList<>();\r\n    \r\n    public static void main(String[] args) {\r\n        BankingSystem bankingSystem = new BankingSystem();\r\n        User user1 = new User(\"Alice\");\r\n        User user2 = new User(\"Bob\");\r\n\r\n        bankingSystem.addObserver(user1);\r\n        bankingSystem.addObserver(user2);\r\n\r\n        CheckingAccount account = new CheckingAccount(500);\r\n        Transaction transaction = new Transaction(account);\r\n\r\n        ExecutorService executor = Executors.newFixedThreadPool(2);\r\n\r\n        executor.submit(() -> {\r\n            transaction.performTransaction(200, true);\r\n            bankingSystem.notifyObservers(\"Alice deposited $200.\");\r\n        });\r\n\r\n        executor.submit(() -> {\r\n            transaction.performTransaction(300, false);\r\n            bankingSystem.notifyObservers(\"Alice withdrew $300.\");\r\n        });\r\n\r\n        executor.shutdown();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "Service.java",
        "java_code": "\r\nclass Consumer {\r\n    private Service service;\r\n\r\n    Consumer(Service service) { // Dependency Injection\r\n        this.service = service;\r\n    }\r\n\r\n    void setService(Service service) { // Setter Injection\r\n        this.service = service;\r\n    }\r\n\r\n    void useService() {\r\n        service.performService();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "MyClass.java",
        "java_code": "public class MyClass extends SuperClass {\r\n\r\n    public MyClass(AnotherClass param) {\r\n        \r\n    }\r\n\r\n    public void processList(List<MyClass> list) {\r\n    }\r\n\r\n    public void createObject() {\r\n        MyClass obj = new MyClass(new AnotherClass());\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        MyClass myClass = new MyClass(new AnotherClass());\r\n        myClass.createObject();\r\n    }\r\n}"
    },
    {
        "file_name": "registration.java",
        "java_code": "import java.util.*;\r\nimport java.io.*;\r\n\r\n// Note: The following classes (student, Hostel, warden) are assumed to be defined elsewhere.\r\n// They are used here to illustrate high coupling.\r\n\r\npublic class registration {\r\n    public static void main(String[] args) throws Exception {\r\n        // Directly instantiating and tightly coupling with a concrete implementation of student.\r\n        List<student> stuList = new ArrayList<student>();\r\n        stuList.add(new student(\"19BCE2010\", \"Rahul\", 8.62f, 101));\r\n        stuList.add(new student(\"19BCE0210\", \"Ram\", 9.62f, 102));  // Inserting Data\r\n        stuList.add(new student(\"19BCE1200\", \"Arjun\", 7.62f, 102));\r\n        \r\n        // Writing the student list to a file (direct dependency on file system classes)\r\n        FileOutputStream fout = new FileOutputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\Reg.txt\");\r\n        ObjectOutputStream ob1 = new ObjectOutputStream(fout);\r\n        ob1.writeObject(stuList);\r\n        ob1.close();\r\n        System.out.println(\"Done Writing\");\r\n\r\n        // Reading the list back from the file\r\n        FileInputStream fin = new FileInputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\Reg.txt\");\r\n        ObjectInputStream i1 = new ObjectInputStream(fin);\r\n        ArrayList<student> Nlist = new ArrayList<student>();\r\n\r\n        // Traversing through List\r\n        while (fin.available() != 0) {\r\n            Nlist = (ArrayList<student>) i1.readObject();\r\n        }\r\n        \r\n        // Sorting based on CGPA and then reversing the order (tight coupling to the student class attributes)\r\n        Nlist.sort((o1, o2) -> Float.compare(o1.CGPA, o2.CGPA));\r\n        Collections.reverse(Nlist);\r\n        Nlist.forEach(o -> System.out.println(\"Details: \" + o.Regno + \" \" + o.Name + \" \" + o.CGPA + \" \" + o.prefroom));\r\n        i1.close();\r\n        \r\n        // Converting the sorted list to an array\r\n        student[] sortedCGPA = Nlist.toArray(new student[Nlist.size()]);\r\n        \r\n        // Direct dependency: the registration class is tightly coupled to the Hostel and warden classes.\r\n        Hostel B1 = new Hostel(\"Block\", 2);\r\n        warden w1 = new warden(B1, sortedCGPA);\r\n        warden w2 = new warden(B1, sortedCGPA);\r\n        \r\n        // Starting threads directly in the main method increases coupling.\r\n        w1.start();\r\n        w2.start();\r\n        \r\n        System.out.println(\"\\nProceeding for result >>.... \");\r\n    }\r\n}"
    },
    {
        "file_name": "AddonGroupServiceImpl.java",
        "java_code": "public class AddonGroupServiceImpl implements AddonGroupService {\r\n    private final AddonGroupRepository addonGroupRepository;\r\n    private final AddonRepository addonRepository;\r\n    private final ModelMapper mapper;\r\n\r\n    public AddonGroupServiceImpl(AddonGroupRepository addonGroupRepository, AddonRepository addonRepository, ModelMapper mapper) {\r\n        this.addonGroupRepository = addonGroupRepository;\r\n        this.addonRepository = addonRepository;\r\n        this.mapper = mapper;\r\n    }\r\n\r\n    public AddonGroupResponseDTO createOrUpdateAddonGroup(AddonGroupRequestDTO addonGroupRequestDTO, Long addonGroupId)throws DuplicateRecordException, RecordNotFoundException {\r\n\r\n        log.info(\"AddonGroupServiceImpl::createOrUpdateAddonGroup\");\r\n        AddonGroup addonGroup;\r\n\r\n        boolean isExistsAddonGroup = addonGroupRepository.existsByNameIgnoreCase(addonGroupRequestDTO.getName());\r\n        if (addonGroupId != null) {\r\n            // Check if the Addon Group exists\r\n            addonGroup = addonGroupRepository.findById(addonGroupId)\r\n                    .orElseThrow(() -> new RecordNotFoundException(\"Addon Group with ID \" + addonGroupId + \" not found\"));\r\n\r\n            // Check if the new addon group name already exists(excluding the current addon group)\r\n            if (isExistsAddonGroup && !addonGroup.getName().equalsIgnoreCase(addonGroupRequestDTO.getName())) {\r\n                throw new DuplicateRecordException(\"Addon group name already exists\");\r\n            }\r\n\r\n            mapper.map(addonGroupRequestDTO, addonGroup);\r\n        } else {\r\n            if (isExistsAddonGroup) {\r\n                throw new DuplicateRecordException(\"Addon group name already exists\");\r\n            }\r\n\r\n            addonGroup = mapper.map(addonGroupRequestDTO, AddonGroup.class);\r\n        }\r\n\r\n        // Process list of addons\r\n        List<AddonAddonGroupRelationRequestDTO> addonAddonGroupRelationRequestDTOList = addonGroupRequestDTO.getListOfAddons();\r\n\r\n        // Utility method - Check for duplicate ids in listOfAddons request\r\n        ValidationUtils.checkForDuplicates(addonAddonGroupRelationRequestDTOList, \"Duplicate addons found in the request\");\r\n\r\n        // Get Addon-AddonGroup relations and save\r\n        List<AddonAddonGroupRelation> addonAddonGroupRelationsToSave = getAddonAddonGroupRelationEntityList(\r\n                addonAddonGroupRelationRequestDTOList,\r\n                addonGroup\r\n        );\r\n        // Remove existing relations and add new AddonAddonGroupRelations\r\n        addonGroup.getAddons().clear();\r\n        addonGroup.getAddons().addAll(addonAddonGroupRelationsToSave);\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        AddonGroup savedAddonGroup = addonGroupRepository.save(addonGroup);\r\n        watch.stop();\r\n        log.info(\"AddonGroupServiceImpl::createOrUpdateAddonGroup -> Addon Group associations saved with ID: {}, Query execution time: {}\",\r\n                savedAddonGroup.getAddonGroupId(),\r\n                watch.getTotalTimeSeconds()\r\n        );\r\n        return mapper.map(savedAddonGroup, AddonGroupResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackOn = {DuplicateRecordException.class, RecordNotFoundException.class, BadRequestException.class})\r\n    public AddOrRemoveAddonsForAddonGroupResponseDTO addAddonsForAddonGroup(Long addonGroupId, AddAddonsForAddonGroupRequestDTO addAddonsForAddonGroupRequestDTO)\r\n            throws RecordNotFoundException, DuplicateRecordException {\r\n\r\n        log.info(\"AddonGroupServiceImpl::addAddonsForAddonGroup\");\r\n\r\n        // Check if the AddonGroup exists\r\n        AddonGroup addonGroup = addonGroupRepository.findById(addonGroupId)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"AddonGroup with ID \" + addonGroupId + \" not found\"));\r\n\r\n        List<AddonAddonGroupRelationRequestDTO> addonAddonGroupRelationRequestDTOList = addAddonsForAddonGroupRequestDTO.getAddons();\r\n\r\n        // Obtain the all the addon ids\r\n        List<Long> requestAddonIdsList = addonAddonGroupRelationRequestDTOList.stream()\r\n                .map(AddonAddonGroupRelationRequestDTO::getAddonId)\r\n                .toList();\r\n\r\n        // Utility method - Check for duplicate ids in listOfAddons request\r\n        ValidationUtils.checkForDuplicates(requestAddonIdsList, \"Duplicate addons found in the request\");\r\n\r\n        // Extract existing addon IDs from the addonGroup\r\n        List<Long> existingAddonIdsList = addonGroup.getAddons().stream()\r\n                .map(relation -> relation.getAddon().getAddonId())\r\n                .toList();\r\n\r\n        // Verify if any existing addons are being re-added.\r\n        boolean hasCommonValues = requestAddonIdsList.stream()\r\n                .anyMatch(existingAddonIdsList::contains);\r\n\r\n        if (hasCommonValues) {\r\n            throw new DuplicateRecordException(\"Associations already exist for some of the requested addons\");\r\n        }\r\n\r\n        // Method -  Addon-AddonGroup relations and save\r\n        List<AddonAddonGroupRelation> addonAddonGroupRelationEntityList = getAddonAddonGroupRelationEntityList(\r\n                addonAddonGroupRelationRequestDTOList,\r\n                addonGroup\r\n        );\r\n\r\n        addonGroup.getAddons().addAll(addonAddonGroupRelationEntityList);\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        AddonGroup savedAddonGroup = addonGroupRepository.save(addonGroup);\r\n        watch.stop();\r\n        log.info(\"AddonGroupServiceImpl::addAddonsForAddonGroup -> Addon Group associations created with ID: {}, Query execution time: {}\",\r\n                savedAddonGroup.getAddonGroupId(),\r\n                watch.getTotalTimeSeconds()\r\n        );\r\n\r\n        // Prepare the response\r\n        List<Long> savedAddonIdsList = savedAddonGroup.getAddons().stream()\r\n                .map(relation -> relation.getAddon().getAddonId())\r\n                .toList();\r\n\r\n        AddOrRemoveAddonsForAddonGroupResponseDTO response = new AddOrRemoveAddonsForAddonGroupResponseDTO();\r\n        response.setId(savedAddonGroup.getAddonGroupId());\r\n        response.setName(savedAddonGroup.getName());\r\n        response.setListOfAddons(savedAddonIdsList);\r\n\r\n        return response;\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackOn = {RecordNotFoundException.class, BadRequestException.class})\r\n    public AddOrRemoveAddonsForAddonGroupResponseDTO removeAddonsFromAddonGroup(Long addonGroupId, RemoveAddonListRequestDTO removeAddonListRequestDTO)\r\n            throws RecordNotFoundException, BadRequestException, DuplicateRecordException {\r\n\r\n        log.info(\"AddonGroupServiceImpl::removeAddonsFromAddonGroup\");\r\n\r\n        // Check if the AddonGroup exists\r\n        AddonGroup addonGroup = addonGroupRepository.findById(addonGroupId)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"AddonGroup with ID \" + addonGroupId + \" not found\"));\r\n\r\n        // Retrieve existing associations for the Addon group\r\n        Set<AddonAddonGroupRelation> existingAddonAssociationsList = addonGroup.getAddons();\r\n\r\n        // Extract the list of addon IDs to remove from the Request DTO - RemoveAddonListRequestDTO\r\n        List<Long> addonsIdList = removeAddonListRequestDTO.getAddons();\r\n        // Check for Duplicate Ids in the request\r\n        ValidationUtils.checkForDuplicates(addonsIdList, \"Duplicate addon ids in the request\");\r\n\r\n        // Obtain existing addon ids\r\n        Set<Long> existingAddonIds = existingAddonAssociationsList.stream()\r\n                .map(association -> association.getAddon().getAddonId())\r\n                .collect(Collectors.toSet());\r\n\r\n        // Check whether all the removing addon ids are existing in addons\r\n        boolean hasNonExistentAddonId = addonsIdList.stream()\r\n                .anyMatch(id -> !existingAddonIds.contains(id));\r\n\r\n        if (hasNonExistentAddonId) {\r\n            throw new BadRequestException(\"At least one addon ID in the request does not have an association with the addon group.\");\r\n        }\r\n\r\n        // Remove Associations form the addon group\r\n        existingAddonAssociationsList.removeIf(association -> addonsIdList.contains(association.getAddon().getAddonId()));\r\n\r\n        // Save the updated AddonGroup to persist the changes\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        AddonGroup savedAddonGroup = addonGroupRepository.save(addonGroup);\r\n        watch.stop();\r\n        log.info(\"AddonGroupServiceImpl::removeAddonsFromAddonGroup -> Addon Group associations removed with ID: {}, Query execution time: {}\",\r\n                savedAddonGroup.getAddonGroupId(),\r\n                watch.getTotalTimeSeconds()\r\n        );\r\n\r\n        // Prepare the response\r\n        List<Long> savedAddonIdsList = savedAddonGroup.getAddons().stream()\r\n                .map(relation -> relation.getAddon().getAddonId())\r\n                .toList();\r\n\r\n        AddOrRemoveAddonsForAddonGroupResponseDTO response = new AddOrRemoveAddonsForAddonGroupResponseDTO();\r\n        response.setId(savedAddonGroup.getAddonGroupId());\r\n        response.setName(savedAddonGroup.getName());\r\n        response.setListOfAddons(savedAddonIdsList);\r\n\r\n        return response;\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO updateAvailabilityStatusByIds(SetAvailabilityStatusRequestDTO setAvailabilityStatusRequestDTO) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::updateAvailabilityStatusByIds\");\r\n\r\n        List<Long> addonGroupIdList = setAvailabilityStatusRequestDTO.getIdList();\r\n        Boolean availabilityStatus = setAvailabilityStatusRequestDTO.getAvailabilityStatus();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(addonGroupIdList, \"Duplicate addon group IDs in the request\");\r\n\r\n        // Find all addon groups by IDs\r\n        List<AddonGroup> addonGroupsToUpdate = addonGroupRepository.findAllById(addonGroupIdList);\r\n\r\n        // Check if all requested addons groups exist\r\n        if (addonGroupsToUpdate.size() != addonGroupIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some addon groups were not found\");\r\n        }\r\n        // Filter only those addon groups where the availability status differs\r\n        List<AddonGroup> filteredAddonGroupsToUpdate = addonGroupsToUpdate.stream()\r\n                .filter(addonGroup -> !availabilityStatus.equals(addonGroup.getAvailabilityStatus()))\r\n                .peek(addonGroup -> {\r\n                    addonGroup.setAvailabilityStatus(availabilityStatus);\r\n                })\r\n                .collect(Collectors.toList());\r\n\r\n        // Save only the filtered Addon Groups\r\n        if (!filteredAddonGroupsToUpdate.isEmpty()) {\r\n            StopWatch watch = new StopWatch();\r\n            watch.start();\r\n            List<AddonGroup> updatedAddonGroupList = addonGroupRepository.saveAll(filteredAddonGroupsToUpdate);\r\n            watch.stop();\r\n\r\n            log.info(\"CategoryServiceImpl::updateAvailabilityStatusByIds -> Query execution time: {}, Total records updated: {}\", watch.getTotalTimeSeconds(), updatedAddonGroupList.size());\r\n        } else {\r\n            log.info(\"CategoryServiceImpl::updateAvailabilityStatusByIds -> No addon group had a change in availability status.\");\r\n        }\r\n\r\n        return new ResponseDTO(\"Availability status updated successfully for Addon Groups.\");\r\n    }\r\n\r\n    @Override\r\n    public GetAddonGroupResponseDTO findAddonGroupById(Long addonGroupId) throws RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::findAddonGroupById\");\r\n\r\n        // Fetch the AddonGroup by ID or throw an exception if not found\r\n        AddonGroup addonGroup = addonGroupRepository.findById(addonGroupId)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Addon Group not found with ID -\" + addonGroupId));\r\n\r\n        // Fetch the existing associations for the given Addon Group ID\r\n        Set<AddonAddonGroupRelation> existingAddonGroupAssociations = addonGroup.getAddons();\r\n\r\n        // Map the associations to Response DTOs\r\n        List<AddonAddonGroupRelationResponseDTO> existingAddons = existingAddonGroupAssociations.stream()\r\n                .map(association -> AddonAddonGroupRelationResponseDTO.builder()\r\n                        .addonId(association.getAddon().getAddonId())\r\n                        .name(association.getAddon().getName())\r\n                        .price(association.getPrice())\r\n                        .build()\r\n                )\r\n                .collect(Collectors.toList());\r\n\r\n        // Map the AddonGroup to response DTO\r\n        GetAddonGroupResponseDTO getAddonGroupResponseDTO = mapper.map(addonGroup, GetAddonGroupResponseDTO.class);\r\n        getAddonGroupResponseDTO.setListOfAddons(existingAddons);\r\n\r\n        return getAddonGroupResponseDTO;\r\n    }\r\n\r\n    @Override\r\n    public AddonGroupListResponseDTO findAllAddonGroups(AddonGroupQueryRequestDTO addonGroupQueryRequestDTO) throws RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::findAllAddonGroups\");\r\n\r\n        return getAddonGroupsResponse(addonGroupQueryRequestDTO, true);\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackOn = {RecordNotFoundException.class})\r\n    public ResponseDTO deleteAddonGroupById(Long addonGroupId) throws RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::deleteAddonGroup\");\r\n\r\n        // Check if the AddonGroup exists, otherwise throw an exception\r\n        AddonGroup addonGroup = addonGroupRepository.findById(addonGroupId)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Addon Group not found with addon group Id \" + addonGroupId));\r\n\r\n        // Remove relationships with products and variation relations using streams\r\n        if (addonGroup.getProducts() != null) {\r\n            addonGroup.getProducts().forEach(product -> product.getAddonGroups().remove(addonGroup));\r\n            addonGroup.getProducts().clear();\r\n        }\r\n\r\n        if (addonGroup.getVariationRelation() != null) {\r\n            addonGroup.getVariationRelation().forEach(variationRelation -> variationRelation.getAddonGroups().remove(addonGroup));\r\n            addonGroup.getVariationRelation().clear();\r\n        }\r\n\r\n        // Orphan removal for addons will be handled automatically\r\n        addonGroupRepository.delete(addonGroup);\r\n        return new ResponseDTO(String.format(\"Addon Group with ID %d deleted successfully\", addonGroupId));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteAddonGroupsByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::deleteAddonGroupsByIds\");\r\n\r\n        List<Long> addonGroupIdList = deleteByIdsRequestDTO.getIdList();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(addonGroupIdList, \"Duplicate addon group ids in the request\");\r\n\r\n        // Find all addon groups by IDs\r\n        List<AddonGroup> addonGroupsToDelete = addonGroupRepository.findAllById(addonGroupIdList);\r\n\r\n        // Verify if all requested IDs exist\r\n        if (addonGroupsToDelete.size() != addonGroupIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some addon groups were not found\");\r\n        }\r\n\r\n        // Remove relationships with products and variation relations using streams\r\n        addonGroupsToDelete.forEach(addonGroup -> {\r\n            Set<Product> associatedProducts = addonGroup.getProducts();\r\n            // Clear the products\r\n            if (associatedProducts != null && !associatedProducts.isEmpty()) {\r\n                addonGroup.getProducts().forEach(product -> product.getAddonGroups().remove(addonGroup));\r\n                addonGroup.getProducts().clear();\r\n            }\r\n            Set<VariationRelation> associatedVariations = addonGroup.getVariationRelation();\r\n            // Clear the variation relation\r\n            if (associatedVariations != null && !associatedVariations.isEmpty()) {\r\n                addonGroup.getVariationRelation().forEach(variationRelation -> variationRelation.getAddonGroups().remove(addonGroup));\r\n                addonGroup.getVariationRelation().clear();\r\n            }\r\n        });\r\n\r\n        // Now, delete the addon groups\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        addonGroupRepository.deleteAll(addonGroupsToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"AddonGroupServiceImpl::deleteAddonGroupsByIds -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                addonGroupsToDelete.size() // Default deleteAll method is void\r\n        );\r\n\r\n        return new ResponseDTO(\"Addon groups deleted successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"AddonGroupServiceImpl::generateImportTemplate\");\r\n\r\n        Set<String> addonItems = addonRepository.findAllAddonNames();\r\n        return new InputStreamResource(ImportTemplates.generateAddonGroupImportTemplate(addonItems));\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackOn = {DuplicateRecordException.class, RecordNotFoundException.class, BadRequestException.class, ExcelDTOMappingValidationException.class, IOException.class})\r\n    public ResponseDTO importAddonGroups(MultipartFile addonGroupExcelFile)\r\n            throws FileNotFoundCustomException, InvalidFileTypeException, DuplicateRecordException, BadRequestException, IOException, ExcelDTOMappingValidationException, RecordNotFoundException {\r\n\r\n        log.info(\"AddonGroupServiceImpl::saveAddonGroupsFromExcelFile\");\r\n\r\n        // Check if file is provided and not empty\r\n        if (addonGroupExcelFile == null || addonGroupExcelFile.isEmpty()) {\r\n            throw new FileNotFoundCustomException(\"No file uploaded or the file is empty\");\r\n        }\r\n\r\n        // Validate file type\r\n        if (!isExcelFile(addonGroupExcelFile)) {\r\n            throw new InvalidFileTypeException(\"Invalid file format. Please upload an Excel file.\");\r\n        }\r\n\r\n        Set<String> existingAddonGroupNames = addonGroupRepository.findAllAddonGroupNames();\r\n        List<Addon> existingAddons = addonRepository.findAll();\r\n\r\n        // Util Method: Returns List AddonGroupRequestDTO from Excel after mapping\r\n        List<AddonGroupRequestDTO> addonGroupRequestDTOList = ImportData.\r\n                convertExcelToAddonGroupDTO(addonGroupExcelFile, existingAddonGroupNames, existingAddons);\r\n\r\n        // for setting AddonAddonGroupRelation\r\n        Map<Long, Addon> addonIdToAddonMap = existingAddons.stream()\r\n                .collect(Collectors.toMap(Addon::getAddonId, addon -> addon));\r\n\r\n        // Map to entity list for saving\r\n        // In this scenario since the request is validated, it is not efficient if we use same logic in create or update method.\r\n        // Therefore, separate function was implemented.\r\n        List<AddonGroup> addonGroupsToSave = addonGroupRequestDTOList.stream()\r\n                .map(addonGroupRequestDTO ->\r\n                        convertDTOToAddonGroupEntity(addonGroupRequestDTO, addonIdToAddonMap))\r\n                .toList();\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<AddonGroup> savedAddonGroups = addonGroupRepository.saveAll(addonGroupsToSave);\r\n        watch.stop();\r\n\r\n        log.info(\"saveAddonGroupsFromExcelFile -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                savedAddonGroups.size());\r\n\r\n        return new ResponseDTO(\"File processed and Addon Groups saved successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportAddonGroups(AddonGroupQueryRequestDTO requestDTO) throws IOException, RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::exportAddonGroups\");\r\n\r\n        // Fetching addon groups\r\n        AddonGroupListResponseDTO addonGroupListResponseDTO = getAddonGroupsResponse(requestDTO, requestDTO.getIncludeLimit());\r\n\r\n        return new InputStreamResource(ExportData.exportAddonGroups(addonGroupListResponseDTO.getAddonGroups()));\r\n    }\r\n\r\n    private AddonGroup convertDTOToAddonGroupEntity(AddonGroupRequestDTO addonGroupRequestDTO, Map<Long, Addon> addonIdAddonMap) {\r\n        AddonGroup addonGroup = AddonGroup.builder()\r\n                .name(addonGroupRequestDTO.getName())\r\n                .onlineDisplayName(addonGroupRequestDTO.getOnlineDisplayName())\r\n                .showInOnline(addonGroupRequestDTO.getShowInOnline())\r\n                .availabilityStatus(addonGroupRequestDTO.getAvailabilityStatus())\r\n                .allowMultipleSelections(addonGroupRequestDTO.getAllowMultipleSelections())\r\n                .minimumSelections(addonGroupRequestDTO.getMinimumSelections())\r\n                .maximumSelections(addonGroupRequestDTO.getMaximumSelections())\r\n                .build();\r\n\r\n        // Add Addon relations\r\n        Set<AddonAddonGroupRelation> addonAddonGroupRelationSet = addonGroupRequestDTO.getListOfAddons().stream()\r\n                .map(addonRelationDTO ->\r\n                        convertAddonRelationDTOToEntity(addonRelationDTO, addonGroup, addonIdAddonMap))\r\n                .collect(Collectors.toSet());\r\n\r\n        addonGroup.setAddons(addonAddonGroupRelationSet);\r\n        return addonGroup;\r\n    }\r\n\r\n    private AddonAddonGroupRelation convertAddonRelationDTOToEntity(AddonAddonGroupRelationRequestDTO addonAddonGroupRelationRequestDTO,\r\n                                                                    AddonGroup addonGroup, Map<Long, Addon> addonIdMap) {\r\n\r\n        Addon addon = addonIdMap.get(addonAddonGroupRelationRequestDTO.getAddonId());\r\n\r\n        return AddonAddonGroupRelation.builder()\r\n                .addonGroup(addonGroup)\r\n                .addon(addon)\r\n                .price(addonAddonGroupRelationRequestDTO.getPrice())\r\n                .build();\r\n    }\r\n\r\n    private List<AddonAddonGroupRelation> getAddonAddonGroupRelationEntityList(\r\n            List<AddonAddonGroupRelationRequestDTO> addonAddonGroupRelationRequestDTOList,\r\n            AddonGroup addonGroup\r\n    ) throws RecordNotFoundException {\r\n\r\n        log.info(\"AddonGroupServiceImpl::getAddonAddonGroupRelationEntityList\");\r\n\r\n        // Validate addon ID existence in the Addon\r\n        List<Long> requestAddonIds = addonAddonGroupRelationRequestDTOList.stream()\r\n                .map(AddonAddonGroupRelationRequestDTO::getAddonId)\r\n                .collect(Collectors.toList());\r\n        List<Addon> existingAddonsList = addonRepository.findAllById(requestAddonIds);\r\n\r\n        if (existingAddonsList.size() != requestAddonIds.size()) {\r\n            throw new RecordNotFoundException(\"Some of the addons for given addon ids not found \");\r\n        }\r\n        log.info(\"AddonGroupServiceImpl::getAddonAddonGroupRelationEntityList -> All request Addon Ids are valid\");\r\n        // Create a map - for lookup of Addon by addonId\r\n        Map<Long, Addon> addonLookupMap = existingAddonsList.stream()\r\n                .collect(Collectors.toMap(Addon::getAddonId, a -> a));\r\n\r\n        // Create list of AddonAddonGroupRelation from addonAddonGroupRelationRequestDTOList and Return List\r\n        return addonAddonGroupRelationRequestDTOList.stream()\r\n                .map(requestDTO -> {\r\n\r\n                    // Verify Addon existence\r\n                    Addon addon = addonLookupMap.get(requestDTO.getAddonId());\r\n\r\n                    // Since we have checked this before, addon cannot be null\r\n                    if (addon == null) {\r\n                        throw new CustomInternalServerException(\"Addon with ID \" + requestDTO.getAddonId() + \" not found\");\r\n                    }\r\n                    // Create new Addon-AddonGroup Relation\r\n                    AddonAddonGroupRelation addonAddonGroupRelation = new AddonAddonGroupRelation();\r\n                    addonAddonGroupRelation.setAddonGroup(addonGroup);\r\n                    addonAddonGroupRelation.setAddon(addon);\r\n                    addonAddonGroupRelation.setPrice(requestDTO.getPrice());\r\n                    return addonAddonGroupRelation;\r\n                }).toList();\r\n    }\r\n\r\n    private AddonGroupListResponseDTO getAddonGroupsResponse(AddonGroupQueryRequestDTO addonGroupQueryRequestDTO, Boolean includeLimit) throws RecordNotFoundException {\r\n        log.info(\"AddonGroupServiceImpl::getAddonGroupsResponse\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<AddonGroupQueryOutputDTO> addonGroupQueryOutputDTOList = addonGroupRepository.findAllAddonGroups(addonGroupQueryRequestDTO, includeLimit);\r\n        watch.stop();\r\n\r\n        // This will throw a RecordNotFound exception when no data found for the export related scenarios\r\n        if (!includeLimit) {\r\n            CommonUtils.validateRecordsNotFound(addonGroupQueryOutputDTOList, \"AddonGroupQueryOutputDTO\");\r\n        }\r\n\r\n        long totalRecords = addonGroupQueryOutputDTOList.isEmpty() ? 0 : addonGroupQueryOutputDTOList.get(0).getTotalRecords();\r\n\r\n        AddonGroupListResponseDTO addonGroupListResponseDTO = new AddonGroupListResponseDTO();\r\n        addonGroupListResponseDTO.setTotalRecords((int) totalRecords);\r\n        addonGroupListResponseDTO.setOffset(addonGroupQueryRequestDTO.getOffset());\r\n        addonGroupListResponseDTO.setLimit(addonGroupQueryRequestDTO.getLimit());\r\n        addonGroupListResponseDTO.setAddonGroups(addonGroupQueryOutputDTOList);\r\n\r\n\r\n        log.info(\"AddonGroupServiceImpl::getAddonGroupsResponse -> Query execution time: {}, Number of addon groups: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                addonGroupListResponseDTO.getAddonGroups().size(),\r\n                addonGroupListResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return addonGroupListResponseDTO;\r\n    }\r\n}"
    },
    {
        "file_name": "AdvancedDecisionMaker.java",
        "java_code": "public class AdvancedDecisionMaker extends BaseAI {\r\n    public String analyzeSituation(int risk, boolean isEmergency, String condition) {\r\n        if (isEmergency) {\r\n            if (risk > 8) {\r\n                if (condition.equals(\"fire\")) {\r\n                    return \"Call fire department immediately\";\r\n                } else if (condition.equals(\"medical\")) {\r\n                    return \"Call an ambulance\";\r\n                } else {\r\n                    return \"Assess further and take action\";\r\n                }\r\n            }\r\n        } else {\r\n            if (risk > 5) {\r\n                try {\r\n                    if (condition.contains(\"weather\")) {\r\n                        return \"Stay indoors\";\r\n                    } else if (condition.contains(\"security\")) {\r\n                        return \"Increase surveillance\";\r\n                    } else {\r\n                        throw new IllegalArgumentException(\"Unknown condition\");\r\n                    }\r\n                } catch (Exception e) {\r\n                    return \"Error: \" + e.getMessage();\r\n                }\r\n            }\r\n        }\r\n        return \"No immediate action required\";\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basicTryCatch() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multipleCatchBlocks() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nestedTryCatch() {\r\n        try {\r\n            System.out.println(\"Outer try block\");\r\n\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void tryCatchInsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "Program.java",
        "java_code": "public class Program {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Starting program...\");\r\n\r\n        for (int i = 1; i <= 2; i++) {\r\n            System.out.println(\"Outer loop iteration: \" + i);\r\n            try {\r\n                for (int j = 1; j <= 2; j++) {\r\n                    System.out.println(\"Inner loop iteration: \" + j);\r\n                    try {\r\n                        for (int k = 1; k <= 2; k++) {\r\n                            if ((k % 2 == 0 && i % 2 == 1) || (j + k > 2)) {\r\n                                if (k == 2 && j == 2) {\r\n                                    throw new IllegalStateException(\"Simulated exception at deep nesting.\");\r\n                                }\r\n                            }\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        System.out.println(\"Level exception caught: \" + ex.getMessage());\r\n                    }\r\n                }\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Outer-level exception caught: \" + ex.getMessage());\r\n            }\r\n        }\r\n\r\n        System.out.println(\"Program completed.\");\r\n    }\r\n}"
    },
    {
        "file_name": "ComplexNestedLoops.java",
        "java_code": "public class DeepNestingExample {\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Outer\");\r\n\r\n            try {\r\n                System.out.println(\"Nested level 1\");\r\n\r\n                try {\r\n                    System.out.println(\"Nested level 2\");\r\n\r\n                    try {\r\n                        System.out.println(\"Nested level 3\");\r\n                        throw new IllegalArgumentException(\"Level 3 exception\");\r\n                    } catch (IllegalArgumentException e) { //try-catch weight assign =5\r\n                        System.out.println(\"Nested level 3: \" + e.getMessage());\r\n                    } finally {\r\n                        System.out.println(\"Nested level 3\");\r\n                    }\r\n\r\n                } catch (NullPointerException e) {//try-catch weight assign =4\r\n                    System.out.println(\"Nested level 2: \" + e.getMessage());\r\n                } finally {\r\n                    System.out.println(\"Nested level 2\");\r\n                }\r\n\r\n            } catch (ArrayIndexOutOfBoundsException e) {//try-catch weight assign =3\r\n                System.out.println(\"Nested level 1: \" + e.getMessage());\r\n            } finally {\r\n                System.out.println(\"Nested level 1\");\r\n            }\r\n\r\n        } catch (Exception e) {//try-catch weight assign =2\r\n            System.out.println(\"Outer: \" + e.getMessage());\r\n        } finally {\r\n            System.out.println(\"Outer\");\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basicTryCatch() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multipleCatchBlocks() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nestedTryCatch() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void tryCatchInsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basicTryCatch() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multipleCatchBlocks() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nestedTryCatch() {\r\n        try {\r\n            System.out.println(\"Inner try block\");\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void tryCatchInsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            } } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } \r\n        catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n            } \r\n            catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } \r\n        catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner try block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n                try {\r\n                   System.out.println(\"Inner try block\");\r\n                   throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n                } \r\n                catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } \r\n            catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } \r\n        catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner try block\");\r\n                   throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n                } \r\n                catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } \r\n            catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } \r\n        catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner try block\");\r\n                   throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested try.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); // Causes inner catch\r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\n            catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        for (int i = 0; i < 3; i++) {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\n            catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n        // for (int i = 0; i < 3; i++) {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\n            catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n        // }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void InsideLoop() {\r\n        try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\n        catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void InsideLoop() {\r\n        try {\r\n            System.out.println(\"Inner block\");\r\n            if (i == 2) {\r\n                throw new Exception(\"Loop exception\");\r\n            }\r\n            System.out.println(\"Processing item \" + i);\r\n        } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    \r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "HttpServer.java",
        "java_code": "public class HttpServer {\r\n  public static void main(String[] args) {\r\n    System.out.println(\"Server starting...\");\r\n\r\n    ConfigurationManager.getInstance().loadConfigurationFile(\"src/main/resources/http.json\");\r\n    Configuration conf = ConfigurationManager.getInstance().getCurrentConfiguration();\r\n\r\n    System.out.printf(\"Using Port: %s%n\" +\r\n            \"Using WebRoot: %s%n\", conf.getPort(), conf.getWebroot());\r\n\r\n    try {\r\n      ServerSocket serverSocket = new ServerSocket(conf.getPort());\r\n\r\n      while (true) { // Infinte loop\r\n        Socket socket = serverSocket.accept();\r\n\r\n        InputStream inputStream = socket.getInputStream();\r\n        OutputStream outputStream = socket.getOutputStream();\r\n\r\n\r\n        outputStream.write(response.getBytes());\r\n        inputStream.close();\r\n        outputStream.close();\r\n        socket.close();\r\n      }\r\n      serverSocket.close();\r\n    } catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}"
    },
    {
        "file_name": "HttpServer.java",
        "java_code": "public class HttpServer {\r\n  public static void main(String[] args) {\r\n    System.out.println(\"Server starting...\");\r\n\r\n    ConfigurationManager.getInstance().loadConfigurationFile(\"src/main/resources/http.json\");\r\n    Configuration conf = ConfigurationManager.getInstance().getCurrentConfiguration();\r\n\r\n    System.out.printf(\"Using Port: %s%n\" +\r\n            \"Using WebRoot: %s%n\", conf.getPort(), conf.getWebroot());\r\n\r\n    try {\r\n      ServerSocket serverSocket = new ServerSocket(conf.getPort());\r\n\r\n      while (true) { // Infinte loop\r\n        Socket socket = serverSocket.accept();\r\n\r\n        InputStream inputStream = socket.getInputStream();\r\n        OutputStream outputStream = socket.getOutputStream();\r\n\r\n\r\n        outputStream.write(response.getBytes());\r\n        inputStream.close();\r\n        outputStream.close();\r\n        socket.close();\r\n      }\r\n      serverSocket.close();\r\n    } \r\n    catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\ncatch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try \r\n            {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\ncatch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try \r\n            {\r\n                \r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\ncatch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "HttpServer.java",
        "java_code": "public class HttpServer {\r\n  public static void main(String[] args) {\r\n    System.out.println(\"Server starting...\");\r\n\r\n    ConfigurationManager.getInstance().loadConfigurationFile(\"src/main/resources/http.json\");\r\n    Configuration conf = ConfigurationManager.getInstance().getCurrentConfiguration();\r\n\r\n    System.out.printf(\"Using Port: %s%n\" +\r\n            \"Using WebRoot: %s%n\", conf.getPort(), conf.getWebroot());\r\n\r\n    try \r\n    {\r\n      ServerSocket serverSocket = new ServerSocket(conf.getPort());\r\n\r\n      while (true) { // Infinte loop\r\n        Socket socket = serverSocket.accept();\r\n\r\n        InputStream inputStream = socket.getInputStream();\r\n        OutputStream outputStream = socket.getOutputStream();\r\n\r\n\r\n        outputStream.write(response.getBytes());\r\n        inputStream.close();\r\n        outputStream.close();\r\n        socket.close();\r\n      }\r\n      serverSocket.close();\r\n    } \r\n    catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}"
    },
    {
        "file_name": "Nested.java",
        "java_code": "import java.util.concurrent.*;\r\n\r\npublic class NestedTryCatchExample {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Starting program...\");\r\n\r\n        for (int i = 1; i <= 2; i++) {\r\n            System.out.println(\"Outer loop iteration: \" + i);\r\n            try {\r\n                for (int j = 1; j <= 2; j++) {\r\n                    System.out.println(\"Inner loop iteration: \" + j);\r\n                    try {\r\n                        for (int k = 1; k <= 2; k++) {\r\n                            if ((k % 2 == 0 && i % 2 == 1) || (j + k > 2)) {\r\n                                if (k == 2 && j == 2) {\r\n                                    throw new IllegalStateException(\"Simulated exception at deep nesting.\");\r\n                                }\r\n                            }\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        System.out.println(\"Level exception caught: \" + ex.getMessage());\r\n                    }\r\n                }\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Outer-level exception caught: \" + ex.getMessage());\r\n            }\r\n        }\r\n\r\n        System.out.println(\"Program completed.\");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "Nested.java",
        "java_code": "import java.util.concurrent.*;\r\n\r\npublic class NestedTryCatchExample {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Starting program...\");\r\n\r\n        for (int i = 1; i <= 2; i++) {\r\n            System.out.println(\"Outer loop iteration: \" + i);\r\n            try {\r\n                for (int j = 1; j <= 2; j++) {\r\n                    System.out.println(\"Inner loop iteration: \" + j);\r\n                    try \r\n                    {\r\n                        for (int k = 1; k <= 2; k++) {\r\n                            if ((k % 2 == 0 && i % 2 == 1) || (j + k > 2)) {\r\n                                if (k == 2 && j == 2) {\r\n                                    throw new IllegalStateException(\"Simulated exception at deep nesting.\");\r\n                                }\r\n                            }\r\n                        }\r\n                    } \r\n                    catch (Exception ex) {\r\n                        System.out.println(\"Level exception caught: \" + ex.getMessage());\r\n                    }\r\n                }\r\n            } \r\n            catch (Exception ex) {\r\n                System.out.println(\"Outer-level exception caught: \" + ex.getMessage());\r\n            }\r\n        }\r\n\r\n        System.out.println(\"Program completed.\");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "Exampleee.java",
        "java_code": "public class Example {\r\n    private Service service;\r\n\r\n    public Example(Service service) { // Constructor Injection\r\n        this.service = service;\r\n    }\r\n}"
    },
    {
        "file_name": "UserService.java",
        "java_code": "// Client class (Injecting dependency via constructor)\r\npublic class UserService {\r\n    private final NotificationService notificationService;\r\n\r\n    // Constructor Injection\r\n    public UserService(NotificationService notificationService) {\r\n        this.notificationService = notificationService;\r\n    }\r\n\r\n    public void notifyUser(String message) {\r\n        notificationService.sendNotification(message);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        // Injecting dependency manually\r\n        NotificationService emailService = new EmailNotificationService();\r\n        UserService userService = new UserService(emailService);\r\n\r\n        userService.notifyUser(\"Hello! Your account has been activated.\");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "Example.java",
        "java_code": "public class Example extends Example1 {\r\n    public static final String CONSTANT = \"TEST\";\r\n\r\n    private Service service;\r\n    private Repository repository;\r\n    private Helper helper;\r\n\r\n    // Constructor Injection\r\n    public Example(Service service, Repository repository) {\r\n        this.service = service;\r\n        this.repository = repository;\r\n    }\r\n\r\n    // Setter Injection\r\n    public void setHelper(Helper helper) {\r\n        this.helper = helper;\r\n    }\r\n\r\n    // Direct Object Instantiation\r\n    public void doSomething() {\r\n        AnotherService as = new AnotherService();\r\n        System.out.println(\"Direct instantiation: \" + as);\r\n    }\r\n\r\n    // Static Method Call\r\n    public void callStatic() {\r\n        int val = Utility.computeValue(5);\r\n        System.out.println(\"Static method call result: \" + val);\r\n    }\r\n\r\n    // Static Variable Usage\r\n    public void useStaticVariable() {\r\n        System.out.println(\"Static variable usage: \" + CONSTANT);\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try \r\n        {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } \r\n        catch (NumberFormatException ex) \r\n        {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } \r\n        finally \r\n        {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try \r\n        {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } \r\n        catch (NumberFormatException ex) \r\n        {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } \r\n        finally \r\n        {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try \r\n        {\r\n            try \r\n            {\r\n                try \r\n                {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } \r\n                catch (IOException ex) \r\n                {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } \r\n            catch (IOException ex) \r\n            {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } \r\n        catch (Exception ex) \r\n        {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } \r\n        finally \r\n        {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try \r\n            {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } \r\n            catch (Exception ex) \r\n            {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try \r\n        {\r\n            System.out.println(\"Trying something...\");\r\n            int num = Integer.parseInt(\"ABC\"); // Causes NumberFormatException\r\n        } \r\n        catch (NumberFormatException ex) \r\n        {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } \r\n        finally \r\n        {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "TryCatchTest.java",
        "java_code": "import java.io.IOException;\r\n\r\nclass TryCatchTest {\r\n    \r\n    public void basic() {\r\n        try \r\n        {\r\n            System.out.println(\"Inner block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n\r\n                   System.out.println(\"Inner block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n                System.out.println(\"Inner block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } \r\n        catch (NumberFormatException ex) \r\n        {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } \r\n        finally \r\n        {\r\n            System.out.println(\"Basic cleanup completed.\");\r\n        }\r\n    }\r\n\r\n    public void multiple() {\r\n        try {\r\n            String[] data = {\"1\", \"2\", \"three\"};\r\n            int value = Integer.parseInt(data[2]); // Causes NumberFormatException\r\n        } catch (ArrayIndexOutOfBoundsException ex) {\r\n            System.out.println(\"Caught ArrayIndexOutOfBoundsException: \" + ex.getMessage());\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Caught NumberFormatException: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup for multipleCatchBlocks.\");\r\n        }\r\n    }\r\n\r\n    public void nested() {\r\n        try {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                throw new IOException(\"Inner IO error\"); \r\n                try {\r\n                   System.out.println(\"Inner block\");\r\n                   throw new IOException(\"Inner IO error\"); \r\n                } catch (IOException ex) {\r\n                   System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n                }\r\n            } catch (IOException ex) {\r\n                System.out.println(\"Caught inner IOException: \" + ex.getMessage());\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Caught outer exception: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Final cleanup after nested.\");\r\n        }\r\n    }\r\n\r\n    public void InsideLoop() {\r\n            try {\r\n                System.out.println(\"Inner block\");\r\n                if (i == 2) {\r\n                    throw new Exception(\"Loop exception\");\r\n                }\r\n                System.out.println(\"Processing item \" + i);\r\n            } catch (Exception ex) {\r\n                System.out.println(\"Caught exception in loop: \" + ex.getMessage());\r\n            }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        TryCatchTest test = new TryCatchTest();\r\n        test.basicTryCatch();\r\n        test.multipleCatchBlocks();\r\n        test.nestedTryCatch();\r\n        test.tryCatchInsideLoop();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "RecursiveProcessor.java",
        "java_code": "class RecursiveProcessor {\r\n    private void recursiveProcess(String data, int depth) {\r\n        if (depth <= 0) {\r\n            return;\r\n        }\r\n\r\n        System.out.println(\"Recursing at depth \" + depth + \" with data: \" + data);\r\n        try {\r\n            if (depth % 2 == 0) {\r\n                for (int i = 0; i < data.length(); i++) {\r\n                    if (Character.isDigit(data.charAt(i))) {\r\n                        throw new NumberFormatException(\"Invalid number at index \" + i);\r\n                    }\r\n                }\r\n            } else {\r\n                for (int i = 0; i < depth; i++) {\r\n                    System.out.println(\"Processing depth: \" + depth + \", iteration: \" + i);\r\n                }\r\n            }\r\n        } catch (NumberFormatException ex) {\r\n            System.out.println(\"Error in recursion: \" + ex.getMessage());\r\n        }\r\n\r\n        ProcessorB.recursiveProcess(data.substring(1), depth - 1);\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "AnotherDerivedClass.java",
        "java_code": "class AnotherDerivedClass extends DerivedClass {\r\n    void process() {\r\n        System.out.println(\"Processing in AnotherDerivedClass\");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "BaseClass.java",
        "java_code": "class BaseClass {\r\n    void process() {\r\n        System.out.println(\"Processing in BaseClass\");\r\n    }\r\n}"
    },
    {
        "file_name": "DeepInheritance.java",
        "java_code": "class DeepInheritance extends AnotherDerivedClass {\r\n    void process() {\r\n        System.out.println(\"Processing in DeepInheritance\");\r\n    }\r\n}"
    },
    {
        "file_name": "DerivedClass.java",
        "java_code": "class DerivedClass extends BaseClass {\r\n    void process() {\r\n        System.out.println(\"Processing in DerivedClass\");\r\n    }\r\n}"
    },
    {
        "file_name": "VeryDeepInheritance.java",
        "java_code": "class VeryDeepInheritance extends DeepInheritance {\r\n    void process() {\r\n        System.out.println(\"Processing in VeryDeepInheritance\");\r\n    }\r\n}"
    },
    {
        "file_name": "CodeComplexityExample.java",
        "java_code": "public class CodeComplexityExample {\r\n\r\n    public void evaluateConditions(int value, boolean flag) {\r\n        // control_structure_complexity = 1, nesting_level = 1, compound_condition_weight = 0\r\n        if (value > 10) {\r\n            System.out.println(\"Value is greater than 10\");\r\n        }\r\n\r\n        // control_structure_complexity = 1, nesting_level = 1, compound_condition_weight = 1\r\n        if (value > 10 && flag) {\r\n            System.out.println(\"Value is greater than 10 and flag is true\");\r\n        }\r\n\r\n        // control_structure_complexity = 1, nesting_level = 1, compound_condition_weight = 2\r\n        if (value > 10 && flag || value < 5) {\r\n            System.out.println(\"Complex condition with compound logic\");\r\n        }\r\n\r\n        // control_structure_complexity = 1, nesting_level = 2, compound_condition_weight = 1\r\n        if (value > 10) {\r\n            if (flag) {\r\n                System.out.println(\"Nested condition with flag true\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public void evaluateLoops(int[] values) {\r\n        // control_structure_complexity = 2, nesting_level = 1, compound_condition_weight = 0\r\n        for (int value : values) {\r\n            System.out.println(\"Value: \" + value);\r\n        }\r\n\r\n        // control_structure_complexity = 2, nesting_level = 2, compound_condition_weight = 1\r\n        for (int value : values) {\r\n            if (value > 10) {\r\n                System.out.println(\"Value greater than 10: \" + value);\r\n            }\r\n        }\r\n\r\n        // control_structure_complexity = 2, nesting_level = 3, compound_condition_weight = 2\r\n        for (int value : values) {\r\n            if (value > 10) {\r\n                while (value > 0) {\r\n                    System.out.println(\"Decrementing value: \" + value);\r\n                    value--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void evaluateSwitchCase(int option) {\r\n        // control_structure_complexity = 3, nesting_level = 1, compound_condition_weight = 0\r\n        switch (option) {\r\n            case 1:\r\n                System.out.println(\"Option 1 selected\");\r\n                break;\r\n            case 2:\r\n                // control_structure_complexity = 3, nesting_level = 2, compound_condition_weight = 1\r\n                if (option > 0) {\r\n                    System.out.println(\"Option 2 with positive value\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // control_structure_complexity = 3, nesting_level = 3, compound_condition_weight = 2\r\n                if (option > 0) {\r\n                    if (option < 5) {\r\n                        System.out.println(\"Option 3 with specific range\");\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                System.out.println(\"Default option\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    public void simplifyCompoundConditions(int x, int y, int z) {\r\n        // control_structure_complexity = 1, nesting_level = 1, compound_condition_weight = 4\r\n        if ((x > 0 && y > 0) || (z < 0 && x < 5)) {\r\n            System.out.println(\"Complex compound condition evaluated\");\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        CodeComplexityExample example = new CodeComplexityExample();\r\n\r\n        int[] values = {1, 12, 15, 3};\r\n        example.evaluateConditions(15, true);\r\n        example.evaluateLoops(values);\r\n        example.evaluateSwitchCase(3);\r\n        example.simplifyCompoundConditions(1, 2, -1);\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "ComplexCodeExample.java",
        "java_code": "public class ComplexCodeExample {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            Scanner scanner = new Scanner(System.in);\r\n            System.out.println(\"Enter a number:\");\r\n            int num = scanner.nextInt();\r\n\r\n            if (num > 0) {\r\n                if (num < 10) {\r\n                    if (num % 2 == 0) {\r\n                        if (num % 3 == 0) {\r\n                            if (num % 5 == 0) {\r\n                                System.out.println(\"Number is divisible by 2, 3, and 5.\");\r\n                            } else {\r\n                                System.out.println(\"Number is divisible by 2 and 3 but not 5.\");\r\n                            }\r\n                        } else {\r\n                            System.out.println(\"Number is even but not divisible by 3.\");\r\n                        }\r\n                    } else {\r\n                        System.out.println(\"Number is odd.\");\r\n                    }\r\n                } else {\r\n                    System.out.println(\"Number is 10 or greater.\");\r\n                }\r\n            } else {\r\n                System.out.println(\"Number is non-positive.\");\r\n            }\r\n\r\n            // Complex switch-case with deep nesting\r\n            switch (num) {\r\n                case 1:\r\n                    System.out.println(\"One\");\r\n                    break;\r\n                case 2:\r\n                    switch (num % 2) {\r\n                        case 0:\r\n                            System.out.println(\"Two and even\");\r\n                            break;\r\n                        default:\r\n                            System.out.println(\"Unexpected case\");\r\n                            break;\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    switch (num % 3) {\r\n                        case 0:\r\n                            System.out.println(\"Three and multiple of 3\");\r\n                            break;\r\n                        default:\r\n                            System.out.println(\"Unexpected case\");\r\n                            break;\r\n                    }\r\n                    break;\r\n                default:\r\n                    System.out.println(\"Some other number\");\r\n                    break;\r\n            }\r\n\r\n            // Multiple try-catch blocks\r\n            try {\r\n                int result = 100 / num;\r\n                System.out.println(\"Division result: \" + result);\r\n            } catch (ArithmeticException e) {\r\n                System.out.println(\"Error: Division by zero!\");\r\n            }\r\n\r\n            try {\r\n                int[] arr = new int[5];\r\n                System.out.println(arr[num]);\r\n            } catch (ArrayIndexOutOfBoundsException e) {\r\n                System.out.println(\"Error: Array index out of bounds!\");\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(\"General Exception: \" + e.getMessage());\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "HighComplexityExample.java",
        "java_code": "public class HighComplexityExample {\r\n    \r\n    public static void main(String[] args) {\r\n        try {\r\n            Scanner scanner = new Scanner(System.in);\r\n            System.out.println(\"Enter a number:\");\r\n            int num = scanner.nextInt();\r\n\r\n            // Deeply Nested If-Else\r\n            if (num > 0) {\r\n                if (num < 50) {\r\n                    if (num % 2 == 0) {\r\n                        if (num % 3 == 0) {\r\n                            if (num % 5 == 0) {\r\n                                System.out.println(\"Number is divisible by 2, 3, and 5.\");\r\n                            } else {\r\n                                System.out.println(\"Number is divisible by 2 and 3 but not 5.\");\r\n                            }\r\n                        } else {\r\n                            System.out.println(\"Number is even but not divisible by 3.\");\r\n                        }\r\n                    } else {\r\n                        if (num % 7 == 0 && num % 11 == 0 && num % 13 == 0) {\r\n                            System.out.println(\"Highly composite number.\");\r\n                        } else {\r\n                            System.out.println(\"Number is odd and large.\");\r\n                        }\r\n                    }\r\n                } else {\r\n                    System.out.println(\"Number is greater than or equal to 50.\");\r\n                }\r\n            } else {\r\n                System.out.println(\"Number is non-positive.\");\r\n            }\r\n\r\n            // Complex switch-case nesting\r\n            switch (num) {\r\n                case 1:\r\n                    System.out.println(\"One\");\r\n                    break;\r\n                case 2:\r\n                    switch (num % 2) {\r\n                        case 0:\r\n                            System.out.println(\"Two and even\");\r\n                            break;\r\n                        default:\r\n                            System.out.println(\"Unexpected case\");\r\n                            break;\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    switch (num % 3) {\r\n                        case 0:\r\n                            System.out.println(\"Three and multiple of 3\");\r\n                            break;\r\n                        default:\r\n                            System.out.println(\"Unexpected case\");\r\n                            break;\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    System.out.println(\"Four\");\r\n                    break;\r\n                default:\r\n                    System.out.println(\"Some other number\");\r\n                    break;\r\n            }\r\n\r\n            // Multiple Try-Catch Blocks\r\n            try {\r\n                int result = 100 / num;\r\n                System.out.println(\"Division result: \" + result);\r\n            } catch (ArithmeticException e) {\r\n                System.out.println(\"Error: Division by zero!\");\r\n            }\r\n\r\n            try {\r\n                int[] arr = new int[5];\r\n                System.out.println(arr[num]);\r\n            } catch (ArrayIndexOutOfBoundsException e) {\r\n                System.out.println(\"Error: Array index out of bounds!\");\r\n            }\r\n\r\n            try {\r\n                String str = null;\r\n                System.out.println(str.length());\r\n            } catch (NullPointerException e) {\r\n                System.out.println(\"Error: Null reference encountered!\");\r\n            }\r\n\r\n            // Deep Inheritance\r\n            BaseClass obj = new LevelFour();\r\n            obj.process();\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(\"General Exception: \" + e.getMessage());\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "ComplexJavaExampleee.java",
        "java_code": "import java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class ComplexJavaExample {\r\n\r\n    public static int processData(List<Integer> numbers, Map<String, Integer> config, boolean flag) {\r\n        int result = 0;\r\n\r\n        // Deeply nested conditionals\r\n        if (numbers != null && !numbers.isEmpty()) {\r\n            for (int num : numbers) {\r\n                if (num > 0) {\r\n                    if (config != null && config.containsKey(\"threshold\")) {\r\n                        int threshold = config.get(\"threshold\");\r\n                        if (num > threshold) {\r\n                            if (flag && num % 2 == 0) {\r\n                                result += num;\r\n                            } else if (!flag && num % 3 == 0) {\r\n                                result -= num;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Multiple nested loops\r\n        for (String key : config.keySet()) {\r\n            for (int i = 0; i < 5; i++) {\r\n                for (int j = 0; j < config.getOrDefault(key, 1); j++) {\r\n                    if ((i + j) % 2 == 0 || j > 3 && i < 2) { // Complex condition\r\n                        result += j * i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Multiple switch cases with deep nesting\r\n        switch (result % 5) {\r\n            case 0:\r\n                switch (result % 3) {\r\n                    case 0:\r\n                        result += 1;\r\n                        break;\r\n                    case 1:\r\n                        result += 2;\r\n                        break;\r\n                    default:\r\n                        result -= 1;\r\n                }\r\n                break;\r\n            case 1:\r\n                result *= 2;\r\n                break;\r\n            case 2:\r\n                result /= 2;\r\n                break;\r\n            default:\r\n                result = -1;\r\n        }\r\n\r\n        // Try-catch with deep nesting\r\n        try {\r\n            if (result > 0) {\r\n                try {\r\n                    int division = 100 / result;\r\n                    if (division > 10) {\r\n                        throw new ArithmeticException(\"Artificial Exception\");\r\n                    }\r\n                } catch (ArithmeticException e) {\r\n                    System.out.println(\"Caught inner arithmetic exception: \" + e.getMessage());\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            System.out.println(\"Caught outer exception: \" + e.getMessage());\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"
    },
    {
        "file_name": "ExtremeComplexityExample.java",
        "java_code": "import java.util.*;\r\n\r\npublic class ExtremeComplexityExample {\r\n\r\n    public static int evaluateLogic(Map<String, List<Integer>> dataMap, int factor, boolean isActive) {\r\n        int total = 0;\r\n\r\n        // Deeply nested conditions\r\n        if (dataMap != null && !dataMap.isEmpty()) {\r\n            for (String key : dataMap.keySet()) {\r\n                if (key.startsWith(\"config\")) {\r\n                    List<Integer> values = dataMap.get(key);\r\n                    if (values != null && !values.isEmpty()) {\r\n                        for (int value : values) {\r\n                            if (value > 0) {\r\n                                if (isActive && value % factor == 0) {\r\n                                    total += value;\r\n                                } else if (!isActive && value % (factor + 1) == 0) {\r\n                                    total -= value;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Multiple nested loops with complex logic\r\n        for (Map.Entry<String, List<Integer>> entry : dataMap.entrySet()) {\r\n            for (int i = 0; i < factor; i++) {\r\n                for (int j = 0; j < entry.getValue().size(); j++) {\r\n                    for (int k = 0; k < j; k++) {\r\n                        if ((i + j + k) % 3 == 0 && k > 2 || j < 4 && i % 2 == 0) {\r\n                            total += i * j * k;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deep switch-case nesting\r\n        switch (total % 4) {\r\n            case 0:\r\n                switch (total % 3) {\r\n                    case 0:\r\n                        switch (total % 2) {\r\n                            case 0:\r\n                                total += 5;\r\n                                break;\r\n                            case 1:\r\n                                total -= 3;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 1:\r\n                        total *= 2;\r\n                        break;\r\n                }\r\n                break;\r\n            case 1:\r\n                total /= (factor == 0) ? 1 : factor;\r\n                break;\r\n            default:\r\n                total = -total;\r\n        }\r\n\r\n        // Complex try-catch with nested error handling\r\n        try {\r\n            int computed = 100 / (total == 0 ? 1 : total);\r\n            try {\r\n                if (computed > 10) {\r\n                    throw new IllegalArgumentException(\"High Computation Warning!\");\r\n                }\r\n            } catch (IllegalArgumentException e) {\r\n                System.out.println(\"Inner exception caught: \" + e.getMessage());\r\n            }\r\n        } catch (ArithmeticException e) {\r\n            System.out.println(\"Outer exception caught: Division by zero.\");\r\n        } finally {\r\n            System.out.println(\"Final block executed\");\r\n        }\r\n\r\n        return total;\r\n    }\r\n}"
    },
    {
        "file_name": "ExtremeLogicProcessor.java",
        "java_code": "import java.util.*;\r\n\r\npublic class ExtremeLogicProcessor {\r\n\r\n    public static int processHierarchy(Map<String, List<Integer>> hierarchy, int level, boolean isEnabled) {\r\n        int score = 0;\r\n\r\n        // Deeply nested conditionals\r\n        if (hierarchy != null && !hierarchy.isEmpty()) {\r\n            for (String key : hierarchy.keySet()) {\r\n                if (key.startsWith(\"node\")) {\r\n                    List<Integer> values = hierarchy.get(key);\r\n                    if (values != null && !values.isEmpty()) {\r\n                        for (int value : values) {\r\n                            if (value > 0) {\r\n                                if (isEnabled && value % level == 0) {\r\n                                    if (value % 2 == 0) {\r\n                                        score += recursiveCompute(value, level, 3);\r\n                                    } else {\r\n                                        score -= recursiveCompute(value, level, 2);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Multiple nested loops with complex conditions\r\n        for (Map.Entry<String, List<Integer>> entry : hierarchy.entrySet()) {\r\n            for (int i = 0; i < level; i++) {\r\n                for (int j = 0; j < entry.getValue().size(); j++) {\r\n                    for (int k = 0; k < j; k++) {\r\n                        if ((i + j + k) % 3 == 0 && k > 2 || j < 4 && i % 2 == 0) {\r\n                            score += i * j * k - level;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Recursive complexity\r\n        if (level > 1) {\r\n            score += processHierarchy(hierarchy, level - 1, !isEnabled);\r\n        }\r\n\r\n        // Deep switch-case nesting\r\n        switch (score % 5) {\r\n            case 0:\r\n                switch (score % 3) {\r\n                    case 0:\r\n                        switch (score % 2) {\r\n                            case 0:\r\n                                score += 7;\r\n                                break;\r\n                            case 1:\r\n                                score -= 4;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 1:\r\n                        score *= 3;\r\n                        break;\r\n                }\r\n                break;\r\n            case 1:\r\n                score /= (level == 0) ? 1 : level;\r\n                break;\r\n            default:\r\n                score = -score;\r\n        }\r\n\r\n        // Complex try-catch with nested error handling\r\n        try {\r\n            int computed = 100 / (score == 0 ? 1 : score);\r\n            try {\r\n                if (computed > 50) {\r\n                    throw new IllegalArgumentException(\"Unusual Computation!\");\r\n                }\r\n            } catch (IllegalArgumentException e) {\r\n                System.out.println(\"Inner exception: \" + e.getMessage());\r\n            }\r\n        } catch (ArithmeticException e) {\r\n            System.out.println(\"Outer exception: Division by zero error.\");\r\n        } finally {\r\n            System.out.println(\"Execution finalized.\");\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    // Recursive function adding complexity\r\n    private static int recursiveCompute(int num, int factor, int depth) {\r\n        if (depth == 0) return num;\r\n        return num + recursiveCompute(num / (factor == 0 ? 1 : factor), factor, depth - 1);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Map<String, List<Integer>> hierarchy = new HashMap<>();\r\n        hierarchy.put(\"node1\", Arrays.asList(10, 20, 30));\r\n        hierarchy.put(\"node2\", Arrays.asList(15, 25, 35));\r\n        \r\n        int result = processHierarchy(hierarchy, 3, true);\r\n        System.out.println(\"Final Score: \" + result);\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "ThreadTest.java",
        "java_code": "public class ThreadTest {\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(() -> System.out.println(\"Thread 1\"));\r\n        Thread t2 = new Thread(() -> System.out.println(\"Thread 2\"));\r\n        \r\n        synchronized(this) {\r\n            System.out.println(\"Inside synchronized block\");\r\n            synchronized(this) {\r\n                System.out.println(\"Nested synchronized block\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    public synchronized void synchronizedMethod() {\r\n        System.out.println(\"Synchronized method\");\r\n        synchronized(this) {\r\n            System.out.println(\"Synchronized block inside method\");\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "Geeks.java",
        "java_code": "public class Geeks {\r\n    public static void main(String[] args) {\r\n        Line obj = new Line();\r\n        Train t1 = new Train(obj);  // Thread creation (via subclass)\r\n        Train t2 = new Train(obj);\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n}"
    },
    {
        "file_name": "Train.java",
        "java_code": "class Train extends Thread {\r\n    Line line;\r\n    Train(Line line) {\r\n        this.line = line;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        line.getLine();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "Zeeks.java",
        "java_code": "public class Zeeks {\r\n    public static void main(String[] args) {\r\n        Line obj = new Line();\r\n        Train t1 = new Train(obj);  // Thread creation (via subclass)\r\n        Train t2 = new Train(obj);\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n}"
    },
    {
        "file_name": "CBOMetricsExample.java",
        "java_code": "public class CBOMetricsExample {\r\n\r\n    // Global variable reference (Factor: Global Variable References)\r\n    private static int counter = 0;\r\n    \r\n    // Dependency Injection using constructor injection (Factor: Constructor Injection)\r\n    private DataService dataService;\r\n    private LoggerService loggerService;\r\n\r\n    // Static variable usage (Factor: Static Variable Usages)\r\n    private static final String APP_NAME = \"CBO Analysis Tool\";\r\n\r\n    // Constructor Injection (Factor: Constructor Injection)\r\n    public CBOMetricsExample(DataService dataService, LoggerService loggerService) {\r\n        this.dataService = dataService; // Assignment in constructor\r\n        this.loggerService = loggerService; // Assignment in constructor\r\n    }\r\n\r\n    // Setter Injection (Factor: Setter Injection)\r\n    public void setLoggerService(LoggerService loggerService) {\r\n        this.loggerService = loggerService; // Assignment in setter\r\n    }\r\n\r\n    // Method demonstrating direct object instantiation (Factor: Direct Object Instantiations)\r\n    public void performAnalysis() {\r\n        // Direct Instantiation of Helper Class\r\n        Helper helper = new Helper(); \r\n        helper.analyze();\r\n\r\n        // Direct instantiation of a thread (Factor: Direct Object Instantiations)\r\n        Thread t1 = new Thread(() -> System.out.println(\"Running a separate thread...\"));\r\n        t1.start();\r\n\r\n        // Using the injected dependency\r\n        dataService.fetchData();\r\n        loggerService.logMessage(\"Data processing completed.\");\r\n\r\n        // Static method call (Factor: Static Method Calls)\r\n        String formattedTime = Utility.getCurrentTimestamp();\r\n        System.out.println(\"Formatted Time: \" + formattedTime);\r\n\r\n        // Static variable usage (Factor: Static Variable Usages)\r\n        System.out.println(\"Application: \" + APP_NAME);\r\n\r\n        // Using a built-in system class (should not be counted as dependency)\r\n        System.out.println(\"Counter Value: \" + counter);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        // Using Constructor Injection\r\n        CBOMetricsExample cboMetrics = new CBOMetricsExample(new DatabaseService(), new FileLogger());\r\n        \r\n        // Using Setter Injection\r\n        cboMetrics.setLoggerService(new FileLogger());\r\n\r\n        cboMetrics.performAnalysis();\r\n    }\r\n}"
    },
    {
        "file_name": "CBOExample.java",
        "java_code": "public class CBOExample {\r\n\r\n    // Static variable usage (Factor: Static Variable Usages)\r\n    private static final Logger LOGGER = Logger.getLogger(CBOExample.class.getName());\r\n\r\n    // Global variable reference (Factor: Global Variable References)\r\n    private static int transactionCount = 0;\r\n\r\n    // Dependency Injection using constructor injection (Factor: Constructor Injection)\r\n    private PaymentService paymentService;\r\n    private NotificationService notificationService;\r\n\r\n    // Constructor Injection (Factor: Constructor Injection)\r\n    public CBOExample(PaymentService paymentService, NotificationService notificationService) {\r\n        this.paymentService = paymentService;\r\n        this.notificationService = notificationService;\r\n    }\r\n\r\n    // Setter Injection (Factor: Setter Injection)\r\n    public void setNotificationService(NotificationService notificationService) {\r\n        this.notificationService = notificationService;\r\n    }\r\n\r\n    // Method demonstrating direct object instantiation (Factor: Direct Object Instantiations)\r\n    public void processTransaction(double amount) {\r\n        // Direct instantiation of helper class\r\n        TransactionHelper helper = new TransactionHelper(); \r\n        helper.logTransaction();\r\n\r\n        // Direct instantiation of a thread (Factor: Direct Object Instantiations)\r\n        Thread transactionThread = new Thread(() -> System.out.println(\"Processing transaction asynchronously...\"));\r\n        transactionThread.start();\r\n\r\n        // Using the injected dependency\r\n        paymentService.processPayment(amount);\r\n        notificationService.sendNotification(\"Payment of $\" + amount + \" is completed.\");\r\n\r\n        // Static method call (Factor: Static Method Calls)\r\n        String transactionId = TransactionUtil.generateTransactionId();\r\n        System.out.println(\"Transaction ID: \" + transactionId);\r\n\r\n        // Static variable usage (Factor: Static Variable Usages)\r\n        LOGGER.info(\"Transaction processed successfully.\");\r\n\r\n        // Using a built-in system class (should not be counted as dependency)\r\n        System.out.println(\"Total Transactions: \" + (++transactionCount));\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        // Using Constructor Injection\r\n        CBOExample transactionProcessor = new CBOExample(new CreditCardPayment(), new EmailNotification());\r\n        \r\n        // Using Setter Injection\r\n        transactionProcessor.setNotificationService(new SMSNotification());\r\n\r\n        transactionProcessor.processTransaction(150.75);\r\n    }\r\n}"
    },
    {
        "file_name": "CBOExampleAdvanced.java",
        "java_code": "public class CBOExampleAdvanced {\r\n\r\n    // Static variable usage (Factor: Static Variable Usages)\r\n    private static final String SYSTEM_VERSION = \"1.0.5\";\r\n\r\n    // Global variable reference (Factor: Global Variable References)\r\n    private static int notificationCount = 0;\r\n\r\n    // Dependency Injection via constructor (Factor: Constructor Injection)\r\n    private NotificationService notificationService;\r\n\r\n    // Constructor Injection\r\n    public CBOExampleAdvanced(NotificationService notificationService) {\r\n        this.notificationService = notificationService;\r\n    }\r\n\r\n    // Setter Injection (Factor: Setter Injection)\r\n    public void setNotificationService(NotificationService notificationService) {\r\n        this.notificationService = notificationService;\r\n    }\r\n\r\n    // Direct object instantiations & Thread usage (Factor: Direct Object Instantiations)\r\n    public void processNotifications() {\r\n        // Using Factory Pattern\r\n        NotificationService emailService = NotificationFactory.createNotification(\"email\");\r\n        emailService.sendNotification(\"Your order has been shipped.\");\r\n\r\n        // Direct Instantiation of a Helper Class\r\n        UtilityHelper helper = new UtilityHelper();\r\n        helper.logMessage(\"Notification processed.\");\r\n\r\n        // Using Reflection (Factor: Advanced Dynamic Calls)\r\n        try {\r\n            Method method = UtilityHelper.class.getMethod(\"logMessage\", String.class);\r\n            method.invoke(helper, \"Reflection API Used\");\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // Using a thread (Factor: Direct Object Instantiations)\r\n        Thread notifyThread = new Thread(() -> System.out.println(\"Asynchronous Notification Running...\"));\r\n        notifyThread.start();\r\n\r\n        // Static method call (Factor: Static Method Calls)\r\n        String transactionId = TransactionUtils.generateTransactionId();\r\n        System.out.println(\"Transaction ID: \" + transactionId);\r\n\r\n        // Static variable usage (Factor: Static Variable Usages)\r\n        System.out.println(\"System Version: \" + SYSTEM_VERSION);\r\n\r\n        // Using Global Variable\r\n        notificationCount++;\r\n        System.out.println(\"Total Notifications Sent: \" + notificationCount);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        // Using Constructor Injection\r\n        CBOExampleAdvanced transactionProcessor = new CBOExampleAdvanced(new SMSNotification());\r\n\r\n        // Using Setter Injection\r\n        transactionProcessor.setNotificationService(new EmailNotification());\r\n\r\n        // Processing Notifications\r\n        transactionProcessor.processNotifications();\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "LowCBOExample.java",
        "java_code": "public class LowCBOExample {\r\n    public static void main(String[] args) {\r\n        // Using dependency injection instead of direct instantiation\r\n        Notifier emailNotifier = new EmailNotifier();\r\n        NotificationService emailService = new NotificationService(emailNotifier);\r\n        emailService.notifyUser(\"Your order has been shipped!\");\r\n\r\n        Notifier smsNotifier = new SMSNotifier();\r\n        NotificationService smsService = new NotificationService(smsNotifier);\r\n        smsService.notifyUser(\"Your OTP is 123456.\");\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "LowCBOExample2.java",
        "java_code": "public class LowCBOExample2 implements A, B, C{\r\n    public static void main(String[] args) {\r\n        // Using Dependency Injection instead of Direct Instantiation\r\n        Logger consoleLogger = new ConsoleLogger();\r\n        OrderProcessor orderProcessor = new OrderProcessor(consoleLogger);\r\n        orderProcessor.processOrder(\"ORD123\");\r\n\r\n        // Changing Logger Without Modifying OrderProcessor\r\n        Logger fileLogger = new FileLogger();\r\n        OrderProcessor fileOrderProcessor = new OrderProcessor(fileLogger);\r\n        fileOrderProcessor.processOrder(\"ORD456\");\r\n    }\r\n}"
    },
    {
        "file_name": "OrderProcessorrr.java",
        "java_code": "class OrderProcessor {\r\n    private final Logger logger;\r\n\r\n    // Constructor Injection (Reduces Direct Dependencies)\r\n    public OrderProcessor(Logger logger) {\r\n        this.logger = logger;\r\n    }\r\n\r\n    // Process Order (Logs status)\r\n    public void processOrder(String orderId) {\r\n        logger.log(\"Processing order: \" + orderId);\r\n    }\r\n}"
    },
    {
        "file_name": "12.ComplexDependencyManager.java",
        "java_code": "\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ComplexDependencyManager {\n    private List<String> dataList;\n    private Map<String, Integer> dataMap;\n    private static final Logger logger = Logger.getLogger(ComplexDependencyManager.class.getName());\n    \n    public ComplexDependencyManager() {\n        this.dataList = new ArrayList<>();\n        this.dataMap = new HashMap<>();\n    }\n    \n    public void loadData() {\n        dataList.add(\"Data1\");\n        dataList.add(\"Data2\");\n        dataMap.put(\"Data1\", 10);\n        dataMap.put(\"Data2\", 20);\n    }\n    \n    public void processData() {\n        for (String key : dataList) {\n            System.out.println(\"Processing: \" + key);\n        }\n    }\n    \n    public void saveToFile() {\n        try {\n            File file = new File(\"output.txt\");\n            FileWriter writer = new FileWriter(file);\n            for (Map.Entry<String, Integer> entry : dataMap.entrySet()) {\n                writer.write(entry.getKey() + \": \" + entry.getValue() + \"\\n\");\n            }\n            writer.close();\n        } catch (IOException e) {\n            logger.severe(\"File writing error: \" + e.getMessage());\n        }\n    }\n    \n    public static void logInfo(String message) {\n        logger.info(message);\n    }\n}\n"
    },
    {
        "file_name": "1.ComplexServiceManager.java",
        "java_code": "\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.logging.Logger;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class ComplexServiceManager {\n    private List<String> records;\n    private static final Logger logger = Logger.getLogger(ComplexServiceManager.class.getName());\n    private Connection connection;\n\n    public ComplexServiceManager() {\n        this.records = new ArrayList<>();\n        try {\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"user\", \"password\");\n        } catch (SQLException e) {\n            logger.severe(\"Database connection failed: \" + e.getMessage());\n        }\n    }\n\n    public void addRecord(String record) {\n        records.add(record);\n    }\n\n    public void saveToFile() {\n        try {\n            File file = new File(\"records.txt\");\n            FileWriter writer = new FileWriter(file);\n            for (String record : records) {\n                writer.write(record + \"\\n\");\n            }\n            writer.close();\n        } catch (IOException e) {\n            logger.severe(\"File writing error: \" + e.getMessage());\n        }\n    }\n}"
    },
    {
        "file_name": "2.AdvancedPaymentProcessor.java",
        "java_code": "\nimport java.util.Random;\nimport java.util.logging.Logger;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class AdvancedPaymentProcessor {\n    private static final Logger logger = Logger.getLogger(AdvancedPaymentProcessor.class.getName());\n    private Random random;\n\n    public AdvancedPaymentProcessor() {\n        this.random = new Random();\n    }\n\n    public boolean processPayment(double amount) {\n        logger.info(\"Processing payment of: \" + amount);\n        return random.nextBoolean();\n    }\n\n    public String sendTransactionData(String jsonData) {\n        try {\n            URL url = new URL(\"https://api.paymentgateway.com/transaction\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setDoOutput(true);\n            \n            OutputStream os = conn.getOutputStream();\n            os.write(jsonData.getBytes());\n            os.flush();\n            os.close();\n            \n            BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line);\n            }\n            br.close();\n            return response.toString();\n        } catch (IOException e) {\n            logger.severe(\"Transaction failed: \" + e.getMessage());\n            return null;\n        }\n    }\n}"
    },
    {
        "file_name": "3.ComplexDataAnalyzer.java",
        "java_code": "\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.logging.Logger;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\n\npublic class ComplexDataAnalyzer {\n    private List<Integer> numbers;\n    private static final Logger logger = Logger.getLogger(ComplexDataAnalyzer.class.getName());\n\n    public ComplexDataAnalyzer() {\n        numbers = new ArrayList<>();\n    }\n\n    public void loadDataFromFile(String filePath) {\n        try {\n            List<String> lines = Files.readAllLines(Paths.get(filePath));\n            for (String line : lines) {\n                numbers.add(Integer.parseInt(line));\n            }\n        } catch (IOException | NumberFormatException e) {\n            logger.severe(\"Error reading file: \" + e.getMessage());\n        }\n    }\n\n    public int getMaxValue() {\n        return Collections.max(numbers);\n    }\n}"
    },
    {
        "file_name": "4.LoggingDatabaseManager.java",
        "java_code": "\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.logging.Logger;\n\npublic class LoggingDatabaseManager {\n    private static final Logger logger = Logger.getLogger(LoggingDatabaseManager.class.getName());\n    private Connection connection;\n\n    public LoggingDatabaseManager() {\n        try {\n            connection = DriverManager.getConnection(\"jdbc:sqlite:sample.db\");\n        } catch (SQLException e) {\n            logger.severe(\"Database connection failed: \" + e.getMessage());\n        }\n    }\n\n    public void fetchData() {\n        String query = \"SELECT * FROM users\";\n        try (PreparedStatement stmt = connection.prepareStatement(query);\n             ResultSet rs = stmt.executeQuery()) {\n            while (rs.next()) {\n                logger.info(\"User ID: \" + rs.getInt(\"id\") + \" Name: \" + rs.getString(\"name\"));\n            }\n        } catch (SQLException e) {\n            logger.severe(\"Data fetch error: \" + e.getMessage());\n        }\n    }\n}"
    },
    {
        "file_name": "5.CloudStorageManager.java",
        "java_code": "\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class CloudStorageManager {\n    private static final Logger logger = Logger.getLogger(CloudStorageManager.class.getName());\n\n    public void uploadFile(String data) {\n        try {\n            URL url = new URL(\"https://api.cloudstorage.com/upload\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setDoOutput(true);\n            \n            OutputStream os = conn.getOutputStream();\n            os.write(data.getBytes());\n            os.flush();\n            os.close();\n            \n            logger.info(\"File uploaded successfully\");\n        } catch (IOException e) {\n            logger.severe(\"Upload failed: \" + e.getMessage());\n        }\n    }\n}"
    },
    {
        "file_name": "1.DataProcessingManager.java",
        "java_code": "\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.logging.Logger;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\n\npublic class DataProcessingManager {\n    private List<String> dataRecords;\n    private static final Logger logger = Logger.getLogger(DataProcessingManager.class.getName());\n    private Connection connection;\n\n    public DataProcessingManager() {\n        this.dataRecords = new ArrayList<>();\n        try {\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"user\", \"password\");\n        } catch (SQLException e) {\n            logger.severe(\"Database connection failed: \" + e.getMessage());\n        }\n    }\n\n    public void loadDataFromFile(String filePath) {\n        try {\n            dataRecords = Files.readAllLines(Paths.get(filePath));\n        } catch (IOException e) {\n            logger.severe(\"File read error: \" + e.getMessage());\n        }\n    }\n\n    public void processRecords() {\n        for (String record : dataRecords) {\n            logger.info(\"Processing record: \" + record);\n        }\n    }\n}"
    },
    {
        "file_name": "2.AdvancedLoggingService.java",
        "java_code": "\nimport java.util.logging.Logger;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class AdvancedLoggingService {\n    private static final Logger logger = Logger.getLogger(AdvancedLoggingService.class.getName());\n    private FileWriter fileWriter;\n\n    public AdvancedLoggingService(String logFile) {\n        try {\n            this.fileWriter = new FileWriter(logFile, true);\n        } catch (IOException e) {\n            logger.severe(\"File opening error: \" + e.getMessage());\n        }\n    }\n\n    public void logMessage(String message) {\n        try {\n            fileWriter.write(message + \"\\n\");\n            fileWriter.flush();\n        } catch (IOException e) {\n            logger.severe(\"Logging error: \" + e.getMessage());\n        }\n    }\n\n    public void logWithReflection() {\n        try {\n            Method method = this.getClass().getMethod(\"logMessage\", String.class);\n            method.invoke(this, \"Logging via Reflection\");\n        } catch (Exception e) {\n            logger.severe(\"Reflection error: \" + e.getMessage());\n        }\n    }\n}"
    },
    {
        "file_name": "3.PaymentTransactionHandler.java",
        "java_code": "\nimport java.util.Random;\nimport java.util.logging.Logger;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class PaymentTransactionHandler {\n    private static final Logger logger = Logger.getLogger(PaymentTransactionHandler.class.getName());\n    private Random random;\n\n    public PaymentTransactionHandler() {\n        this.random = new Random();\n    }\n\n    public boolean processTransaction(double amount) {\n        logger.info(\"Processing transaction of: \" + amount);\n        return random.nextBoolean();\n    }\n\n    public void notifyServer(String transactionData) {\n        try {\n            URL url = new URL(\"https://api.transactions.com/notify\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setDoOutput(true);\n\n            OutputStream os = conn.getOutputStream();\n            os.write(transactionData.getBytes());\n            os.flush();\n            os.close();\n\n            logger.info(\"Transaction notification sent\");\n        } catch (IOException e) {\n            logger.severe(\"Notification error: \" + e.getMessage());\n        }\n    }\n}"
    },
    {
        "file_name": "4.MultiThreadedDataProcessor.java",
        "java_code": "\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.logging.Logger;\n\npublic class MultiThreadedDataProcessor {\n    private static final Logger logger = Logger.getLogger(MultiThreadedDataProcessor.class.getName());\n    private ExecutorService executor;\n    private List<String> data;\n\n    public MultiThreadedDataProcessor() {\n        this.executor = Executors.newFixedThreadPool(5);\n        this.data = new ArrayList<>();\n    }\n\n    public void processData() {\n        for (String record : data) {\n            executor.submit(() -> {\n                logger.info(\"Processing record: \" + record);\n            });\n        }\n    }\n\n    public void shutdown() {\n        executor.shutdown();\n    }\n}"
    },
    {
        "file_name": "5.CloudSyncManager.java",
        "java_code": "\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class CloudSyncManager {\n    private static final Logger logger = Logger.getLogger(CloudSyncManager.class.getName());\n\n    public void syncData(String jsonData) {\n        try {\n            URL url = new URL(\"https://api.cloudstorage.com/sync\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setDoOutput(true);\n            \n            OutputStream os = conn.getOutputStream();\n            os.write(jsonData.getBytes());\n            os.flush();\n            os.close();\n            \n            logger.info(\"Data synced successfully\");\n        } catch (IOException e) {\n            logger.severe(\"Sync error: \" + e.getMessage());\n        }\n    }\n}"
    },
    {
        "file_name": "1.OrderProcessor.java",
        "java_code": "public class OrderProcessor {\n    private static final String SYSTEM_VERSION = \"2.0\";\n    private static int orderCount = 0;\n    private PaymentService paymentService;\n    public OrderProcessor(PaymentService paymentService) {\n        this.paymentService = paymentService;\n    }\n    public void setPaymentService(PaymentService paymentService) {\n        this.paymentService = paymentService;\n    }\n    public void processOrder(String orderId, double amount) {\n        OrderValidator validator = new OrderValidator();\n        if (validator.validate(orderId)) {\n            paymentService.pay(amount);\n            LoggerService.log(\"Order processed: \" + orderId);\n        }\n        orderCount++;\n        LoggerService.log(\"Total Orders: \" + orderCount);\n    }\n}"
    },
    {
        "file_name": "2.ChatMessenger.java",
        "java_code": "public class ChatMessenger {\n    private static final String PLATFORM = \"MessagingApp\";\n    private static int messageCount = 0;\n    private MessageService messageService;\n    public ChatMessenger(MessageService messageService) {\n        this.messageService = messageService;\n    }\n    public void setMessageService(MessageService messageService) {\n        this.messageService = messageService;\n    }\n    public void sendMessage(String user, String message) {\n        EncryptionUtility encryptor = new EncryptionUtility();\n        String encryptedMessage = encryptor.encrypt(message);\n        messageService.send(user, encryptedMessage);\n        LoggerService.log(\"Message sent to: \" + user);\n        messageCount++;\n        LoggerService.log(\"Total Messages: \" + messageCount);\n    }\n}"
    },
    {
        "file_name": "3.SensorMonitor.java",
        "java_code": "public class SensorMonitor {\n    private static int sensorCount = 0;\n    private AlertService alertService;\n    public SensorMonitor(AlertService alertService) {\n        this.alertService = alertService;\n    }\n    public void setAlertService(AlertService alertService) {\n        this.alertService = alertService;\n    }\n    public void analyzeData(String sensorId, double reading) {\n        DataAnalyzer analyzer = new DataAnalyzer();\n        boolean isAnomaly = analyzer.detectAnomaly(reading);\n        if (isAnomaly) {\n            alertService.triggerAlert(sensorId, \"Anomaly detected!\");\n            LoggerService.log(\"Alert triggered for sensor: \" + sensorId);\n        }\n        sensorCount++;\n        LoggerService.log(\"Total Sensors Monitored: \" + sensorCount);\n    }\n}"
    },
    {
        "file_name": "4.AutomationEngine.java",
        "java_code": "public class AutomationEngine {\n    private static final String ENGINE_VERSION = \"3.1\";\n    private static int automationCount = 0;\n    private TaskScheduler taskScheduler;\n    public AutomationEngine(TaskScheduler taskScheduler) {\n        this.taskScheduler = taskScheduler;\n    }\n    public void setTaskScheduler(TaskScheduler taskScheduler) {\n        this.taskScheduler = taskScheduler;\n    }\n    public void executeTask(String taskId) {\n        TaskValidator validator = new TaskValidator();\n        if (validator.isValid(taskId)) {\n            taskScheduler.schedule(taskId);\n            LoggerService.log(\"Task scheduled: \" + taskId);\n        }\n        automationCount++;\n        LoggerService.log(\"Total Automations: \" + automationCount);\n    }\n}"
    },
    {
        "file_name": "5.BillingSystem.java",
        "java_code": "public class BillingSystem {\n    private static final String BILLING_VERSION = \"5.0\";\n    private static int invoiceCount = 0;\n    private InvoiceService invoiceService;\n    public BillingSystem(InvoiceService invoiceService) {\n        this.invoiceService = invoiceService;\n    }\n    public void setInvoiceService(InvoiceService invoiceService) {\n        this.invoiceService = invoiceService;\n    }\n    public void generateInvoice(String customerId, double amount) {\n        DiscountCalculator calculator = new DiscountCalculator();\n        double finalAmount = calculator.applyDiscount(customerId, amount);\n        invoiceService.createInvoice(customerId, finalAmount);\n        LoggerService.log(\"Invoice generated for: \" + customerId);\n        invoiceCount++;\n        LoggerService.log(\"Total Invoices: \" + invoiceCount);\n    }\n}"
    },
    {
        "file_name": "1.UserAccountManager.java",
        "java_code": "public class UserAccountManager {\n    private static final String APP_VERSION = \"1.5.0\";\n    private static int userCount = 0;\n    private DatabaseService databaseService;\n    public UserAccountManager(DatabaseService databaseService) {\n        this.databaseService = databaseService;\n    }\n    public void setDatabaseService(DatabaseService databaseService) {\n        this.databaseService = databaseService;\n    }\n    public void createUser(String username, String password) {\n        PasswordHasher hasher = new PasswordHasher();\n        String hashedPassword = hasher.hash(password);\n        databaseService.saveUser(username, hashedPassword);\n        LoggerService.log(\"User created: \" + username);\n        userCount++;\n        LoggerService.log(\"Total Users: \" + userCount);\n    }\n}"
    },
    {
        "file_name": "2.ECommerceOrderProcessor.java",
        "java_code": "public class ECommerceOrderProcessor {\n    private static final String PLATFORM_NAME = \"ShopEase\";\n    private static int orderTotal = 0;\n    private PaymentGateway paymentGateway;\n    public ECommerceOrderProcessor(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n    public void setPaymentGateway(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n    public void processOrder(String orderId, double amount) {\n        OrderValidator validator = new OrderValidator();\n        if (validator.validate(orderId)) {\n            paymentGateway.processPayment(amount);\n            LoggerService.log(\"Order processed: \" + orderId);\n        }\n        orderTotal++;\n        LoggerService.log(\"Total Orders: \" + orderTotal);\n    }\n}"
    },
    {
        "file_name": "3.SmartHomeController.java",
        "java_code": "public class SmartHomeController {\n    private static final String CONTROLLER_VERSION = \"2.1\";\n    private static int deviceCount = 0;\n    private DeviceManager deviceManager;\n    public SmartHomeController(DeviceManager deviceManager) {\n        this.deviceManager = deviceManager;\n    }\n    public void setDeviceManager(DeviceManager deviceManager) {\n        this.deviceManager = deviceManager;\n    }\n    public void controlDevice(String deviceId, String action) {\n        CommandExecutor executor = new CommandExecutor();\n        if (executor.execute(action)) {\n            deviceManager.updateDeviceStatus(deviceId, action);\n            LoggerService.log(\"Device controlled: \" + deviceId);\n        }\n        deviceCount++;\n        LoggerService.log(\"Total Devices Controlled: \" + deviceCount);\n    }\n}"
    },
    {
        "file_name": "4.InvestmentPortfolioManager.java",
        "java_code": "public class InvestmentPortfolioManager {\n    private static final String PORTFOLIO_VERSION = \"3.2\";\n    private static int transactionCount = 0;\n    private MarketDataService marketDataService;\n    public InvestmentPortfolioManager(MarketDataService marketDataService) {\n        this.marketDataService = marketDataService;\n    }\n    public void setMarketDataService(MarketDataService marketDataService) {\n        this.marketDataService = marketDataService;\n    }\n    public void analyzeInvestment(String stockSymbol, double amount) {\n        RiskAnalyzer analyzer = new RiskAnalyzer();\n        boolean risk = analyzer.evaluateRisk(stockSymbol, amount);\n        if (risk) {\n            marketDataService.trackStock(stockSymbol);\n            LoggerService.log(\"High-risk investment detected: \" + stockSymbol);\n        }\n        transactionCount++;\n        LoggerService.log(\"Total Transactions: \" + transactionCount);\n    }\n}"
    },
    {
        "file_name": "5.CRMSystem.java",
        "java_code": "public class CRMSystem {\n    private static final String CRM_VERSION = \"4.0\";\n    private static int customerCount = 0;\n    private CustomerService customerService;\n    public CRMSystem(CustomerService customerService) {\n        this.customerService = customerService;\n    }\n    public void setCustomerService(CustomerService customerService) {\n        this.customerService = customerService;\n    }\n    public void manageCustomer(String customerId) {\n        CustomerAnalyzer analyzer = new CustomerAnalyzer();\n        boolean isPremium = analyzer.isPremiumCustomer(customerId);\n        if (isPremium) {\n            customerService.upgradeCustomer(customerId);\n            LoggerService.log(\"Premium customer upgraded: \" + customerId);\n        }\n        customerCount++;\n        LoggerService.log(\"Total Customers Managed: \" + customerCount);\n    }\n}"
    },
    {
        "file_name": "6.HighCBOExample.java",
        "java_code": "public class HighCBOExample {\n    \n    // Static variable usage (Factor: Static Variable Usages)\n    private static final Logger LOGGER = Logger.getLogger(HighCBOExample.class.getName());\n    \n    // Global variable reference (Factor: Global Variable References)\n    private static int requestCount = 0;\n    \n    // Dependency Injection via constructor (Factor: Constructor Injection)\n    private DataService dataService;\n    private NotificationService notificationService;\n    \n    // Constructor Injection\n    public HighCBOExample(DataService dataService, NotificationService notificationService) {\n        this.dataService = dataService;\n        this.notificationService = notificationService;\n    }\n    \n    // Setter Injection (Factor: Setter Injection)\n    public void setNotificationService(NotificationService notificationService) {\n        this.notificationService = notificationService;\n    }\n    \n    // Direct Object Instantiations (Factor: Direct Object Instantiations)\n    public void processData(String data) {\n        // Direct Instantiation of Helper Class\n        DataProcessor processor = new DataProcessor();\n        processor.validateData(data);\n        \n        // Direct Instantiation of Thread\n        Thread processingThread = new Thread(() -> System.out.println(\"Asynchronous Data Processing...\"));\n        processingThread.start();\n        \n        // Using the injected dependencies\n        dataService.storeData(data);\n        notificationService.sendNotification(\"Data processed successfully: \" + data);\n        \n        // Static Method Call (Factor: Static Method Calls)\n        String dataId = DataUtil.generateDataId();\n        System.out.println(\"Processed Data ID: \" + dataId);\n        \n        // Static Variable Usage (Factor: Static Variable Usages)\n        LOGGER.info(\"Data Processing Completed.\");\n        \n        // Using a global variable\n        requestCount++;\n        System.out.println(\"Total Requests Processed: \" + requestCount);\n    }\n    \n    public static void main(String[] args) {\n        // Using Constructor Injection\n        HighCBOExample processor = new HighCBOExample(new CloudDataService(), new EmailNotifier());\n        \n        // Using Setter Injection\n        processor.setNotificationService(new SMSNotifier());\n        \n        // Processing Data\n        processor.processData(\"Sample Payload\");\n    }\n}"
    },
    {
        "file_name": "7.AdvancedCBOExample.java",
        "java_code": "public class AdvancedCBOExample {\n\n    // Static variable usage (Factor: Static Variable Usages)\n    private static final AuditLogger AUDIT_LOGGER = AuditLogger.getInstance();\n    \n    // Global variable reference (Factor: Global Variable References)\n    private static int reportCount = 0;\n    \n    // Dependency Injection via constructor (Factor: Constructor Injection)\n    private ReportGenerator reportGenerator;\n    private MessagingService messagingService;\n    \n    // Constructor Injection\n    public AdvancedCBOExample(ReportGenerator reportGenerator, MessagingService messagingService) {\n        this.reportGenerator = reportGenerator;\n        this.messagingService = messagingService;\n    }\n    \n    // Setter Injection (Factor: Setter Injection)\n    public void setMessagingService(MessagingService messagingService) {\n        this.messagingService = messagingService;\n    }\n    \n    // Direct Object Instantiations (Factor: Direct Object Instantiations)\n    public void generateReport(String reportName) {\n        // Direct Instantiation of Helper Class\n        ReportHelper helper = new ReportHelper();\n        helper.validateReport(reportName);\n        \n        // Direct Instantiation of Thread\n        Thread reportThread = new Thread(() -> System.out.println(\"Generating report asynchronously...\"));\n        reportThread.start();\n        \n        // Using the injected dependencies\n        reportGenerator.createReport(reportName);\n        messagingService.sendMessage(\"Report generated successfully: \" + reportName);\n        \n        // Static Method Call (Factor: Static Method Calls)\n        String uniqueId = ReportUtil.generateReportId();\n        System.out.println(\"Generated Report ID: \" + uniqueId);\n        \n        // Static Variable Usage (Factor: Static Variable Usages)\n        AUDIT_LOGGER.log(\"Report generated: \" + reportName);\n        \n        // Using a global variable\n        reportCount++;\n        System.out.println(\"Total Reports Generated: \" + reportCount);\n    }\n    \n    public static void main(String[] args) {\n        // Using Constructor Injection\n        AdvancedCBOExample reportManager = new AdvancedCBOExample(new PdfReportGenerator(), new EmailService());\n        \n        // Using Setter Injection\n        reportManager.setMessagingService(new SMSService());\n        \n        // Generating Report\n        reportManager.generateReport(\"Financial Report\");\n    }\n}"
    },
    {
        "file_name": "8.ReportProcessingSystem.java",
        "java_code": "public class ReportProcessor {\n    void processReport(String reportType);\n}\n\nclass FileReportProcessor implements ReportProcessor {\n    @Override\n    public void processReport(String reportType) {\n        System.out.println(\"Processing report of type: \" + reportType + \" using File Report Processor\");\n    }\n}\n\nclass DatabaseReportProcessor implements ReportProcessor {\n    @Override\n    public void processReport(String reportType) {\n        System.out.println(\"Processing report of type: \" + reportType + \" using Database Report Processor\");\n    }\n}\n\nclass ReportService {\n    private ReportProcessor reportProcessor;\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int reportCounter = 0;\n\n    public ReportService(ReportProcessor reportProcessor) {\n        this.reportProcessor = reportProcessor;\n    }\n    \n    public void setReportProcessor(ReportProcessor reportProcessor) {\n        this.reportProcessor = reportProcessor;\n    }\n\n    public void generateReport(String reportType) {\n        Helper helper = new Helper();\n        helper.validateReport(reportType);\n        \n        Thread reportThread = new Thread(() -> {\n            System.out.println(\"Generating report asynchronously...\");\n        });\n        reportThread.start();\n        \n        reportProcessor.processReport(reportType);\n        \n        String uniqueId = ReportUtil.generateUniqueId();\n        System.out.println(\"Report ID: \" + uniqueId);\n        \n        LOGGER.log(\"Report Generated: \" + reportType);\n        \n        reportCounter++;\n        System.out.println(\"Total Reports Processed: \" + reportCounter);\n    }\n}\n\npublic class ReportProcessingSystem {\n    public static void main(String[] args) {\n        ReportService reportService = new ReportService(new FileReportProcessor());\n        \n        reportService.generateReport(\"Financial Report\");\n        \n        reportService.setReportProcessor(new DatabaseReportProcessor());\n        reportService.generateReport(\"Annual Report\");\n    }\n}"
    },
    {
        "file_name": "9.PaymentProcessingSystem.java",
        "java_code": "public class PaymentProcessor implements A, B {\n    void processPayment(double amount);\n}\n\nclass CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n    }\n}\n\nclass PayPalProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing PayPal payment of $\" + amount);\n    }\n}\n\nclass PaymentService {\n    private PaymentProcessor paymentProcessor;\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int transactionCount = 0;\n\n    public PaymentService(PaymentProcessor paymentProcessor) {\n        this.paymentProcessor = paymentProcessor;\n    }\n\n    public void setPaymentProcessor(PaymentProcessor paymentProcessor) {\n        this.paymentProcessor = paymentProcessor;\n    }\n\n    public void processTransaction(double amount) {\n        Helper helper = new Helper();\n        helper.validateTransaction(amount);\n        \n        Thread transactionThread = new Thread(() -> {\n            System.out.println(\"Processing transaction asynchronously...\");\n        });\n        transactionThread.start();\n        \n        paymentProcessor.processPayment(amount);\n        \n        String transactionId = TransactionUtil.generateTransactionId();\n        System.out.println(\"Transaction ID: \" + transactionId);\n        \n        LOGGER.log(\"Transaction Completed for amount: $\" + amount);\n        \n        transactionCount++;\n        System.out.println(\"Total Transactions Processed: \" + transactionCount);\n    }\n}\n\npublic class PaymentProcessingSystem {\n    public static void main(String[] args) {\n        PaymentService paymentService = new PaymentService(new CreditCardProcessor());\n        \n        paymentService.processTransaction(150.75);\n        \n        paymentService.setPaymentProcessor(new PayPalProcessor());\n        paymentService.processTransaction(99.99);\n    }\n}"
    },
    {
        "file_name": "8.AdvancedCBOExample.java",
        "java_code": "public class LoggerService {\n    void log(String message);\n}\n\nclass FileLogger implements LoggerService {\n    @Override\n    public void log(String message) {\n        System.out.println(\"Logging to File: \" + message);\n    }\n}\n\nclass DatabaseLogger implements LoggerService {\n    @Override\n    public void log(String message) {\n        System.out.println(\"Logging to Database: \" + message);\n    }\n}\n\nclass LogManager {\n    private LoggerService loggerService;\n    private static final LogHelper LOG_HELPER = LogHelper.getInstance();\n    private static int logCount = 0;\n\n    public LogManager(LoggerService loggerService) {\n        this.loggerService = loggerService;\n    }\n\n    public void setLoggerService(LoggerService loggerService) {\n        this.loggerService = loggerService;\n    }\n\n    public void processLog(String message) {\n        LogHelper helper = new LogHelper();\n        helper.validateMessage(message);\n\n        Thread logThread = new Thread(() -> System.out.println(\"Logging asynchronously...\"));\n        logThread.start();\n\n        loggerService.log(message);\n\n        String logId = LogUtility.generateLogId();\n        System.out.println(\"Generated Log ID: \" + logId);\n\n        LOG_HELPER.log(\"Log processed: \" + message);\n\n        logCount++;\n        System.out.println(\"Total Logs Processed: \" + logCount);\n    }\n}\n\npublic class AdvancedCBOExample {\n    public static void main(String[] args) {\n        LogManager logManager = new LogManager(new FileLogger());\n\n        logManager.processLog(\"Application started successfully.\");\n\n        logManager.setLoggerService(new DatabaseLogger());\n        logManager.processLog(\"Database connection established.\");\n    }\n}"
    },
    {
        "file_name": "1.UserManagement.java",
        "java_code": "public class UserRepository {\n    void saveUser(String username);\n}\n\nclass SQLUserRepository implements UserRepository {\n    @Override\n    public void saveUser(String username) {\n        System.out.println(\"Saving user to SQL Database: \" + username);\n    }\n}\n\nclass UserService {\n    private UserRepository userRepository;\n    private static final AuditLogger auditLogger = AuditLogger.getInstance();\n    private static int userCount = 0;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public void registerUser(String username) {\n        userRepository.saveUser(username);\n        auditLogger.log(\"User registered: \" + username);\n        userCount++;\n        System.out.println(\"Total Users Registered: \" + userCount);\n    }\n}\n\npublic class UserManagement {\n    public static void main(String[] args) {\n        UserService userService = new UserService(new SQLUserRepository());\n        userService.registerUser(\"JohnDoe\");\n    }\n}"
    },
    {
        "file_name": "2.PaymentProcessor.java",
        "java_code": "public class PaymentGateway {\n    void processPayment(double amount);\n}\n\nclass PayPalGateway implements PaymentGateway {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing payment via PayPal: $\" + amount);\n    }\n}\n\nclass PaymentService {\n    private PaymentGateway paymentGateway;\n    private static final Logger logger = Logger.getInstance();\n    private static double totalPayments = 0.0;\n\n    public PaymentService(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n\n    public void setPaymentGateway(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n\n    public void process(double amount) {\n        paymentGateway.processPayment(amount);\n        logger.log(\"Payment processed: $\" + amount);\n        totalPayments += amount;\n        System.out.println(\"Total Payments Processed: $\" + totalPayments);\n    }\n}\n\npublic class PaymentProcessor {\n    public static void main(String[] args) {\n        PaymentService paymentService = new PaymentService(new PayPalGateway());\n        paymentService.process(100.0);\n    }\n}"
    },
    {
        "file_name": "3.OrderProcessing.java",
        "java_code": "public class OrderRepository {\n    void saveOrder(String orderId);\n}\n\nclass CloudOrderRepository implements OrderRepository {\n    @Override\n    public void saveOrder(String orderId) {\n        System.out.println(\"Order saved in Cloud: \" + orderId);\n    }\n}\n\nclass OrderService {\n    private OrderRepository orderRepository;\n    private static final Inventory inventory = Inventory.getInstance();\n    private static int orderCount = 0;\n\n    public OrderService(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n\n    public void placeOrder(String orderId) {\n        orderRepository.saveOrder(orderId);\n        inventory.updateStock(orderId);\n        orderCount++;\n        System.out.println(\"Total Orders Placed: \" + orderCount);\n    }\n}\n\npublic class OrderProcessing {\n    public static void main(String[] args) {\n        OrderService orderService = new OrderService(new CloudOrderRepository());\n        orderService.placeOrder(\"ORD1234\");\n    }\n}"
    },
    {
        "file_name": "4.AuthenticationSystem.java",
        "java_code": "public class AuthProvider {\n    boolean authenticate(String username, String password);\n}\n\nclass OAuthProvider implements AuthProvider {\n    @Override\n    public boolean authenticate(String username, String password) {\n        System.out.println(\"Authenticating via OAuth: \" + username);\n        return true;\n    }\n}\n\nclass AuthService {\n    private AuthProvider authProvider;\n    private static final AuditTrail auditTrail = AuditTrail.getInstance();\n    private static int loginAttempts = 0;\n\n    public AuthService(AuthProvider authProvider) {\n        this.authProvider = authProvider;\n    }\n\n    public void login(String username, String password) {\n        boolean isAuthenticated = authProvider.authenticate(username, password);\n        auditTrail.record(\"User Login Attempt: \" + username);\n        loginAttempts++;\n        System.out.println(\"Login Attempts: \" + loginAttempts);\n    }\n}\n\npublic class AuthenticationSystem {\n    public static void main(String[] args) {\n        AuthService authService = new AuthService(new OAuthProvider());\n        authService.login(\"Alice\", \"password123\");\n    }\n}"
    },
    {
        "file_name": "5.NotificationService.java",
        "java_code": "public class Notifier {\n    void sendNotification(String message);\n}\n\nclass EmailNotifier implements Notifier {\n    @Override\n    public void sendNotification(String message) {\n        System.out.println(\"Sending Email Notification: \" + message);\n    }\n}\n\nclass NotificationService {\n    private Notifier notifier;\n    private static final NotificationLogger notificationLogger = NotificationLogger.getInstance();\n    private static int notificationCount = 0;\n\n    public NotificationService(Notifier notifier) {\n        this.notifier = notifier;\n    }\n\n    public void setNotifier(Notifier notifier) {\n        this.notifier = notifier;\n    }\n\n    public void notifyUser(String message) {\n        notifier.sendNotification(message);\n        notificationLogger.log(\"Notification Sent: \" + message);\n        notificationCount++;\n        System.out.println(\"Total Notifications Sent: \" + notificationCount);\n    }\n}\n\npublic class NotificationSystem {\n    public static void main(String[] args) {\n        NotificationService notificationService = new NotificationService(new EmailNotifier());\n        notificationService.notifyUser(\"Your package has shipped!\");\n    }\n}"
    },
    {
        "file_name": "1.OnlineShopping.java",
        "java_code": "public class PaymentGateway {\n    void processPayment(double amount);\n}\n\nclass StripeGateway implements PaymentGateway {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing payment via Stripe: $\" + amount);\n    }\n}\n\nclass ShoppingCart {\n    private PaymentGateway paymentGateway;\n    private static final Logger logger = Logger.getInstance();\n    private static int cartItemCount = 0;\n\n    public ShoppingCart(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n\n    public void setPaymentGateway(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n\n    public void checkout(double amount) {\n        paymentGateway.processPayment(amount);\n        logger.log(\"Checkout complete: $\" + amount);\n        cartItemCount++;\n        System.out.println(\"Total Items Checked Out: \" + cartItemCount);\n    }\n}\n\npublic class OnlineShopping {\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart(new StripeGateway());\n        cart.checkout(250.0);\n    }\n}"
    },
    {
        "file_name": "2.BankingSystem.java",
        "java_code": "public class LoanProcessor {\n    void approveLoan(String account);\n}\n\nclass MortgageLoanProcessor implements LoanProcessor {\n    @Override\n    public void approveLoan(String account) {\n        System.out.println(\"Approving Mortgage Loan for: \" + account);\n    }\n}\n\nclass Bank {\n    private LoanProcessor loanProcessor;\n    private static final Security security = Security.getInstance();\n    private static double totalLoans = 0.0;\n\n    public Bank(LoanProcessor loanProcessor) {\n        this.loanProcessor = loanProcessor;\n    }\n\n    public void approveLoan(String account) {\n        loanProcessor.approveLoan(account);\n        security.validateUser(account);\n        totalLoans++;\n        System.out.println(\"Total Loans Approved: \" + totalLoans);\n    }\n}\n\npublic class BankingSystem {\n    public static void main(String[] args) {\n        Bank bank = new Bank(new MortgageLoanProcessor());\n        bank.approveLoan(\"123456789\");\n    }\n}"
    },
    {
        "file_name": "3.SocialMediaPlatform.java",
        "java_code": "public class NotificationSender {\n    void sendNotification(String user, String message);\n}\n\nclass PushNotificationSender implements NotificationSender {\n    @Override\n    public void sendNotification(String user, String message) {\n        System.out.println(\"Sending push notification to \" + user + \": \" + message);\n    }\n}\n\nclass SocialMediaApp {\n    private NotificationSender notificationSender;\n    private static final LogManager logManager = LogManager.getInstance();\n    private static int totalPosts = 0;\n\n    public SocialMediaApp(NotificationSender notificationSender) {\n        this.notificationSender = notificationSender;\n    }\n\n    public void createPost(String user, String content) {\n        System.out.println(user + \" created a post: \" + content);\n        notificationSender.sendNotification(user, \"Your post is live!\");\n        logManager.logActivity(user, \"New post created\");\n        totalPosts++;\n        System.out.println(\"Total Posts: \" + totalPosts);\n    }\n}\n\npublic class SocialMediaPlatform {\n    public static void main(String[] args) {\n        SocialMediaApp app = new SocialMediaApp(new PushNotificationSender());\n        app.createPost(\"Alice\", \"Hello, world!\");\n    }\n}"
    },
    {
        "file_name": "4.LogisticsSystem.java",
        "java_code": "public class DeliveryService {\n    void deliverPackage(String packageId);\n}\n\nclass DroneDelivery implements DeliveryService {\n    @Override\n    public void deliverPackage(String packageId) {\n        System.out.println(\"Delivering package via Drone: \" + packageId);\n    }\n}\n\nclass Logistics {\n    private DeliveryService deliveryService;\n    private static final TrackingSystem trackingSystem = TrackingSystem.getInstance();\n    private static int totalDeliveries = 0;\n\n    public Logistics(DeliveryService deliveryService) {\n        this.deliveryService = deliveryService;\n    }\n\n    public void scheduleDelivery(String packageId) {\n        deliveryService.deliverPackage(packageId);\n        trackingSystem.updateStatus(packageId, \"Out for delivery\");\n        totalDeliveries++;\n        System.out.println(\"Total Deliveries: \" + totalDeliveries);\n    }\n}\n\npublic class LogisticsSystem {\n    public static void main(String[] args) {\n        Logistics logistics = new Logistics(new DroneDelivery());\n        logistics.scheduleDelivery(\"PKG1001\");\n    }\n}"
    },
    {
        "file_name": "5.HealthcareSystem.java",
        "java_code": "public class MedicalRecordManager {\n    void updateRecord(String patientId, String record);\n}\n\nclass CloudMedicalRecordManager implements MedicalRecordManager {\n    @Override\n    public void updateRecord(String patientId, String record) {\n        System.out.println(\"Updating cloud medical record for: \" + patientId);\n    }\n}\n\nclass Hospital {\n    private MedicalRecordManager medicalRecordManager;\n    private static final BillingSystem billingSystem = BillingSystem.getInstance();\n    private static int totalPatients = 0;\n\n    public Hospital(MedicalRecordManager medicalRecordManager) {\n        this.medicalRecordManager = medicalRecordManager;\n    }\n\n    public void admitPatient(String patientId) {\n        medicalRecordManager.updateRecord(patientId, \"Patient admitted\");\n        billingSystem.generateInvoice(patientId);\n        totalPatients++;\n        System.out.println(\"Total Patients Admitted: \" + totalPatients);\n    }\n}\n\npublic class HealthcareSystem {\n    public static void main(String[] args) {\n        Hospital hospital = new Hospital(new CloudMedicalRecordManager());\n        hospital.admitPatient(\"PAT2023\");\n    }\n}"
    },
    {
        "file_name": "1.HotelManagement.java",
        "java_code": "public interface PaymentProcessor {\n    void processPayment(double amount);\n}\n\nclass CreditCardPayment implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n    }\n}\n\nclass HotelBooking {\n    private PaymentProcessor paymentProcessor;\n    private static final Logger logger = Logger.getInstance();\n    private static int totalBookings = 0;\n\n    public HotelBooking(PaymentProcessor paymentProcessor) {\n        this.paymentProcessor = paymentProcessor;\n    }\n\n    public void confirmBooking(double amount) {\n        paymentProcessor.processPayment(amount);\n        logger.log(\"Booking confirmed: $\" + amount);\n        totalBookings++;\n        System.out.println(\"Total Bookings: \" + totalBookings);\n    }\n}\n\npublic class HotelManagement {\n    public static void main(String[] args) {\n        HotelBooking booking = new HotelBooking(new CreditCardPayment());\n        booking.confirmBooking(500.0);\n    }\n}"
    },
    {
        "file_name": "2.EcommerceOrder.java",
        "java_code": "public interface ShippingService {\n    void shipOrder(String orderId);\n}\n\nclass ExpressShipping implements ShippingService {\n    @Override\n    public void shipOrder(String orderId) {\n        System.out.println(\"Express shipping for order: \" + orderId);\n    }\n}\n\nclass OrderProcessor {\n    private ShippingService shippingService;\n    private static final Inventory inventory = Inventory.getInstance();\n    private static int orderCount = 0;\n\n    public OrderProcessor(ShippingService shippingService) {\n        this.shippingService = shippingService;\n    }\n\n    public void processOrder(String orderId) {\n        shippingService.shipOrder(orderId);\n        inventory.updateStock(orderId);\n        orderCount++;\n        System.out.println(\"Total Orders Processed: \" + orderCount);\n    }\n}\n\npublic class EcommerceOrder {\n    public static void main(String[] args) {\n        OrderProcessor processor = new OrderProcessor(new ExpressShipping());\n        processor.processOrder(\"ORD123\");\n    }\n}"
    },
    {
        "file_name": "3.CarRentalService.java",
        "java_code": "public interface InsuranceProvider {\n    void provideInsurance(String vehicleId);\n}\n\nclass FullCoverageInsurance implements InsuranceProvider {\n    @Override\n    public void provideInsurance(String vehicleId) {\n        System.out.println(\"Full coverage insurance for vehicle: \" + vehicleId);\n    }\n}\n\nclass CarRental {\n    private InsuranceProvider insuranceProvider;\n    private static final MaintenanceService maintenance = MaintenanceService.getInstance();\n    private static int rentals = 0;\n\n    public CarRental(InsuranceProvider insuranceProvider) {\n        this.insuranceProvider = insuranceProvider;\n    }\n\n    public void rentCar(String vehicleId) {\n        insuranceProvider.provideInsurance(vehicleId);\n        maintenance.scheduleCheckup(vehicleId);\n        rentals++;\n        System.out.println(\"Total Rentals: \" + rentals);\n    }\n}\n\npublic class CarRentalService {\n    public static void main(String[] args) {\n        CarRental rental = new CarRental(new FullCoverageInsurance());\n        rental.rentCar(\"CAR2023\");\n    }\n}"
    },
    {
        "file_name": "4.FlightReservation.java",
        "java_code": "public interface FlightBookingService {\n    void bookFlight(String flightNumber);\n}\n\nclass InternationalBooking implements FlightBookingService {\n    @Override\n    public void bookFlight(String flightNumber) {\n        System.out.println(\"Booking international flight: \" + flightNumber);\n    }\n}\n\nclass Reservation {\n    private FlightBookingService flightBookingService;\n    private static final CustomerSupport support = CustomerSupport.getInstance();\n    private static int totalReservations = 0;\n\n    public Reservation(FlightBookingService flightBookingService) {\n        this.flightBookingService = flightBookingService;\n    }\n\n    public void confirmFlight(String flightNumber) {\n        flightBookingService.bookFlight(flightNumber);\n        support.sendConfirmation(flightNumber);\n        totalReservations++;\n        System.out.println(\"Total Reservations: \" + totalReservations);\n    }\n}\n\npublic class FlightReservation {\n    public static void main(String[] args) {\n        Reservation reservation = new Reservation(new InternationalBooking());\n        reservation.confirmFlight(\"FL1234\");\n    }\n}"
    },
    {
        "file_name": "5.LibraryManagement.java",
        "java_code": "public interface CatalogService {\n    void searchBook(String title);\n}\n\nclass DigitalCatalog implements CatalogService {\n    @Override\n    public void searchBook(String title) {\n        System.out.println(\"Searching in digital catalog: \" + title);\n    }\n}\n\nclass Library {\n    private CatalogService catalogService;\n    private static final Membership membership = Membership.getInstance();\n    private static int totalSearches = 0;\n\n    public Library(CatalogService catalogService) {\n        this.catalogService = catalogService;\n    }\n\n    public void findBook(String title) {\n        catalogService.searchBook(title);\n        membership.checkMembershipStatus(title);\n        totalSearches++;\n        System.out.println(\"Total Searches: \" + totalSearches);\n    }\n}\n\npublic class LibraryManagement {\n    public static void main(String[] args) {\n        Library library = new Library(new DigitalCatalog());\n        library.findBook(\"Design Patterns\");\n    }\n}"
    },
    {
        "file_name": "8.HighCBOOrderProcessing.java",
        "java_code": "public class HighCBOOrderProcessing {\n\n    // Static variable usage (Factor: Static Variable Usages)\n    private static final Logger LOGGER = Logger.getInstance();\n    \n    // Global variable reference (Factor: Global Variable References)\n    private static int orderCount = 0;\n    \n    // Dependency Injection via constructor (Factor: Constructor Injection)\n    private OrderService orderService;\n    private PaymentGateway paymentGateway;\n    \n    // Constructor Injection\n    public HighCBOOrderProcessing(OrderService orderService, PaymentGateway paymentGateway) {\n        this.orderService = orderService;\n        this.paymentGateway = paymentGateway;\n    }\n    \n    // Setter Injection (Factor: Setter Injection)\n    public void setPaymentGateway(PaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n    }\n    \n    // Direct Object Instantiations (Factor: Direct Object Instantiations)\n    public void processOrder(String orderId) {\n        OrderHelper helper = new OrderHelper();\n        helper.validateOrder(orderId);\n        \n        // Direct Instantiation of Thread\n        Thread orderThread = new Thread(() -> System.out.println(\"Processing order asynchronously...\"));\n        orderThread.start();\n        \n        // Using the injected dependencies\n        orderService.createOrder(orderId);\n        paymentGateway.processPayment(orderId);\n        \n        // Static Method Call (Factor: Static Method Calls)\n        String transactionId = PaymentUtil.generateTransactionId();\n        System.out.println(\"Transaction ID: \" + transactionId);\n        \n        // Static Variable Usage (Factor: Static Variable Usages)\n        LOGGER.log(\"Order processed: \" + orderId);\n        \n        // Using a global variable\n        orderCount++;\n        System.out.println(\"Total Orders Processed: \" + orderCount);\n    }\n    \n    public static void main(String[] args) {\n        HighCBOOrderProcessing processor = new HighCBOOrderProcessing(new OnlineOrderService(), new StripePaymentGateway());\n        processor.setPaymentGateway(new PayPalPaymentGateway());\n        processor.processOrder(\"ORD001\");\n    }\n}"
    },
    {
        "file_name": "9.HighCBOInventoryManagement.java",
        "java_code": "public class HighCBOInventoryManagement {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int inventoryUpdates = 0;\n    private InventoryService inventoryService;\n    private NotificationService notificationService;\n\n    public HighCBOInventoryManagement(InventoryService inventoryService, NotificationService notificationService) {\n        this.inventoryService = inventoryService;\n        this.notificationService = notificationService;\n    }\n\n    public void setNotificationService(NotificationService notificationService) {\n        this.notificationService = notificationService;\n    }\n\n    public void updateInventory(String productId) {\n        InventoryHelper helper = new InventoryHelper();\n        helper.checkStock(productId);\n        \n        Thread inventoryThread = new Thread(() -> System.out.println(\"Updating inventory asynchronously...\"));\n        inventoryThread.start();\n        \n        inventoryService.updateStock(productId);\n        notificationService.notifyUser(\"Inventory updated for product: \" + productId);\n        \n        String updateId = InventoryUtil.generateUpdateId();\n        System.out.println(\"Inventory Update ID: \" + updateId);\n        \n        LOGGER.log(\"Inventory updated for: \" + productId);\n        inventoryUpdates++;\n        System.out.println(\"Total Inventory Updates: \" + inventoryUpdates);\n    }\n\n    public static void main(String[] args) {\n        HighCBOInventoryManagement inventoryManager = new HighCBOInventoryManagement(new WarehouseInventoryService(), new EmailNotifier());\n        inventoryManager.setNotificationService(new SMSNotifier());\n        inventoryManager.updateInventory(\"PRD1001\");\n    }\n}"
    },
    {
        "file_name": "10.HighCBOHealthcareSystem.java",
        "java_code": "public class HighCBOHealthcareSystem {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int patientRecordsUpdated = 0;\n    private PatientRecordService recordService;\n    private BillingService billingService;\n\n    public HighCBOHealthcareSystem(PatientRecordService recordService, BillingService billingService) {\n        this.recordService = recordService;\n        this.billingService = billingService;\n    }\n\n    public void setBillingService(BillingService billingService) {\n        this.billingService = billingService;\n    }\n\n    public void updatePatientRecord(String patientId) {\n        RecordValidator validator = new RecordValidator();\n        validator.verifyPatient(patientId);\n        \n        Thread recordThread = new Thread(() -> System.out.println(\"Updating patient record asynchronously...\"));\n        recordThread.start();\n        \n        recordService.updateRecord(patientId);\n        billingService.processBill(patientId);\n        \n        String recordId = RecordUtil.generateRecordId();\n        System.out.println(\"Record Update ID: \" + recordId);\n        \n        LOGGER.log(\"Patient record updated: \" + patientId);\n        patientRecordsUpdated++;\n        System.out.println(\"Total Patient Records Updated: \" + patientRecordsUpdated);\n    }\n\n    public static void main(String[] args) {\n        HighCBOHealthcareSystem healthcareSystem = new HighCBOHealthcareSystem(new HospitalRecordService(), new InsuranceBillingService());\n        healthcareSystem.setBillingService(new DirectBillingService());\n        healthcareSystem.updatePatientRecord(\"PAT5678\");\n    }\n}"
    },
    {
        "file_name": "1.PaymentProcessor.java",
        "java_code": "class CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n    }\n}\n\nclass PayPalProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing PayPal payment of $\" + amount);\n    }\n}\n\npublic class PaymentSystem {\n    private PaymentProcessor processor;\n\n    public PaymentSystem(PaymentProcessor processor) {\n        this.processor = processor;\n    }\n\n    public void pay(double amount) {\n        processor.processPayment(amount);\n    }\n\n    public static void main(String[] args) {\n        PaymentSystem system = new PaymentSystem(new CreditCardProcessor());\n        system.pay(100.50);\n    }\n}"
    },
    {
        "file_name": "3.AnimalBehavior.java",
        "java_code": "class Dog implements Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof Woof!\");\n    }\n}\n\nclass Cat implements Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow Meow!\");\n    }\n}\n\npublic class AnimalSimulator {\n    public static void main(String[] args) {\n        Animal dog = new Dog();\n        Animal cat = new Cat();\n\n        dog.makeSound();\n        cat.makeSound();\n    }\n}"
    },
    {
        "file_name": "4.DatabaseOperations.java",
        "java_code": "interface DatabaseOperations {\n    void connect();\n    void disconnect();\n}\n\nclass MySQLDatabase implements DatabaseOperations {\n    @Override\n    public void connect() {\n        System.out.println(\"Connecting to MySQL database...\");\n    }\n    \n    @Override\n    public void disconnect() {\n        System.out.println(\"Disconnecting from MySQL database...\");\n    }\n}\n\nclass PostgreSQLDatabase implements DatabaseOperations {\n    @Override\n    public void connect() {\n        System.out.println(\"Connecting to PostgreSQL database...\");\n    }\n    \n    @Override\n    public void disconnect() {\n        System.out.println(\"Disconnecting from PostgreSQL database...\");\n    }\n}\n\npublic class DatabaseManager {\n    public static void main(String[] args) {\n        DatabaseOperations db = new MySQLDatabase();\n        db.connect();\n        db.disconnect();\n    }\n}"
    },
    {
        "file_name": "5.VehicleManagement.java",
        "java_code": "class Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car is starting...\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Car is stopping...\");\n    }\n}\n\nclass Bike implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Bike is starting...\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Bike is stopping...\");\n    }\n}\n\npublic class VehicleManager {\n    public static void main(String[] args) {\n        Vehicle car = new Car();\n        Vehicle bike = new Bike();\n\n        car.start();\n        car.stop();\n        bike.start();\n        bike.stop();\n    }\n}"
    },
    {
        "file_name": "11.HighCBOLoggingSystem.java",
        "java_code": "public class HighCBOLoggingSystem {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int logEntries = 0;\n    private LogService logService;\n    private NotificationService notificationService;\n\n    public HighCBOLoggingSystem(LogService logService, NotificationService notificationService) {\n        this.logService = logService;\n        this.notificationService = notificationService;\n    }\n\n    public void setNotificationService(NotificationService notificationService) {\n        this.notificationService = notificationService;\n    }\n\n    public void addLogEntry(String message) {\n        LogHelper helper = new LogHelper();\n        helper.validateLog(message);\n        \n        Thread logThread = new Thread(() -> System.out.println(\"Writing log asynchronously...\"));\n        logThread.start();\n        \n        logService.writeLog(message);\n        notificationService.notifyUser(\"New log entry added: \" + message);\n        \n        String logId = LogUtil.generateLogId();\n        System.out.println(\"Log Entry ID: \" + logId);\n        \n        LOGGER.log(\"Log written: \" + message);\n        logEntries++;\n        System.out.println(\"Total Log Entries: \" + logEntries);\n    }\n\n    public static void main(String[] args) {\n        HighCBOLoggingSystem loggingSystem = new HighCBOLoggingSystem(new FileLogService(), new EmailNotifier());\n        loggingSystem.setNotificationService(new SMSNotifier());\n        loggingSystem.addLogEntry(\"System started successfully.\");\n    }\n}"
    },
    {
        "file_name": "12.HighCBOMessagingSystem.java",
        "java_code": "public class HighCBOMessagingSystem {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int messagesSent = 0;\n    private MessagingService messagingService;\n    private SecurityService securityService;\n\n    public HighCBOMessagingSystem(MessagingService messagingService, SecurityService securityService) {\n        this.messagingService = messagingService;\n        this.securityService = securityService;\n    }\n\n    public void setSecurityService(SecurityService securityService) {\n        this.securityService = securityService;\n    }\n\n    public void sendMessage(String recipient, String message) {\n        MessageValidator validator = new MessageValidator();\n        validator.validateMessage(message);\n        \n        Thread messageThread = new Thread(() -> System.out.println(\"Sending message asynchronously...\"));\n        messageThread.start();\n        \n        messagingService.sendMessage(recipient, message);\n        securityService.encryptMessage(message);\n        \n        String messageId = MessageUtil.generateMessageId();\n        System.out.println(\"Message ID: \" + messageId);\n        \n        LOGGER.log(\"Message sent: \" + message);\n        messagesSent++;\n        System.out.println(\"Total Messages Sent: \" + messagesSent);\n    }\n\n    public static void main(String[] args) {\n        HighCBOMessagingSystem messagingSystem = new HighCBOMessagingSystem(new SMSService(), new EncryptionService());\n        messagingSystem.setSecurityService(new AdvancedEncryptionService());\n        messagingSystem.sendMessage(\"JohnDoe\", \"Hello, how are you?\");\n    }\n}"
    },
    {
        "file_name": "13.HighCBOPaymentProcessing.java",
        "java_code": "public class HighCBOPaymentProcessing {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int paymentsProcessed = 0;\n    private PaymentService paymentService;\n    private FraudDetectionService fraudDetectionService;\n\n    public HighCBOPaymentProcessing(PaymentService paymentService, FraudDetectionService fraudDetectionService) {\n        this.paymentService = paymentService;\n        this.fraudDetectionService = fraudDetectionService;\n    }\n\n    public void setFraudDetectionService(FraudDetectionService fraudDetectionService) {\n        this.fraudDetectionService = fraudDetectionService;\n    }\n\n    public void processPayment(String accountId, double amount) {\n        FraudChecker checker = new FraudChecker();\n        checker.verifyTransaction(accountId, amount);\n        \n        Thread paymentThread = new Thread(() -> System.out.println(\"Processing payment asynchronously...\"));\n        paymentThread.start();\n        \n        paymentService.processPayment(accountId, amount);\n        fraudDetectionService.analyzeTransaction(accountId, amount);\n        \n        String paymentId = PaymentUtil.generatePaymentId();\n        System.out.println(\"Payment ID: \" + paymentId);\n        \n        LOGGER.log(\"Payment processed: \" + accountId);\n        paymentsProcessed++;\n        System.out.println(\"Total Payments Processed: \" + paymentsProcessed);\n    }\n\n    public static void main(String[] args) {\n        HighCBOPaymentProcessing paymentProcessor = new HighCBOPaymentProcessing(new CreditCardPaymentService(), new AIAnalysisFraudService());\n        paymentProcessor.setFraudDetectionService(new SimpleFraudCheckService());\n        paymentProcessor.processPayment(\"ACC12345\", 250.75);\n    }\n}"
    },
    {
        "file_name": "14.HighCBODataProcessing.java",
        "java_code": "public class HighCBODataProcessing {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int dataEntriesProcessed = 0;\n    private DataProcessingService dataService;\n    private BackupService backupService;\n\n    public HighCBODataProcessing(DataProcessingService dataService, BackupService backupService) {\n        this.dataService = dataService;\n        this.backupService = backupService;\n    }\n\n    public void setBackupService(BackupService backupService) {\n        this.backupService = backupService;\n    }\n\n    public void processData(String dataEntry) {\n        DataValidator validator = new DataValidator();\n        validator.checkDataQuality(dataEntry);\n        \n        Thread dataThread = new Thread(() -> System.out.println(\"Processing data asynchronously...\"));\n        dataThread.start();\n        \n        dataService.processData(dataEntry);\n        backupService.createBackup(dataEntry);\n        \n        String entryId = DataUtil.generateEntryId();\n        System.out.println(\"Data Entry ID: \" + entryId);\n        \n        LOGGER.log(\"Data processed: \" + dataEntry);\n        dataEntriesProcessed++;\n        System.out.println(\"Total Data Entries Processed: \" + dataEntriesProcessed);\n    }\n\n    public static void main(String[] args) {\n        HighCBODataProcessing dataProcessor = new HighCBODataProcessing(new CloudDataProcessingService(), new DatabaseBackupService());\n        dataProcessor.setBackupService(new FileBackupService());\n        dataProcessor.processData(\"Sample Data Entry\");\n    }\n}"
    },
    {
        "file_name": "15.HighCBOIoTSystem.java",
        "java_code": "public class HighCBOIoTSystem {\n\n    private static final Logger LOGGER = Logger.getInstance();\n    private static int deviceMessagesProcessed = 0;\n    private DeviceCommunicationService communicationService;\n    private DataAnalyticsService analyticsService;\n\n    public HighCBOIoTSystem(DeviceCommunicationService communicationService, DataAnalyticsService analyticsService) {\n        this.communicationService = communicationService;\n        this.analyticsService = analyticsService;\n    }\n\n    public void setAnalyticsService(DataAnalyticsService analyticsService) {\n        this.analyticsService = analyticsService;\n    }\n\n    public void processIoTMessage(String deviceId, String message) {\n        IoTMessageValidator validator = new IoTMessageValidator();\n        validator.validateMessage(deviceId, message);\n        \n        Thread ioTThread = new Thread(() -> System.out.println(\"Processing IoT message asynchronously...\"));\n        ioTThread.start();\n        \n        communicationService.transmitMessage(deviceId, message);\n        analyticsService.analyzeData(deviceId, message);\n        \n        String messageId = IoTUtil.generateMessageId();\n        System.out.println(\"IoT Message ID: \" + messageId);\n        \n        LOGGER.log(\"IoT message processed: \" + deviceId);\n        deviceMessagesProcessed++;\n        System.out.println(\"Total IoT Messages Processed: \" + deviceMessagesProcessed);\n    }\n}"
    },
    {
        "file_name": "1.LowCBOUserProfile.java",
        "java_code": "public class LowCBOUserProfile {\n\n    private String username;\n    private int age;\n\n    public LowCBOUserProfile(String username, int age) {\n        this.username = username;\n        this.age = age;\n    }\n\n    public void displayProfile() {\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Age: \" + age);\n    }\n\n    public static void main(String[] args) {\n        LowCBOUserProfile user = new LowCBOUserProfile(\"JohnDoe\", 25);\n        user.displayProfile();\n    }\n}"
    },
    {
        "file_name": "2.LowCBOCalculator.java",
        "java_code": "public class LowCBOCalculator {\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public int subtract(int a, int b) {\n        return a - b;\n    }\n\n    public static void main(String[] args) {\n        LowCBOCalculator calculator = new LowCBOCalculator();\n        System.out.println(\"Sum: \" + calculator.add(5, 3));\n        System.out.println(\"Difference: \" + calculator.subtract(5, 3));\n    }\n}"
    },
    {
        "file_name": "3.LowCBOLogger.java",
        "java_code": "public class LowCBOLogger {\n\n    public void logMessage(String message) {\n        System.out.println(\"LOG: \" + message);\n    }\n\n    public static void main(String[] args) {\n        LowCBOLogger logger = new LowCBOLogger();\n        logger.logMessage(\"Application started.\");\n    }\n}"
    },
    {
        "file_name": "4.LowCBOCounter.java",
        "java_code": "public class LowCBOCounter {\n\n    private int count;\n\n    public LowCBOCounter() {\n        this.count = 0;\n    }\n\n    public void increment() {\n        count++;\n    }\n\n    public void displayCount() {\n        System.out.println(\"Current Count: \" + count);\n    }\n\n    public static void main(String[] args) {\n        LowCBOCounter counter = new LowCBOCounter();\n        counter.increment();\n        counter.displayCount();\n    }\n}"
    },
    {
        "file_name": "5.LowCBOMessagePrinter.java",
        "java_code": "public class LowCBOMessagePrinter {\n\n    public void printMessage(String message) {\n        System.out.println(\"Message: \" + message);\n    }\n\n    public static void main(String[] args) {\n        LowCBOMessagePrinter printer = new LowCBOMessagePrinter();\n        printer.printMessage(\"Hello, world!\");\n    }\n}"
    },
    {
        "file_name": "1.LowCBOProductService.java",
        "java_code": "public class LowCBOProductService {\n\n    private Product product;\n\n    // Constructor Injection (Factor: Constructor Injection)\n    public LowCBOProductService(Product product) {\n        this.product = product;\n    }\n\n    // Setter Injection (Factor: Setter Injection)\n    public void setProduct(Product product) {\n        this.product = product;\n    }\n\n    public void displayProduct() {\n        System.out.println(\"Product Name: \" + product.getName());\n    }\n\n    public static void main(String[] args) {\n        Product prod = new Product(\"Laptop\");\n        LowCBOProductService service = new LowCBOProductService(prod);\n        service.displayProduct();\n    }\n}\n\nclass Product {\n    private String name;\n    public Product(String name) { this.name = name; }\n    public String getName() { return name; }\n}"
    },
    {
        "file_name": "2.LowCBODataProcessor.java",
        "java_code": "public class LowCBODataProcessor {\n\n    private static final int MAX_SIZE = 100; // Static Variable Usage (Factor: Static Variable Usages)\n\n    public void processData(int data) {\n        // Direct Instantiation (Factor: Direct Object Instantiations)\n        DataValidator validator = new DataValidator();\n        if (validator.isValid(data)) {\n            System.out.println(\"Data processed: \" + data);\n        }\n    }\n\n    public static void printMaxSize() {\n        // Static Method Call (Factor: Static Method Calls)\n        System.out.println(\"Max Size: \" + MAX_SIZE);\n    }\n\n    public static void main(String[] args) {\n        LowCBODataProcessor processor = new LowCBODataProcessor();\n        processor.processData(50);\n        printMaxSize();\n    }\n}\n\nclass DataValidator {\n    public boolean isValid(int value) {\n        return value > 0;\n    }\n}"
    },
    {
        "file_name": "3.LowCBOLogger.java",
        "java_code": "public class LowCBOLogger {\n    \n    private String logLevel;\n    \n    public LowCBOLogger(String logLevel) {\n        this.logLevel = logLevel;\n    }\n    \n    public void log(String message) {\n        System.out.println(logLevel + \": \" + message);\n    }\n    \n    public static void main(String[] args) {\n        LowCBOLogger logger = new LowCBOLogger(\"INFO\");\n        logger.log(\"Application started.\");\n    }\n}"
    },
    {
        "file_name": "4.LowCBOCounter.java",
        "java_code": "public class LowCBOCounter {\n\n    private int count;\n    \n    public LowCBOCounter() {\n        this.count = 0;\n    }\n    \n    public void increment() {\n        count++;\n    }\n    \n    public void displayCount() {\n        System.out.println(\"Current Count: \" + count);\n    }\n    \n    public static void main(String[] args) {\n        LowCBOCounter counter = new LowCBOCounter();\n        counter.increment();\n        counter.displayCount();\n    }\n}"
    },
    {
        "file_name": "5.LowCBOUserAuth.java",
        "java_code": "interface AuthService {\n    boolean authenticate(String username, String password);\n}\n\npublic class LowCBOUserAuth implements AuthService {\n\n    @Override\n    public boolean authenticate(String username, String password) {\n        return username.equals(\"admin\") && password.equals(\"1234\");\n    }\n\n    public static void main(String[] args) {\n        LowCBOUserAuth auth = new LowCBOUserAuth();\n        System.out.println(\"Authentication success: \" + auth.authenticate(\"admin\", \"1234\"));\n    }\n}"
    },
    {
        "file_name": "AddonGroupServiceImpl.java",
        "java_code": "public class AddonGroupServiceImpl implements AddonGroupService {\r\n    private final AddonGroupRepository addonGroupRepository;\r\n    private final AddonRepository addonRepository;\r\n    private final ModelMapper mapper;\r\n\r\n    public AddonGroupServiceImpl(AddonGroupRepository addonGroupRepository, AddonRepository addonRepository, ModelMapper mapper) {\r\n        this.addonGroupRepository = addonGroupRepository;\r\n        this.addonRepository = addonRepository;\r\n        this.mapper = mapper;\r\n    }\r\n\r\n    public AddonGroupResponseDTO createOrUpdateAddonGroup(AddonGroupRequestDTO addonGroupRequestDTO, Long addonGroupId)throws DuplicateRecordException, RecordNotFoundException {\r\n\r\n        log.info(\"AddonGroupServiceImpl::createOrUpdateAddonGroup\");\r\n        AddonGroup addonGroup;\r\n\r\n        boolean isExistsAddonGroup = addonGroupRepository.existsByNameIgnoreCase(addonGroupRequestDTO.getName());\r\n        if (addonGroupId != null) {\r\n            // Check if the Addon Group exists\r\n            addonGroup = addonGroupRepository.findById(addonGroupId)\r\n                    .orElseThrow(() -> new RecordNotFoundException(\"Addon Group with ID \" + addonGroupId + \" not found\"));\r\n\r\n            // Check if the new addon group name already exists(excluding the current addon group)\r\n            if (isExistsAddonGroup && !addonGroup.getName().equalsIgnoreCase(addonGroupRequestDTO.getName())) {\r\n                throw new DuplicateRecordException(\"Addon group name already exists\");\r\n            }\r\n\r\n            mapper.map(addonGroupRequestDTO, addonGroup);\r\n        } else {\r\n            if (isExistsAddonGroup) {\r\n                throw new DuplicateRecordException(\"Addon group name already exists\");\r\n            }\r\n\r\n            addonGroup = mapper.map(addonGroupRequestDTO, AddonGroup.class);\r\n        }\r\n\r\n        // Process list of addons\r\n        List<AddonAddonGroupRelationRequestDTO> addonAddonGroupRelationRequestDTOList = addonGroupRequestDTO.getListOfAddons();\r\n\r\n        // Utility method - Check for duplicate ids in listOfAddons request\r\n        ValidationUtils.checkForDuplicates(addonAddonGroupRelationRequestDTOList, \"Duplicate addons found in the request\");\r\n\r\n        // Get Addon-AddonGroup relations and save\r\n        List<AddonAddonGroupRelation> addonAddonGroupRelationsToSave = getAddonAddonGroupRelationEntityList(\r\n                addonAddonGroupRelationRequestDTOList,\r\n                addonGroup\r\n        );\r\n        // Remove existing relations and add new AddonAddonGroupRelations\r\n        addonGroup.getAddons().clear();\r\n        addonGroup.getAddons().addAll(addonAddonGroupRelationsToSave);\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        AddonGroup savedAddonGroup = addonGroupRepository.save(addonGroup);\r\n        watch.stop();\r\n        log.info(\"AddonGroupServiceImpl::createOrUpdateAddonGroup -> Addon Group associations saved with ID: {}, Query execution time: {}\",\r\n                savedAddonGroup.getAddonGroupId(),\r\n                watch.getTotalTimeSeconds()\r\n        );\r\n        return mapper.map(savedAddonGroup, AddonGroupResponseDTO.class);\r\n    }\r\n}"
    },
    {
        "file_name": "ProductServiceImpl.java",
        "java_code": "package com.icieos.pos.restaurant.service.product.impl;\r\n\r\nimport com.icieos.pos.restaurant.dto.ResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.addongroup.SaveAddonGroupResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.category.SaveCategoryResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.DeleteByIdsRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.SetAvailabilityStatusRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.product.*;\r\nimport com.icieos.pos.restaurant.dto.product.tag.GetTagDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variationrelation.GetVariationRelationResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variationrelation.SaveVariationRelationRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variationrelation.SavedVariationRelationResponseDTO;\r\nimport com.icieos.pos.restaurant.entity.enums.DayOfWeek;\r\nimport com.icieos.pos.restaurant.entity.enums.DietaryType;\r\nimport com.icieos.pos.restaurant.entity.enums.OrderType;\r\nimport com.icieos.pos.restaurant.entity.enums.Platform;\r\nimport com.icieos.pos.restaurant.entity.product.*;\r\nimport com.icieos.pos.restaurant.repository.product.*;\r\nimport com.icieos.pos.restaurant.service.exception.BadRequestException;\r\nimport com.icieos.pos.restaurant.service.product.ProductService;\r\nimport com.icieos.pos.restaurant.service.exception.DuplicateRecordException;\r\nimport com.icieos.pos.restaurant.util.CommonUtils;\r\nimport com.icieos.pos.restaurant.service.exception.RecordNotFoundException;\r\nimport com.icieos.pos.restaurant.util.ValidationUtils;\r\nimport com.icieos.pos.restaurant.util.excel.exportdata.ExportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportTemplates;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.ss.usermodel.Cell;\r\nimport org.modelmapper.ModelMapper;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.util.StopWatch;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\n@Slf4j\r\npublic class ProductServiceImpl implements ProductService {\r\n    private final ProductRepository productRepository;\r\n\r\n    private final CategoryRepository categoryRepository;\r\n\r\n    private final TagRepository tagRepository;\r\n\r\n    private final AddonGroupRepository addonGroupRepository;\r\n\r\n    private final VariationRepository variationRepository;\r\n\r\n    private final ModelMapper mapper;\r\n\r\n    public ProductServiceImpl(ProductRepository productRepository, CategoryRepository categoryRepository,\r\n                              TagRepository tagRepository, AddonGroupRepository addonGroupRepository,\r\n                              VariationRepository variationRepository, ModelMapper mapper) {\r\n        this.productRepository = productRepository;\r\n        this.categoryRepository = categoryRepository;\r\n        this.tagRepository = tagRepository;\r\n        this.addonGroupRepository = addonGroupRepository;\r\n        this.variationRepository = variationRepository;\r\n        this.mapper = mapper;\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackOn = {DuplicateRecordException.class, RecordNotFoundException.class, BadRequestException.class})\r\n    public SaveProductResponseDTO createOrUpdateProduct(SaveProductRequestDTO saveProductRequestDTO, Long productId)\r\n            throws RecordNotFoundException, DuplicateRecordException, BadRequestException {\r\n\r\n        log.info(\"ProductServiceImpl::createOrUpdateProduct\");\r\n        Product product;\r\n\r\n        boolean isExistsProduct = productRepository.existsByNameIgnoreCaseAndIsDeletedFalse(saveProductRequestDTO.getProductName());\r\n        if (productId != null) {\r\n            // Check if the product exists and Product Is not deleted\r\n            product = productRepository.findByIdAndIsDeletedFalse(productId);\r\n            if (product == null) {\r\n                throw new RecordNotFoundException(\"Product not found\");\r\n            }\r\n\r\n            // Check if the new product name already exists and Product Is not deleted (excluding the current product)\r\n            if (isExistsProduct && !product.getName().equals(saveProductRequestDTO.getProductName())) {\r\n                throw new DuplicateRecordException(\"Product name already exists\");\r\n            }\r\n\r\n            mapper.map(saveProductRequestDTO, product);\r\n        } else {\r\n            if (isExistsProduct) {\r\n                throw new DuplicateRecordException(\"Product name already exists\");\r\n            }\r\n\r\n            product = mapper.map(saveProductRequestDTO, Product.class);\r\n        }\r\n\r\n        // Validate and Create Enum Strings\r\n        String dietaryTypes = DietaryType.processDietaryTypesString(saveProductRequestDTO.getDietary());\r\n        String orderTypes = OrderType.processOrderTypesString(saveProductRequestDTO.getOrderType());\r\n        String platforms = Platform.processPlatformString(saveProductRequestDTO.getExposingPlatforms());\r\n        String daysOfWeek = DayOfWeek.processAvailableDaysString(saveProductRequestDTO.getAvailableDays());\r\n\r\n        // Validate product Category\r\n        Category category = categoryRepository.findByCategoryId(saveProductRequestDTO.getCategoryGroupId());\r\n        if (category == null) {\r\n            throw new RecordNotFoundException(\"Product category group not found\");\r\n        }\r\n\r\n        // Check for duplicate product tags\r\n        List<Long> tagIds = saveProductRequestDTO.getTagIds();\r\n        ValidationUtils.checkForDuplicates(tagIds, \"Duplicate tag IDs found\");\r\n\r\n        // Check the existence of tags\r\n        Set<Tag> tagSet = new LinkedHashSet<>(tagRepository.findAllById(tagIds));\r\n\r\n        if (tagSet.size() != tagIds.size()) {\r\n            throw new RecordNotFoundException(\"Some tags were not found\");\r\n        }\r\n\r\n        product.setName(saveProductRequestDTO.getProductName());\r\n        product.setDietary(dietaryTypes);\r\n        product.setAvailableDays(daysOfWeek);\r\n        product.setExposingPlatforms(platforms);\r\n        product.setOrderType(orderTypes);\r\n        product.setCategory(category);\r\n        product.setTags(tagSet);\r\n\r\n        if (!saveProductRequestDTO.getIsVariableProduct()) {\r\n            log.info(\"ProductServiceImpl::createOrUpdateProduct ->Updating non-variable product\");\r\n            return saveOrUpdateNonVariableProduct(saveProductRequestDTO, product, productId != null);\r\n\r\n        } else {\r\n            log.info(\"ProductServiceImpl::createOrUpdateProduct ->Updating variable product\");\r\n            return saveOrUpdateVariableProduct(saveProductRequestDTO, product);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO updateFavouriteStatusByIds(SetProductFavoriteStatusRequestDTO setProductFavoriteStatusRequestDTO) throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"ProductServiceImpl::updateFavouriteStatusByIds\");\r\n\r\n        List<Long> productsIdList = setProductFavoriteStatusRequestDTO.getProducts();\r\n        Boolean favoriteStatus = setProductFavoriteStatusRequestDTO.getFavoriteStatus();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(productsIdList, \"Duplicate Product IDs in the request\");\r\n\r\n        // Find all products by IDs that are not marked as deleted\r\n        List<Product> productsToUpdate = productRepository.findAllByIdsAndIsDeletedFalse(productsIdList);\r\n\r\n        // Check if all requested products exist\r\n        if (productsToUpdate.size() != productsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some products were not found\");\r\n        }\r\n        // Filter only those products where the favourite status differs\r\n        List<Product> filteredProductsToUpdate = productsToUpdate.stream()\r\n                .filter(product -> !favoriteStatus.equals(product.getAvailabilityStatus()))\r\n                .peek(product -> {\r\n                    product.setSetAsFavorite(favoriteStatus);\r\n                    log.info(\"ProductServiceImpl::updateFavouriteStatusByIds -> Product with ID {} is marked as : {}\", product.getProductId(), favoriteStatus);\r\n                })\r\n                .collect(Collectors.toList());\r\n\r\n        // Save only the filtered product categories\r\n        if (!filteredProductsToUpdate.isEmpty()) {\r\n            StopWatch watch = new StopWatch();\r\n            watch.start();\r\n            List<Product> updatedProductList = productRepository.saveAll(filteredProductsToUpdate);\r\n            watch.stop();\r\n\r\n            log.info(\"ProductServiceImpl::updateFavouriteStatusByIds -> Query execution time: {}, Total records updated: {}\", watch.getTotalTimeSeconds(), updatedProductList.size());\r\n        } else {\r\n            log.info(\"ProductServiceImpl::updateFavouriteStatusByIds -> No product  had a change in availability status.\");\r\n        }\r\n\r\n        return new ResponseDTO(\"Favorite status updated successfully for products.\");\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO updateAvailabilityStatusByIds(SetAvailabilityStatusRequestDTO setAvailabilityStatusRequestDTO) throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds\");\r\n\r\n        List<Long> productsIdList = setAvailabilityStatusRequestDTO.getIdList();\r\n        Boolean availabilityStatus = setAvailabilityStatusRequestDTO.getAvailabilityStatus();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(productsIdList, \"Duplicate product IDs in the request\");\r\n\r\n        // Find all products by IDs that are not marked as deleted\r\n        List<Product> productsToUpdate = productRepository.findAllByIdsAndIsDeletedFalse(productsIdList);\r\n\r\n        // Check if all requested products exist\r\n        if (productsToUpdate.size() != productsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some products were not found\");\r\n        }\r\n        // Filter only those product  where the availability status differs\r\n        List<Product> filteredProductsToUpdate = productsToUpdate.stream()\r\n                .filter(product -> !availabilityStatus.equals(product.getAvailabilityStatus()))\r\n                .peek(product -> {\r\n                    product.setAvailabilityStatus(availabilityStatus);\r\n                    log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds -> Product with ID {} is marked as : {}\", product.getProductId(), availabilityStatus);\r\n                })\r\n                .collect(Collectors.toList());\r\n\r\n        // Save only the filtered products\r\n        if (!filteredProductsToUpdate.isEmpty()) {\r\n            StopWatch watch = new StopWatch();\r\n            watch.start();\r\n            List<Product> updatedProductList = productRepository.saveAll(filteredProductsToUpdate);\r\n            watch.stop();\r\n\r\n            log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds -> Query execution time: {}, Total records updated: {}\", watch.getTotalTimeSeconds(), updatedProductList.size());\r\n        } else {\r\n            log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds -> No products had a change in availability status.\");\r\n        }\r\n\r\n        return new ResponseDTO(\"Availability status updated successfully for products.\");\r\n    }\r\n\r\n    @Override\r\n    public GetProductResponseDTO findProductById(Long id) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::findProductById\");\r\n\r\n        // Retrieve the product by its ID and ensure it is not deleted\r\n        Product product = productRepository.findByIdAndIsDeletedFalse(id);\r\n        if (product == null) {\r\n            throw new RecordNotFoundException(\"Product not found\");\r\n        }\r\n\r\n        // Map the product entity to GetProductResponseDTO\r\n        GetProductResponseDTO getProductResponseDTO = mapper.map(product, GetProductResponseDTO.class);\r\n        getProductResponseDTO.setId(product.getProductId());\r\n        getProductResponseDTO.setProductName(product.getName());\r\n\r\n        // Set Category Group in response\r\n        SaveCategoryResponseDTO saveCategoryResponseDTO = new SaveCategoryResponseDTO();\r\n        saveCategoryResponseDTO.setId(product.getCategory().getCategoryId());\r\n        saveCategoryResponseDTO.setName(product.getCategory().getName());\r\n\r\n        getProductResponseDTO.setCategoryGroup(saveCategoryResponseDTO);\r\n\r\n        // Set Product Tags In Response\r\n        Set<Tag> existingTags = product.getTags();\r\n        if (existingTags != null) {\r\n            List<GetTagDTO> getTagDTOList = existingTags.stream()\r\n                    .map(tag -> {\r\n                        GetTagDTO getTagDTO = new GetTagDTO();\r\n                        getTagDTO.setId(tag.getTagId());\r\n                        getTagDTO.setName(tag.getName());\r\n                        return getTagDTO;\r\n                    })\r\n                    .collect(Collectors.toList());\r\n\r\n            getProductResponseDTO.setTags(getTagDTOList);\r\n        } else {\r\n            getProductResponseDTO.setTags(Collections.emptyList());\r\n        }\r\n\r\n        // Check if the product is variable\r\n        if (product.getIsVariableProduct()) {\r\n            log.info(\"ProductServiceImpl::findProductById -> Get Product Variation Relations for Product Id : {} \", id);\r\n\r\n            //Make the AddonGroup Field Null(otherwise Empty)\r\n            getProductResponseDTO.setAddonGroups(null);\r\n\r\n            // Retrieve Product variations\r\n            Set<VariationRelation> variationRelations = product.getVariationRelations();\r\n            List<GetVariationRelationResponseDTO> existingVariationRelationResponseDTOList = variationRelations.stream()\r\n                    .map(productVariationRelation -> {\r\n\r\n                        // Map AddonGroup entities to SavedProductProductAddonGroupResponseDTO\r\n                        List<SaveAddonGroupResponseDTO> saveAddonGroupResponseDTOList = productVariationRelation.getAddonGroups().stream()\r\n                                .map(productAddonGroup -> SaveAddonGroupResponseDTO.builder()\r\n                                        .id(productAddonGroup.getAddonGroupId())\r\n                                        .name(productAddonGroup.getName())\r\n                                        .build())\r\n                                .collect(Collectors.toList());\r\n\r\n                        // Build and return GetVariationRelationResponseDTO\r\n                        return GetVariationRelationResponseDTO.builder()\r\n                                .id(productVariationRelation.getVariation().getVariationId())\r\n                                .itemBasePrice(productVariationRelation.getItemBasePrice())\r\n                                .profitMargin(productVariationRelation.getProfitMargin())\r\n                                .containerCharges(productVariationRelation.getContainerCharges())\r\n                                .sapCode(productVariationRelation.getSapCode())\r\n                                .serves(productVariationRelation.getServes())\r\n                                .weightOrVolume(productVariationRelation.getWeightOrVolume())\r\n                                .addonGroups(saveAddonGroupResponseDTOList)\r\n                                .build();\r\n                    })\r\n                    .toList();\r\n\r\n            // Set variations in the response DTO\r\n            getProductResponseDTO.setVariations(existingVariationRelationResponseDTOList);\r\n        } else {\r\n            // Existing Product Addon Groups\r\n            Set<AddonGroup> existingAddonGroups = product.getAddonGroups();\r\n\r\n            // Map Product Addon Groups to SaveProductAddonGroupResponseDTO\r\n            List<SaveAddonGroupResponseDTO> savedProductAddonGroupResponseDTOList =\r\n                    existingAddonGroups.stream()\r\n                            .map(addonGroup -> {\r\n                                SaveAddonGroupResponseDTO saveAddonGroupResponseDTO = new SaveAddonGroupResponseDTO();\r\n                                saveAddonGroupResponseDTO.setId(addonGroup.getAddonGroupId());\r\n                                saveAddonGroupResponseDTO.setName(addonGroup.getName());\r\n                                return saveAddonGroupResponseDTO;\r\n                            })\r\n                            .collect(Collectors.toList());\r\n            getProductResponseDTO.setAddonGroups(savedProductAddonGroupResponseDTOList);\r\n        }\r\n\r\n        return getProductResponseDTO;\r\n    }\r\n\r\n    @Override\r\n    public ProductResponseDTO findAllProducts(ProductQueryRequestDTO productQueryRequestDTO) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::findAllProducts\");\r\n\r\n        return getProductsResponse(\r\n                productQueryRequestDTO,\r\n                true\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public ProductsByCategoryResponseDTO findProductsByCategoryId(Long id) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::findProductsByCategoryId\");\r\n\r\n        Category category = categoryRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Category Not Found\"));\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n\r\n        List<Product> directProducts = productRepository.findByCategory(category);\r\n        List<Product> productList = new ArrayList<>(directProducts);\r\n\r\n        if (category.getCategoryGroup() == null) {\r\n            List<Category> subcategories = categoryRepository.findByCategoryGroup(category);\r\n            for (Category subcategory : subcategories) {\r\n                productList.addAll(productRepository.findByCategory(subcategory));\r\n            }\r\n        }\r\n\r\n        List<ProductDTO> productDTOList = productList.stream()\r\n                .map(product -> mapper.map(product, ProductDTO.class))\r\n                .collect(Collectors.toList());\r\n\r\n        ProductsByCategoryResponseDTO productsByCategoryResponseDTO = new ProductsByCategoryResponseDTO();\r\n        productsByCategoryResponseDTO.setProducts(productDTOList);\r\n        productsByCategoryResponseDTO.setTotalRecords(productList.size());\r\n        productsByCategoryResponseDTO.setCategoryId(category.getCategoryId());\r\n        productsByCategoryResponseDTO.setCategoryName(category.getName());\r\n\r\n        log.info(\r\n                \"ProductServiceImpl::findProductsByCategoryId -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                productsByCategoryResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return productsByCategoryResponseDTO;\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteProductById(Long id) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::deleteProductById\");\r\n\r\n        // Retrieve the product by its ID and ensure it is not deleted\r\n        Product product = productRepository.findByIdAndIsDeletedFalse(id);\r\n        if (product == null) {\r\n            throw new RecordNotFoundException(\"Product not found\");\r\n        }\r\n\r\n        // Mark the product as deleted\r\n        product.setIsDeleted(true);\r\n        productRepository.save(product);\r\n\r\n        return new ResponseDTO(String.format(\"Product with ID %d deleted successfully\", id));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteProductsByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO) throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"ProductServiceImpl::deleteProductsByIds\");\r\n\r\n        List<Long> productsIdList = deleteByIdsRequestDTO.getIdList();\r\n        // Check for Duplicate Ids in the request\r\n        ValidationUtils.checkForDuplicates(productsIdList, \"Duplicate product Ids in the request\");\r\n\r\n        // Find all products by IDs\r\n        List<Product> productsToDelete = productRepository.findAllByIdsAndIsDeletedFalse(productsIdList);\r\n\r\n        // Check whether the request ids are exists\r\n        if (productsToDelete.size() != productsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some products were not found\");\r\n        }\r\n\r\n        // No need filter\r\n        productsToDelete.stream()\r\n                .filter(product -> !Boolean.TRUE.equals(product.getIsDeleted()))\r\n                .forEach(product -> {\r\n                    product.setIsDeleted(true);\r\n                });\r\n\r\n        // Save changes\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<Product> deletedProductList = productRepository.saveAll(productsToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ProductServiceImpl::deleteProductsByIds -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                deletedProductList.size()\r\n        );\r\n\r\n        return new ResponseDTO(\"Products successfully deleted\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"ProductServiceImpl::generateImportTemplate\");\r\n\r\n        return new InputStreamResource(ImportTemplates.generateProductImportTemplate());\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportProducts(ProductQueryRequestDTO productQueryRequestDTO) throws IOException, RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::exportProducts\");\r\n\r\n        ProductResponseDTO productResponseDTO = getProductsResponse(productQueryRequestDTO, productQueryRequestDTO.getIncludeLimit());\r\n        return new InputStreamResource(ExportData.exportProducts(productResponseDTO.getProducts()));\r\n\r\n\r\n    }\r\n\r\n    //Custom Method For Saving,Updating and Creating Response for Non-Variable Products\r\n    private SaveProductResponseDTO saveOrUpdateNonVariableProduct(SaveProductRequestDTO saveProductRequestDTO, Product product, Boolean isUpdate) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::saveOrUpdateNonVariableProduct\");\r\n\r\n        // When Update from variable-> non-variable, need to remove all the association with variation relations.\r\n        // It will remove all the product - variation associations and variation - addon group associations.\r\n        if (isUpdate) {\r\n            product.getVariationRelations().clear();\r\n        }\r\n\r\n        // Validate Addon Groups existence\r\n        List<Long> addonGroupIds = saveProductRequestDTO.getAddonGroupIds();\r\n        //Utility method for checking Duplicates\r\n        ValidationUtils.checkForDuplicates(addonGroupIds, \"Duplicate addon group IDs found\");\r\n\r\n        // Check the existence of all the addon groups\r\n        Set<AddonGroup> existingAddonGroups = new HashSet<>(addonGroupRepository.findAllById(addonGroupIds));\r\n        if (existingAddonGroups.size() != addonGroupIds.size()) {\r\n            throw new RecordNotFoundException(\"Some addon groups were not found\");\r\n        }\r\n\r\n\r\n        product.setAddonGroups(existingAddonGroups);\r\n\r\n        product.setIsVariableProduct(false);\r\n        product.setWeightOrVolume(saveProductRequestDTO.getWeightOrVolume());\r\n        product.setContainerCharges(saveProductRequestDTO.getContainerCharges());\r\n        product.setItemBasePrice(saveProductRequestDTO.getItemBasePrice());\r\n        product.setProfitMargin(saveProductRequestDTO.getProfitMargin());\r\n        product.setSapCode(saveProductRequestDTO.getSapCode());\r\n        product.setServes(saveProductRequestDTO.getServes());\r\n\r\n        // Save Non-variable Product\r\n        // Note: If we are updating a product, we don't need to remove previous associations (including many-to-many with no extra attributes).\r\n        //       Since we are updating the whole product, it will take care of associations as well.\r\n        Product savedOrUpdatedProduct = productRepository.save(product);\r\n        log.info(\"ProductServiceImpl::saveOrUpdateNonVariableProduct -> Product Saved/Updated with Product Id : {}\", savedOrUpdatedProduct.getProductId());\r\n\r\n        // Map to Response DTO\r\n        SaveProductResponseDTO saveProductResponseDTO = mapper.map(savedOrUpdatedProduct, SaveProductResponseDTO.class);\r\n        saveProductResponseDTO.setId(savedOrUpdatedProduct.getProductId());\r\n        saveProductResponseDTO.setProductName(savedOrUpdatedProduct.getName());\r\n\r\n        // Set Category Group in response\r\n        SaveCategoryResponseDTO saveCategoryResponseDTO = new SaveCategoryResponseDTO();\r\n        saveCategoryResponseDTO.setId(savedOrUpdatedProduct.getCategory().getCategoryId());\r\n        saveCategoryResponseDTO.setName(savedOrUpdatedProduct.getCategory().getName());\r\n        saveProductResponseDTO.setCategoryGroup(saveCategoryResponseDTO);\r\n\r\n        // Map Product Addon Groups to Response DTO\r\n        // List of saved AddonGroups from savedOrUpdatedProduct\r\n        Set<AddonGroup> savedAddonGroups = savedOrUpdatedProduct.getAddonGroups();\r\n\r\n        List<SaveAddonGroupResponseDTO> savedProductAddonGroupResponseDTOList =\r\n                savedAddonGroups.stream()\r\n                        .map(addonGroup -> {\r\n                            SaveAddonGroupResponseDTO saveAddonGroupResponseDTO = new SaveAddonGroupResponseDTO();\r\n                            saveAddonGroupResponseDTO.setId(addonGroup.getAddonGroupId());\r\n                            saveAddonGroupResponseDTO.setName(addonGroup.getName());\r\n                            return saveAddonGroupResponseDTO;\r\n                        })\r\n                        .collect(Collectors.toList());\r\n        saveProductResponseDTO.setAddonGroups(savedProductAddonGroupResponseDTOList);\r\n\r\n        return saveProductResponseDTO;\r\n    }\r\n\r\n    //Custom Method For Saving,Updating and Creating Response for Non-Variable Products\r\n    private SaveProductResponseDTO saveOrUpdateVariableProduct(SaveProductRequestDTO saveProductRequestDTO, Product product) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::saveOrUpdateVariableProduct\");\r\n\r\n        product.setIsVariableProduct(true);\r\n        product.setWeightOrVolume(null);\r\n        product.setContainerCharges(null);\r\n        product.setItemBasePrice(null);\r\n        product.setProfitMargin(null);\r\n        product.setSapCode(null);\r\n        product.setServes(null);\r\n        product.setAddonGroups(null);\r\n\r\n        // Collect all variation IDs from the request\r\n        List<Long> requestVariationIdList = saveProductRequestDTO.getVariations().stream()\r\n                .map(SaveVariationRelationRequestDTO::getId)\r\n                .toList();\r\n\r\n        // Utility method for duplicate variation IDs\r\n        ValidationUtils.checkForDuplicates(requestVariationIdList, \"Duplicate variation IDs found\");\r\n\r\n        // Fetch all required ProductVariations and validate existence\r\n        Map<Long, Variation> productVariationMap = variationRepository.findAllById(requestVariationIdList).stream()\r\n                .collect(Collectors.toMap(Variation::getVariationId, productVariation -> productVariation));\r\n\r\n        if (productVariationMap.size() != requestVariationIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some product variation IDs were not found\");\r\n        }\r\n\r\n        // Check for variations with duplicate addon group IDs; throw exception if any are found\r\n        long duplicateCount = saveProductRequestDTO.getVariations().stream()\r\n                .filter(variation -> {\r\n                    List<Long> addonGroupIds = variation.getAddonGroupIds();\r\n                    // Use helper method here\r\n                    return addonGroupIds.size() != new HashSet<>(addonGroupIds).size();\r\n                })\r\n                .count();\r\n\r\n        if (duplicateCount > 0) {\r\n            throw new DuplicateRecordException(\"One or more product variations has duplicate addon group IDs\");\r\n        }\r\n\r\n        // Collect all addon group IDs from the variations in the saveProductRequestDTO\r\n        List<Long> allAddonGroupIdsFromVariations = saveProductRequestDTO.getVariations().stream()\r\n                .flatMap(variation -> variation.getAddonGroupIds().stream())\r\n                .toList();\r\n\r\n        // Create a set of unique addon group IDs for validation\r\n        Set<Long> addonGroupIdSet = new HashSet<>(allAddonGroupIdsFromVariations);\r\n\r\n        // Fetch all required ProductAddonGroups and map them by their ID\r\n        Map<Long, AddonGroup> productAddonGroupMap = addonGroupRepository.findAllById(addonGroupIdSet).stream()\r\n                .collect(Collectors.toMap(AddonGroup::getAddonGroupId, productAddonGroup -> productAddonGroup));\r\n\r\n        // Check if all addon groups are found; throw exception if any are missing\r\n        if (productAddonGroupMap.size() != addonGroupIdSet.size()) {\r\n            throw new RecordNotFoundException(\"Some addon groups were not found\");\r\n        }\r\n\r\n        // Create a list of VariationRelation for creating\r\n        Set<VariationRelation> variationRelations = saveProductRequestDTO.getVariations().stream()\r\n                .map(saveVariationRelationRequestDTO -> {\r\n                    Long variationId = saveVariationRelationRequestDTO.getId();\r\n                    Variation variation = productVariationMap.get(variationId);\r\n\r\n                    // Map addon group IDs to AddonGroup objects\r\n                    Set<AddonGroup> addonGroups = saveVariationRelationRequestDTO.getAddonGroupIds().stream()\r\n                            .map(productAddonGroupMap::get)\r\n                            .collect(Collectors.toSet());\r\n\r\n                    // Create a new VariationRelation and set its properties\r\n                    VariationRelation variationRelation = new VariationRelation();\r\n                    variationRelation.setProduct(product);\r\n                    variationRelation.setVariation(variation);\r\n\r\n                    // Update the variationRelation with new details\r\n                    variationRelation.setContainerCharges(saveVariationRelationRequestDTO.getContainerCharges());\r\n                    variationRelation.setProfitMargin(saveVariationRelationRequestDTO.getProfitMargin());\r\n                    variationRelation.setItemBasePrice(saveVariationRelationRequestDTO.getItemBasePrice());\r\n                    variationRelation.setWeightOrVolume(saveVariationRelationRequestDTO.getWeightOrVolume());\r\n                    variationRelation.setServes(saveVariationRelationRequestDTO.getServes());\r\n                    variationRelation.setSapCode(saveVariationRelationRequestDTO.getSapCode());\r\n                    variationRelation.setAddonGroups(addonGroups);\r\n\r\n                    return variationRelation;\r\n                })\r\n                .collect(Collectors.toSet());\r\n\r\n        // Clear Existing ProductVariationRelations and Add new ProductVariationRelations\r\n        // All the (addon group - product variation relation) associations will be removed and added again.\r\n        product.getVariationRelations().clear();\r\n        product.getVariationRelations().addAll(variationRelations);\r\n\r\n        // Save/Update The Product\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        Product savedOrUpdatedProduct = productRepository.save(product);\r\n        watch.stop();\r\n        log.info(\"ProductServiceImpl::saveOrUpdateVariableProduct -> Product Saved/Updated with Product Id : {}, Query execution time: {}\", savedOrUpdatedProduct.getProductId(), watch.getTotalTimeSeconds());\r\n\r\n        // Map to SaveProductResponseDTO\r\n        SaveProductResponseDTO saveProductResponseDTO = mapper.map(savedOrUpdatedProduct, SaveProductResponseDTO.class);\r\n        saveProductResponseDTO.setId(savedOrUpdatedProduct.getProductId());\r\n        saveProductResponseDTO.setProductName(savedOrUpdatedProduct.getName());\r\n\r\n        // Set Category Group in response\r\n        SaveCategoryResponseDTO saveCategoryResponseDTO = new SaveCategoryResponseDTO();\r\n        saveCategoryResponseDTO.setId(savedOrUpdatedProduct.getCategory().getCategoryId());\r\n        saveCategoryResponseDTO.setName(savedOrUpdatedProduct.getCategory().getName());\r\n        saveProductResponseDTO.setCategoryGroup(saveCategoryResponseDTO);\r\n\r\n        // Map ProductVariationRelations to SavedVariationRelationResponseDTO\r\n\r\n        List<SavedVariationRelationResponseDTO> savedVariationRelationResponseDTOS = savedOrUpdatedProduct.getVariationRelations().stream()\r\n                .map(productVariationRelation -> {\r\n\r\n                    // Map AddonGroup entities to SavedProductProductAddonGroupResponseDTO\r\n                    List<SaveAddonGroupResponseDTO> saveAddonGroupResponseDTOList = productVariationRelation.getAddonGroups().stream()\r\n                            .map(productAddonGroup -> SaveAddonGroupResponseDTO.builder()\r\n                                    .id(productAddonGroup.getAddonGroupId())\r\n                                    .name(productAddonGroup.getName())\r\n                                    .build())\r\n                            .collect(Collectors.toList());\r\n\r\n                    // Build and return SavedVariationRelationResponseDTO\r\n                    return SavedVariationRelationResponseDTO.builder()\r\n                            .id(productVariationRelation.getVariation().getVariationId())\r\n                            .itemBasePrice(productVariationRelation.getItemBasePrice())\r\n                            .profitMargin(productVariationRelation.getProfitMargin())\r\n                            .addonGroups(saveAddonGroupResponseDTOList)\r\n                            .build();\r\n                })\r\n                .collect(Collectors.toList());\r\n        // Set Product Variation Relations in response\r\n        saveProductResponseDTO.setVariations(savedVariationRelationResponseDTOS);\r\n\r\n        return saveProductResponseDTO;\r\n    }\r\n\r\n    private ProductResponseDTO getProductsResponse(ProductQueryRequestDTO productQueryRequestDTO, Boolean includeLimit) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::getProductsResponse\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<ProductQueryOutputDTO> productQueryOutputDTOList = productRepository.findAllProducts(\r\n                productQueryRequestDTO,\r\n                includeLimit\r\n        );\r\n        watch.stop();\r\n\r\n        // This will throw a RecordNotFound exception when no data found for the export related scenarios\r\n        if (!includeLimit) {\r\n            CommonUtils.validateRecordsNotFound(productQueryOutputDTOList, \"ProductQueryOutputDTO\");\r\n        }\r\n\r\n        long totalRecords = productQueryOutputDTOList.isEmpty() ? 0 : productQueryOutputDTOList.get(0).getTotalRecords();\r\n        ProductResponseDTO productResponseDTO = new ProductResponseDTO();\r\n        productResponseDTO.setTotalRecords((int) totalRecords);\r\n        productResponseDTO.setOffset(productQueryRequestDTO.getOffset());\r\n        productResponseDTO.setLimit(productQueryRequestDTO.getLimit());\r\n        productResponseDTO.setProducts(productQueryOutputDTOList);\r\n\r\n        log.info(\r\n                \"ProductServiceImpl::getProductsResponse -> Query execution time: {}, Number of products: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                productResponseDTO.getProducts().size(),\r\n                productResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return productResponseDTO;\r\n    }\r\n}"
    },
    {
        "file_name": "HighComplexityExample.java",
        "java_code": "public class HighComplexityExample {\r\n    public static void main(String[] args) {\r\n        try {\r\n            String[] inputs = { \"alpha\", \"beta\", \"gamma\", null, \"delta\" };\r\n            for (String input : inputs) {\r\n                try {\r\n                    processPipeline(input);\r\n                } catch (Exception e) {\r\n                    System.out.println(\"Error processing input: \" + e.getMessage());\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Critical error in main pipeline: \" + ex.getMessage());\r\n        }\r\n    }\r\n\r\n    public static void processPipeline(String input) {\r\n        LoggingProcessor processor = new LoggingProcessor();\r\n        try {\r\n            processor.process(input);\r\n            if (input != null) {\r\n                if (input.length() > 5) {\r\n                    for (int i = 0; i < input.length(); i++) {\r\n                        char c = input.charAt(i);\r\n                        if (Character.isLetter(c)) {\r\n                            for (int j = 0; j < c; j++) {\r\n                                if (j % 2 == 0 && j % 3 == 0) {\r\n                                    System.out.println(\"Special char: \" + c + \" at position \" + j);\r\n                                } else {\r\n                                    System.out.println(\"Regular char: \" + c);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    System.out.println(\"Short input: \" + input);\r\n                }\r\n            } else {\r\n                throw new NullPointerException(\"Input is null\");\r\n            }\r\n        } catch (IllegalArgumentException ex) {\r\n            System.out.println(\"Validation error: \" + ex.getMessage());\r\n        } catch (NullPointerException ex) {\r\n            System.out.println(\"Null error: \" + ex.getMessage());\r\n        } catch (Exception ex) {\r\n            System.out.println(\"Unexpected error: \" + ex.getMessage());\r\n        } finally {\r\n            System.out.println(\"Pipeline processing completed for input: \" + input);\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "LearnerServiceImpl.java",
        "java_code": "public class LearnerServiceImpl  {\r\n    private LearnerRepository learnerRepository;\r\n    private NotificationClient notificationClient;\r\n\r\n    public LearnerServiceImpl(LearnerRepository learnerRepository, NotificationClient notificationClient){\r\n        this.learnerRepository = learnerRepository;\r\n        this.notificationClient = notificationClient;\r\n    }\r\n\r\n    public void enrollCourse(Long learnerId, Long courseId) {\r\n        Learner learner = learnerRepository.findById(learnerId)\r\n                .orElseThrow(() -> new RuntimeException(\"Learner not found with id: \" + learnerId));\r\n        Course course = courseClient.getCourseById(courseId);\r\n        if (course == null) {\r\n            throw new RuntimeException(\"Course not found with id: \" + courseId);\r\n        }\r\n\r\n        if (learner.getEnrolledCourses().containsKey(courseId)) {\r\n            throw new RuntimeException(\"Learner is already enrolled in the course\");\r\n        }\r\n        CourseInfo courseInfo = new CourseInfo(course.getName(), course.getCoursePrice(), \"Not Paid\");\r\n        learner.getEnrolledCourses().put(courseId, courseInfo);\r\n        learner.getInProgressCourses().put(courseId, course.getName()); \r\n        learnerRepository.save(learner);\r\n        try {\r\n            Notification notification = new Notification();\r\n            notification.setToEmail(learner.getEmail());\r\n            notification.setCourseId(courseId.toString());\r\n            notification.setCourseName(course.getName());\r\n\r\n            notificationClient.sendEmail(notification);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Failed to send notification\", e);\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "sss.java",
        "java_code": "package com.example.Payment.service;\r\n\r\n\r\nimport com.example.Payment.repository.PaymentRepository;\r\nimport com.example.Payment.entity.CourseInfo;\r\nimport com.example.Payment.entity.Payments;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@Service\r\npublic class PaymentImpl implements PaymentService{\r\n\r\n    @Autowired\r\n    PaymentClient paymentClient;\r\n\r\n    @Autowired\r\n    PaymentRepository paymentRepository;\r\n\r\n    @Override\r\n    public Map<Long, CourseInfo> getLearnerCourses(Long learnerId) {\r\n        ResponseEntity<Map<Long, CourseInfo>> response = paymentClient.getLearnerById(learnerId);\r\n\r\n        if (response != null && response.getBody() != null) {\r\n            return response.getBody(); // Corrected return statement\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void saveLearnerCourses(Long learnerId, Map<Long, CourseInfo> courses) {\r\n        for (Map.Entry<Long, CourseInfo> entry : courses.entrySet()) {\r\n            Long courseId = entry.getKey();\r\n            CourseInfo courseInfo = entry.getValue();\r\n\r\n            // Check if the learnerId and courseId combination already exists in the database\r\n            if (paymentRepository.existsByLearnerIdAndCourseName(learnerId.toString(), courseInfo.getName())) {\r\n                // If it exists, print a message or perform any desired action\r\n                System.out.println(\"LearnerId \" + learnerId + \" and CourseInfo \" + courseInfo.getName() + \" already exist.\");\r\n            } else {\r\n                // If it doesn't exist, create and save the Payments object\r\n                Payments payment = new Payments();\r\n                payment.setLearnerId(learnerId.toString());\r\n                payment.setCourseName(courseInfo.getName());\r\n                payment.setPrice(courseInfo.getPrice());\r\n                payment.setDate(new Date()); // Assuming you want to set the current date\r\n\r\n                paymentRepository.save(payment);\r\n            }\r\n        }\r\n    }\r\n\r\n    public double calculateTotalPrice(Map<Long, CourseInfo> courses) {\r\n        double totalPrice = 0.0;\r\n        for (CourseInfo courseInfo : courses.values()) {\r\n            // Check if the payment status is \"Not Paid\"\r\n            if (\"Not Paid\".equals(courseInfo.getPaymentStatus())) {\r\n                totalPrice += courseInfo.getPrice();\r\n            }\r\n        }\r\n        return totalPrice;\r\n    }\r\n\r\n}"
    },
    {
        "file_name": "ComplexJavaExampleee.java",
        "java_code": "import java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class ComplexJavaExample {\r\n\r\n    public static int processData(List<Integer> numbers, Map<String, Integer> config, boolean flag) {\r\n        int result = 0;\r\n\r\n        // Deeply nested conditionals\r\n        if (numbers != null && !numbers.isEmpty()) {\r\n            for (int num : numbers) {\r\n                if (num > 0) {\r\n                    System.out.println(\"Caught inner arithmetic exception: \" + e.getMessage());\r\n                }\r\n            }\r\n        }\r\n\r\n        // Multiple nested loops\r\n        for (String key : config.keySet()) {\r\n            for (int i = 0; i < 5; i++) {\r\n                for (int j = 0; j < config.getOrDefault(key, 1); j++) {\r\n                    if ((i + j) % 2 == 0 || j > 3 && i < 2) { // Complex condition\r\n                        result += j * i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Try-catch with deep nesting\r\n        try {\r\n            if (result > 0) {\r\n                try {\r\n                    int division = 100 / result;\r\n                    if (division > 10) {\r\n                        throw new ArithmeticException(\"Artificial Exception\");\r\n                    }\r\n                } catch (ArithmeticException e) {\r\n                    System.out.println(\"Caught inner arithmetic exception: \" + e.getMessage());\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            System.out.println(\"Caught outer exception: \" + e.getMessage());\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"
    },
    {
        "file_name": "ComplexJavaExample.java",
        "java_code": "public class ComplexJavaExample {\r\n\r\n    private int value;\r\n\r\n    public ComplexJavaExample(int value) {\r\n        super(\"Example\");\r\n        this.value = value;\r\n    }\r\n\r\n    public void complexMethod(int param) {\r\n        ExecutorService executor = Executors.newFixedThreadPool(2);\r\n\r\n        try {\r\n            if (param > 0 && param < 50 || (param % 2 == 0 && param > 10)) {\r\n                for (int i = 0; i < 5; i++) {\r\n                        try {\r\n                            \r\n                        } catch (Exception e) { \r\n                            System.out.println(\"Error processing task: \" + e.getMessage());\r\n                        }\r\n                }\r\n            } \r\n            else if (param < 0){\r\n                while (value > 0) \r\n                { \r\n                    System.out.println(\"Decrementing value\");\r\n                    value--;\r\n                }\r\n            } else {\r\n                System.out.println(\"Parameter out of range\");\r\n            }\r\n        } \r\n        finally {\r\n            executor.shutdown();\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "ComplexCodeExample.java",
        "java_code": "public class ComplexCodeExample {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            Scanner scanner = new Scanner(System.in);\r\n            System.out.println(\"Enter a number:\");\r\n            int num = scanner.nextInt();\r\n\r\n            if (num > 0) {\r\n                if (num < 10) {\r\n                    if (num % 2 == 0) {\r\n                        if (num % 3 == 0) {\r\n                            System.out.println(\"Number is divisible by 2, 3, and 5.\");\r\n                        } else {\r\n                            System.out.println(\"Number is even but not divisible by 3.\");\r\n                        }\r\n                    } else {\r\n                        System.out.println(\"Number is odd.\");\r\n                    }\r\n                } else {\r\n                    System.out.println(\"Number is 10 or greater.\");\r\n                }\r\n            } else {\r\n                System.out.println(\"Number is non-positive.\");\r\n            }\r\n\r\n            // Complex switch-case with deep nesting\r\n            switch (num) {\r\n                case 1:\r\n                    System.out.println(\"One\");\r\n                    break;\r\n                case 2:\r\n                    System.out.println(\"One\");\r\n                    break;\r\n                case 3:\r\n                    System.out.println(\"One\");\r\n                    break;\r\n                default:\r\n                    System.out.println(\"Some other number\");\r\n                    break;\r\n            }\r\n\r\n            // Multiple try-catch blocks\r\n            try {\r\n                int result = 100 / num;\r\n                System.out.println(\"Division result: \" + result);\r\n            } catch (ArithmeticException e) {\r\n                System.out.println(\"Error: Division by zero!\");\r\n            }\r\n\r\n            try {\r\n                int[] arr = new int[5];\r\n                System.out.println(arr[num]);\r\n            } catch (ArrayIndexOutOfBoundsException e) {\r\n                System.out.println(\"Error: Array index out of bounds!\");\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(\"General Exception: \" + e.getMessage());\r\n        }\r\n    }\r\n}"
    },
    {
        "file_name": "4.Hostel_registration.java",
        "java_code": "package Reg;\n\n//Hostel Class\nclass Hostel implements Serializable {\n    String BlockName;\n    room r[] = new room[2];\n    static int booking;\n\n    Hostel(String BlockName, int n) {\n        this.BlockName = BlockName;\n        for (int i = 0; i < n; i++) {\n            r[i] = new room();\n        }\n        r[0] = new room(101, 2);\n        r[1] = new room(102, 2);\n    }\n\n    public int Book(student[] sortedCGPA) throws InterruptedException {\n        for (student sortedCGPA1 : sortedCGPA) {\n            if (sortedCGPA1.allocatedroom == 0) {\n                for (room r1 : r) {\n                    if ((sortedCGPA1.prefroom == r1.roomno) && (r1.allotedno < r1.Size)) {\n                        sortedCGPA1.allocatedroom = sortedCGPA1.prefroom;\n                        r1.allotedno = r1.allotedno + 1;\n                        booking=booking+1;\n                        if(booking==1){\n                            wait(); }}\n                        if(booking>1&&booking<sortedCGPA.length-2){\n                            notifyAll();\n                            wait(); }}\n                        for (student o1:sortedCGPA){\n                            System.out.println(\"Details: \"+\" \"+o1.Regno+\" \"+o1.Name+\" \"+o1.CGPA+\" \"+o1.prefroom);\n                        }\n                    }\n                }\n                if(booking==sortedCGPA.length-1){\n                    return 1;\n                }\n                return 0;\n            }\n        }\n"
    },
    {
        "file_name": "4.Hostel_registration.java",
        "java_code": "package Reg;\n\n//Hostel Class\nclass Hostel implements Serializable {\n    String BlockName;\n    room r[] = new room[2];\n    static int booking;\n\n    Hostel(String BlockName, int n) {\n        this.BlockName = BlockName;\n        for (int i = 0; i < n; i++) {\n            r[i] = new room();\n        }\n        r[0] = new room(101, 2);\n        r[1] = new room(102, 2);\n    }\n\n    public int Book(student[] sortedCGPA) throws InterruptedException {\n        for (student sortedCGPA1 : sortedCGPA) {\n            if (sortedCGPA1.allocatedroom == 0) {\n                for (room r1 : r) {\n                    if ((sortedCGPA1.prefroom == r1.roomno) && (r1.allotedno < r1.Size)) {\n                        sortedCGPA1.allocatedroom = sortedCGPA1.prefroom;\n                        r1.allotedno = r1.allotedno + 1;\n                        booking=booking+1;\n                        if(booking==1){\n                            wait(); \n                          }\n                        }\n                        if(booking>1&&booking<sortedCGPA.length-2){\n                            notifyAll();\n                            wait(); \n                            }\n                        }\n                        for (student o1:sortedCGPA){\n                            System.out.println(\"Details: \"+\" \"+o1.Regno+\" \"+o1.Name+\" \"+o1.CGPA+\" \"+o1.prefroom);\n                        }\n                    }\n                }\n                if(booking==sortedCGPA.length-1){\n                    return 1;\n                }\n                return 0;\n            }\n        }\n"
    },
    {
        "file_name": "8.TestResult.java",
        "java_code": "/*Question - \nDesign a class called Participants with properties like Name, Phno,\nBranch and University, TestResult_Classification[L1,L2,L3,L4,L5]. Create a\nstatic method to display a message as follows based on the selection\ncriteria,\n(i) If student test result classification is L1, congratulate the student\nand inform that he/she has been selected for both Full time\nintership as well as Full time job\n(ii) If student test result classification is L2 or L3, inform the student\nthat he/she has been selected for Full time intership and Job\nmay be offered based on intership Performance.\n(iii) If student test result classification is L4 or L5, inform that he/she\nhas been selected for Part time intership of 21 days.\nCreate atleast three Participants objects of array and then invoke static\nmethod to display the message.\nNote: Don\u2019t use if statement for conditional check, instead use Switch\nCase statement.*/\n\n//Code-\nimport java.util.Scanner;\npublic class participants {\n  public static void main(String[] args) {\n    selection obj[] = new selection[3] ;\n    obj[0]=new selection();\n    obj[0].getData();\n    obj[1]=new selection();\n    obj[1].getData();\n    obj[2]=new selection();\n    obj[2].getData();\n  }\n}\nclass selection {\n  static void getData() {\n    Scanner s = new Scanner(System.in);\n    System.out.println(\"Enter Your Name:\");\n    String N = s.nextLine();\n    System.out.println(\"Enter Your phone no:\");\n    String P = s.nextLine();\n    int n = P.length();\n    if (n != 10) {\n      System.out.println(\"Enter valid phone no\");\n    } \n    else {\n      System.out.println(\"Enter Your Branch and University\");\n      String B = s.nextLine();\n      String U = s.nextLine();\n      System.out.println(\"Enter Condition as:\");\n      String L = s.next();\n      switch (L) {\n        case \"L1\":\n          System.out.println(\"Congrats \" + N + \" You selected for Full time internship and Full time job\");\n          break;\n        case \"L2\":\n          System.out.println(\"Congrats \" + N + \" You selecte for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case \"L3\":\n          System.out.println(\"Congrats \" + N + \" You selected for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case \"L4\":\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        case \"L5\":\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        default:\n          System.out.println(\"Invalid\");\n      }\n    }\n  }\n}\n"
    },
    {
        "file_name": "8.TestResult.java",
        "java_code": "\nclass selection {\n  static void getData() {\n    Scanner s = new Scanner(System.in);\n    System.out.println(\"Enter Your Name:\");\n    String N = s.nextLine();\n    System.out.println(\"Enter Your phone no:\");\n    String P = s.nextLine();\n    int n = P.length();\n    if (n != 10) {\n      System.out.println(\"Enter valid phone no\");\n    } \n    else {\n      System.out.println(\"Enter Your Branch and University\");\n      String B = s.nextLine();\n      String U = s.nextLine();\n      System.out.println(\"Enter Condition as:\");\n      String L = s.next();\n      switch (L) {\n        case \"L1\":\n          System.out.println(\"Congrats \" + N + \" You selected for Full time internship and Full time job\");\n          break;\n        case \"L2\":\n          System.out.println(\"Congrats \" + N + \" You selecte for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case \"L3\":\n          System.out.println(\"Congrats \" + N + \" You selected for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case \"L4\":\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        case \"L5\":\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        default:\n          System.out.println(\"Invalid\");\n      }\n    }\n  }\n}\n"
    },
    {
        "file_name": "8.TestResult.java",
        "java_code": "\nclass selection {\n  static void getData() {\n    Scanner s = new Scanner(System.in);\n    System.out.println(\"Enter Your Name:\");\n    String N = s.nextLine();\n    System.out.println(\"Enter Your phone no:\");\n    String P = s.nextLine();\n    int n = P.length();\n    if (n != 10) {\n      System.out.println(\"Enter valid phone no\");\n    } \n    else {\n      System.out.println(\"Enter Your Branch and University\");\n      String B = s.nextLine();\n      String U = s.nextLine();\n      System.out.println(\"Enter Condition as:\");\n      String L = s.next();\n    }\n\n    switch (L) {\n        case \"L1\":\n          System.out.println(\"Congrats \" + N + \" You selected for Full time internship and Full time job\");\n          break;\n        case \"L2\":\n          System.out.println(\"Congrats \" + N + \" You selecte for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case \"L3\":\n          System.out.println(\"Congrats \" + N + \" You selected for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case \"L4\":\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        case \"L5\":\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        default:\n          System.out.println(\"Invalid\");\n      }\n  }\n}\n"
    },
    {
        "file_name": "8.TestResult.java",
        "java_code": "\nclass selection {\n  static void getData() {\n    Scanner s = new Scanner(System.in);\n    System.out.println(\"Enter Your Name:\");\n    String N = s.nextLine();\n    System.out.println(\"Enter Your phone no:\");\n    String P = s.nextLine();\n    int n = P.length();\n    if (n != 10) {\n      System.out.println(\"Enter valid phone no\");\n    } \n    else {\n      System.out.println(\"Enter Your Branch and University\");\n      String B = s.nextLine();\n      String U = s.nextLine();\n      System.out.println(\"Enter Condition as:\");\n      String L = s.next();\n    }\n\n    switch (L) {\n        case 1:\n          System.out.println(\"Congrats \" + N + \" You selected for Full time internship and Full time job\");\n          break;\n        case 2:\n          System.out.println(\"Congrats \" + N + \" You selecte for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case 3:\n          System.out.println(\"Congrats \" + N + \" You selected for selected for Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case 4:\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        case 5:\n          System.out.println(\"Congrats \" + N + \" You selected for Part time intership of 21 days.\");\n          break;\n        default:\n          System.out.println(\"Invalid\");\n      }\n  }\n}\n"
    },
    {
        "file_name": "8.TestResult.java",
        "java_code": "\nclass selection {\n  static void getData() {\n    Scanner s = new Scanner(System.in);\n    System.out.println(\"Enter Your Name:\");\n    String N = s.nextLine();\n    System.out.println(\"Enter Your phone no:\");\n    String P = s.nextLine();\n    int n = P.length();\n    if (n != 10) {\n      System.out.println(\"Enter valid phone no\");\n    } \n    else {\n      System.out.println(\"Enter Your Branch and University\");\n      String B = s.nextLine();\n      String U = s.nextLine();\n      System.out.println(\"Enter Condition as:\");\n      String L = s.next();\n    }\n\n    switch (L) {\n        case 1:\n          System.out.println(\"Congrats \" + N + \" You selected Full time internship and Full time job\");\n          break;\n        case 2:\n          System.out.println(\"Congrats \" + N + \" You selecte selected Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case 3:\n          System.out.println(\"Congrats \" + N + \" You selected selected Full time internship and Job may be offered based on internship Performance. \");\n          break;\n        case 4:\n          System.out.println(\"Congrats \" + N + \" You selected Part time intership of 21 days.\");\n          break;\n        case 5:\n          System.out.println(\"Congrats \" + N + \" You selected Part time intership of 21 days.\");\n          break;\n        default:\n          System.out.println(\"Invalid\");\n      }\n  }\n}\n"
    },
    {
        "file_name": "Sand_Timer_Pattern.java",
        "java_code": "package Star_pattern;\nimport java.util.Scanner;\n\npublic class Sand_Timer_Pattern {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int i,j,k;\n        System.out.println(\"Enter no of rows:\");\n        int row = in.nextInt();\n        for ( i = 1; i <= row; i++) {\n            for ( j = 1; j <= i; j++) {\n                System.out.print(\" \");\n            }\n            for ( k = row; k >= i; k--) {\n                System.out.print(\" \");\n                System.out.print(\"*\");\n            }\n            System.out.println();\n        }\n        for(i=2;i<=row;i++){\n            for(j=(row-1);j>=(i-1);j--){\n                System.out.print(\" \");\n            }\n            for(k=1;k<=i;k++){\n                System.out.print(\" \");\n                System.out.print(\"*\");  //or use System,out.print(\" *\");\n            }\n            System.out.println();\n\n        }\n    }\n}\n"
    },
    {
        "file_name": "ComplexJavaApp.java",
        "java_code": "public class ComplexJavaApp {\r\n    public static void main(String[] args) {\r\n        ComplexCalculator calculator = new ComplexCalculator();\r\n        int a = 10;\r\n        int b = 5;\r\n        if (a > b) \r\n        { \r\n            for (int i = 0; i < 3; i++) \r\n            { \r\n                System.out.println(\"Loop iteration: \" + i);\r\n            }\r\n        }\r\n        String operation = \"add\";\r\n        switch (operation) \r\n        {\r\n            case \"add\":\r\n                System.out.println(\"Addition: \" + calculator.add(a, b));\r\n                break;\r\n            case \"subtract\":\r\n                System.out.println(\"Subtraction: \" + (a - b));\r\n                break;\r\n            default:\r\n                System.out.println(\"No operation matched.\");\r\n        }\r\n\r\n        calculator.startCalculationThread(a, b, \"multiply\");\r\n        calculator.synchronizedMethod(a, b);\r\n\r\n        calculator.calculateWithErrorHandling(a, b, \"divide\");\r\n\r\n        calculator.nestedErrorHandling(a, 0);\r\n\r\n        boolean isComplex = calculator.complexCondition(a, b, 10);\r\n        System.out.println(\"Complex condition result: \" + isComplex);\r\n    }\r\n}"
    },
    {
        "file_name": "ProductServiceImpl.java",
        "java_code": "package com.icieos.pos.restaurant.service.product.impl;\r\n\r\nimport com.icieos.pos.restaurant.dto.ResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.addongroup.SaveAddonGroupResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.category.SaveCategoryResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.DeleteByIdsRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.SetAvailabilityStatusRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.product.*;\r\nimport com.icieos.pos.restaurant.dto.product.tag.GetTagDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variationrelation.GetVariationRelationResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variationrelation.SaveVariationRelationRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variationrelation.SavedVariationRelationResponseDTO;\r\nimport com.icieos.pos.restaurant.entity.enums.DayOfWeek;\r\nimport com.icieos.pos.restaurant.entity.enums.DietaryType;\r\nimport com.icieos.pos.restaurant.entity.enums.OrderType;\r\nimport com.icieos.pos.restaurant.entity.enums.Platform;\r\nimport com.icieos.pos.restaurant.entity.product.*;\r\nimport com.icieos.pos.restaurant.repository.product.*;\r\nimport com.icieos.pos.restaurant.service.exception.BadRequestException;\r\nimport com.icieos.pos.restaurant.service.product.ProductService;\r\nimport com.icieos.pos.restaurant.service.exception.DuplicateRecordException;\r\nimport com.icieos.pos.restaurant.util.CommonUtils;\r\nimport com.icieos.pos.restaurant.service.exception.RecordNotFoundException;\r\nimport com.icieos.pos.restaurant.util.ValidationUtils;\r\nimport com.icieos.pos.restaurant.util.excel.exportdata.ExportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportTemplates;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.ss.usermodel.Cell;\r\nimport org.modelmapper.ModelMapper;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.util.StopWatch;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\n@Slf4j\r\npublic class ProductServiceImpl implements ProductService {\r\n    private final ProductRepository productRepository;\r\n\r\n    private final CategoryRepository categoryRepository;\r\n\r\n    private final TagRepository tagRepository;\r\n\r\n    private final AddonGroupRepository addonGroupRepository;\r\n\r\n    private final VariationRepository variationRepository;\r\n\r\n    private final ModelMapper mapper;\r\n\r\n    public ProductServiceImpl(ProductRepository productRepository, CategoryRepository categoryRepository,TagRepository tagRepository, AddonGroupRepository addonGroupRepository,VariationRepository variationRepository, ModelMapper mapper) {\r\n        this.productRepository = productRepository;\r\n        this.categoryRepository = categoryRepository;\r\n        this.tagRepository = tagRepository;\r\n        this.addonGroupRepository = addonGroupRepository;\r\n        this.variationRepository = variationRepository;\r\n        this.mapper = mapper;\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackOn = {DuplicateRecordException.class, RecordNotFoundException.class, BadRequestException.class})\r\n    public SaveProductResponseDTO createOrUpdateProduct(SaveProductRequestDTO saveProductRequestDTO, Long productId) throws RecordNotFoundException, DuplicateRecordException, BadRequestException {\r\n\r\n        log.info(\"ProductServiceImpl::createOrUpdateProduct\");\r\n        Product product;\r\n\r\n        boolean isExistsProduct = productRepository.existsByNameIgnoreCaseAndIsDeletedFalse(saveProductRequestDTO.getProductName());\r\n        if (productId != null) {\r\n            // Check if the product exists and Product Is not deleted\r\n            product = productRepository.findByIdAndIsDeletedFalse(productId);\r\n            if (product == null) {\r\n                throw new RecordNotFoundException(\"Product not found\");\r\n            }\r\n\r\n            // Check if the new product name already exists and Product Is not deleted (excluding the current product)\r\n            if (isExistsProduct && !product.getName().equals(saveProductRequestDTO.getProductName())) {\r\n                throw new DuplicateRecordException(\"Product name already exists\");\r\n            }\r\n\r\n            mapper.map(saveProductRequestDTO, product);\r\n        } else {\r\n            if (isExistsProduct) {\r\n                throw new DuplicateRecordException(\"Product name already exists\");\r\n            }\r\n\r\n            product = mapper.map(saveProductRequestDTO, Product.class);\r\n        }\r\n\r\n        // Validate and Create Enum Strings\r\n        String dietaryTypes = DietaryType.processDietaryTypesString(saveProductRequestDTO.getDietary());\r\n        String orderTypes = OrderType.processOrderTypesString(saveProductRequestDTO.getOrderType());\r\n        String platforms = Platform.processPlatformString(saveProductRequestDTO.getExposingPlatforms());\r\n        String daysOfWeek = DayOfWeek.processAvailableDaysString(saveProductRequestDTO.getAvailableDays());\r\n\r\n        // Validate product Category\r\n        Category category = categoryRepository.findByCategoryId(saveProductRequestDTO.getCategoryGroupId());\r\n        if (category == null) {\r\n            throw new RecordNotFoundException(\"Product category group not found\");\r\n        }\r\n\r\n        // Check for duplicate product tags\r\n        List<Long> tagIds = saveProductRequestDTO.getTagIds();\r\n        ValidationUtils.checkForDuplicates(tagIds, \"Duplicate tag IDs found\");\r\n\r\n        // Check the existence of tags\r\n        Set<Tag> tagSet = new LinkedHashSet<>(tagRepository.findAllById(tagIds));\r\n\r\n        if (tagSet.size() != tagIds.size()) {\r\n            throw new RecordNotFoundException(\"Some tags were not found\");\r\n        }\r\n\r\n        product.setName(saveProductRequestDTO.getProductName());\r\n        product.setDietary(dietaryTypes);\r\n        product.setAvailableDays(daysOfWeek);\r\n        product.setExposingPlatforms(platforms);\r\n        product.setOrderType(orderTypes);\r\n        product.setCategory(category);\r\n        product.setTags(tagSet);\r\n\r\n        if (!saveProductRequestDTO.getIsVariableProduct()) {\r\n            log.info(\"ProductServiceImpl::createOrUpdateProduct ->Updating non-variable product\");\r\n            return saveOrUpdateNonVariableProduct(saveProductRequestDTO, product, productId != null);\r\n\r\n        } else {\r\n            log.info(\"ProductServiceImpl::createOrUpdateProduct ->Updating variable product\");\r\n            return saveOrUpdateVariableProduct(saveProductRequestDTO, product);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO updateFavouriteStatusByIds(SetProductFavoriteStatusRequestDTO setProductFavoriteStatusRequestDTO) throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"ProductServiceImpl::updateFavouriteStatusByIds\");\r\n\r\n        List<Long> productsIdList = setProductFavoriteStatusRequestDTO.getProducts();\r\n        Boolean favoriteStatus = setProductFavoriteStatusRequestDTO.getFavoriteStatus();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(productsIdList, \"Duplicate Product IDs in the request\");\r\n\r\n        // Find all products by IDs that are not marked as deleted\r\n        List<Product> productsToUpdate = productRepository.findAllByIdsAndIsDeletedFalse(productsIdList);\r\n\r\n        // Check if all requested products exist\r\n        if (productsToUpdate.size() != productsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some products were not found\");\r\n        }\r\n        // Filter only those products where the favourite status differs\r\n        List<Product> filteredProductsToUpdate = productsToUpdate.stream()\r\n                .filter(product -> !favoriteStatus.equals(product.getAvailabilityStatus()))\r\n                .peek(product -> {\r\n                    product.setSetAsFavorite(favoriteStatus);\r\n                    log.info(\"ProductServiceImpl::updateFavouriteStatusByIds -> Product with ID {} is marked as : {}\", product.getProductId(), favoriteStatus);\r\n                })\r\n                .collect(Collectors.toList());\r\n\r\n        // Save only the filtered product categories\r\n        if (!filteredProductsToUpdate.isEmpty()) {\r\n            StopWatch watch = new StopWatch();\r\n            watch.start();\r\n            List<Product> updatedProductList = productRepository.saveAll(filteredProductsToUpdate);\r\n            watch.stop();\r\n\r\n            log.info(\"ProductServiceImpl::updateFavouriteStatusByIds -> Query execution time: {}, Total records updated: {}\", watch.getTotalTimeSeconds(), updatedProductList.size());\r\n        } else {\r\n            log.info(\"ProductServiceImpl::updateFavouriteStatusByIds -> No product  had a change in availability status.\");\r\n        }\r\n\r\n        return new ResponseDTO(\"Favorite status updated successfully for products.\");\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO updateAvailabilityStatusByIds(SetAvailabilityStatusRequestDTO setAvailabilityStatusRequestDTO) throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds\");\r\n\r\n        List<Long> productsIdList = setAvailabilityStatusRequestDTO.getIdList();\r\n        Boolean availabilityStatus = setAvailabilityStatusRequestDTO.getAvailabilityStatus();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(productsIdList, \"Duplicate product IDs in the request\");\r\n\r\n        // Find all products by IDs that are not marked as deleted\r\n        List<Product> productsToUpdate = productRepository.findAllByIdsAndIsDeletedFalse(productsIdList);\r\n\r\n        // Check if all requested products exist\r\n        if (productsToUpdate.size() != productsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some products were not found\");\r\n        }\r\n        // Filter only those product  where the availability status differs\r\n        List<Product> filteredProductsToUpdate = productsToUpdate.stream()\r\n                .filter(product -> !availabilityStatus.equals(product.getAvailabilityStatus()))\r\n                .peek(product -> {\r\n                    product.setAvailabilityStatus(availabilityStatus);\r\n                    log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds -> Product with ID {} is marked as : {}\", product.getProductId(), availabilityStatus);\r\n                })\r\n                .collect(Collectors.toList());\r\n\r\n        // Save only the filtered products\r\n        if (!filteredProductsToUpdate.isEmpty()) {\r\n            StopWatch watch = new StopWatch();\r\n            watch.start();\r\n            List<Product> updatedProductList = productRepository.saveAll(filteredProductsToUpdate);\r\n            watch.stop();\r\n\r\n            log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds -> Query execution time: {}, Total records updated: {}\", watch.getTotalTimeSeconds(), updatedProductList.size());\r\n        } else {\r\n            log.info(\"ProductServiceImpl::updateAvailabilityStatusByIds -> No products had a change in availability status.\");\r\n        }\r\n\r\n        return new ResponseDTO(\"Availability status updated successfully for products.\");\r\n    }\r\n\r\n    @Override\r\n    public GetProductResponseDTO findProductById(Long id) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::findProductById\");\r\n\r\n        // Retrieve the product by its ID and ensure it is not deleted\r\n        Product product = productRepository.findByIdAndIsDeletedFalse(id);\r\n        if (product == null) {\r\n            throw new RecordNotFoundException(\"Product not found\");\r\n        }\r\n\r\n        // Map the product entity to GetProductResponseDTO\r\n        GetProductResponseDTO getProductResponseDTO = mapper.map(product, GetProductResponseDTO.class);\r\n        getProductResponseDTO.setId(product.getProductId());\r\n        getProductResponseDTO.setProductName(product.getName());\r\n\r\n        // Set Category Group in response\r\n        SaveCategoryResponseDTO saveCategoryResponseDTO = new SaveCategoryResponseDTO();\r\n        saveCategoryResponseDTO.setId(product.getCategory().getCategoryId());\r\n        saveCategoryResponseDTO.setName(product.getCategory().getName());\r\n\r\n        getProductResponseDTO.setCategoryGroup(saveCategoryResponseDTO);\r\n\r\n        // Set Product Tags In Response\r\n        Set<Tag> existingTags = product.getTags();\r\n        if (existingTags != null) {\r\n            List<GetTagDTO> getTagDTOList = existingTags.stream()\r\n                    .map(tag -> {\r\n                        GetTagDTO getTagDTO = new GetTagDTO();\r\n                        getTagDTO.setId(tag.getTagId());\r\n                        getTagDTO.setName(tag.getName());\r\n                        return getTagDTO;\r\n                    })\r\n                    .collect(Collectors.toList());\r\n\r\n            getProductResponseDTO.setTags(getTagDTOList);\r\n        } else {\r\n            getProductResponseDTO.setTags(Collections.emptyList());\r\n        }\r\n\r\n        // Check if the product is variable\r\n        if (product.getIsVariableProduct()) {\r\n            log.info(\"ProductServiceImpl::findProductById -> Get Product Variation Relations for Product Id : {} \", id);\r\n\r\n            //Make the AddonGroup Field Null(otherwise Empty)\r\n            getProductResponseDTO.setAddonGroups(null);\r\n\r\n            // Retrieve Product variations\r\n            Set<VariationRelation> variationRelations = product.getVariationRelations();\r\n            List<GetVariationRelationResponseDTO> existingVariationRelationResponseDTOList = variationRelations.stream()\r\n                    .map(productVariationRelation -> {\r\n\r\n                        // Map AddonGroup entities to SavedProductProductAddonGroupResponseDTO\r\n                        List<SaveAddonGroupResponseDTO> saveAddonGroupResponseDTOList = productVariationRelation.getAddonGroups().stream()\r\n                                .map(productAddonGroup -> SaveAddonGroupResponseDTO.builder()\r\n                                        .id(productAddonGroup.getAddonGroupId())\r\n                                        .name(productAddonGroup.getName())\r\n                                        .build())\r\n                                .collect(Collectors.toList());\r\n\r\n                        // Build and return GetVariationRelationResponseDTO\r\n                        return GetVariationRelationResponseDTO.builder()\r\n                                .id(productVariationRelation.getVariation().getVariationId())\r\n                                .itemBasePrice(productVariationRelation.getItemBasePrice())\r\n                                .profitMargin(productVariationRelation.getProfitMargin())\r\n                                .containerCharges(productVariationRelation.getContainerCharges())\r\n                                .sapCode(productVariationRelation.getSapCode())\r\n                                .serves(productVariationRelation.getServes())\r\n                                .weightOrVolume(productVariationRelation.getWeightOrVolume())\r\n                                .addonGroups(saveAddonGroupResponseDTOList)\r\n                                .build();\r\n                    })\r\n                    .toList();\r\n\r\n            // Set variations in the response DTO\r\n            getProductResponseDTO.setVariations(existingVariationRelationResponseDTOList);\r\n        } else {\r\n            // Existing Product Addon Groups\r\n            Set<AddonGroup> existingAddonGroups = product.getAddonGroups();\r\n\r\n            // Map Product Addon Groups to SaveProductAddonGroupResponseDTO\r\n            List<SaveAddonGroupResponseDTO> savedProductAddonGroupResponseDTOList =\r\n                    existingAddonGroups.stream()\r\n                            .map(addonGroup -> {\r\n                                SaveAddonGroupResponseDTO saveAddonGroupResponseDTO = new SaveAddonGroupResponseDTO();\r\n                                saveAddonGroupResponseDTO.setId(addonGroup.getAddonGroupId());\r\n                                saveAddonGroupResponseDTO.setName(addonGroup.getName());\r\n                                return saveAddonGroupResponseDTO;\r\n                            })\r\n                            .collect(Collectors.toList());\r\n            getProductResponseDTO.setAddonGroups(savedProductAddonGroupResponseDTOList);\r\n        }\r\n\r\n        return getProductResponseDTO;\r\n    }\r\n\r\n    @Override\r\n    public ProductResponseDTO findAllProducts(ProductQueryRequestDTO productQueryRequestDTO) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::findAllProducts\");\r\n\r\n        return getProductsResponse(\r\n                productQueryRequestDTO,\r\n                true\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public ProductsByCategoryResponseDTO findProductsByCategoryId(Long id) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::findProductsByCategoryId\");\r\n\r\n        Category category = categoryRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Category Not Found\"));\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n\r\n        List<Product> directProducts = productRepository.findByCategory(category);\r\n        List<Product> productList = new ArrayList<>(directProducts);\r\n\r\n        if (category.getCategoryGroup() == null) {\r\n            List<Category> subcategories = categoryRepository.findByCategoryGroup(category);\r\n            for (Category subcategory : subcategories) {\r\n                productList.addAll(productRepository.findByCategory(subcategory));\r\n            }\r\n        }\r\n\r\n        List<ProductDTO> productDTOList = productList.stream()\r\n                .map(product -> mapper.map(product, ProductDTO.class))\r\n                .collect(Collectors.toList());\r\n\r\n        ProductsByCategoryResponseDTO productsByCategoryResponseDTO = new ProductsByCategoryResponseDTO();\r\n        productsByCategoryResponseDTO.setProducts(productDTOList);\r\n        productsByCategoryResponseDTO.setTotalRecords(productList.size());\r\n        productsByCategoryResponseDTO.setCategoryId(category.getCategoryId());\r\n        productsByCategoryResponseDTO.setCategoryName(category.getName());\r\n\r\n        log.info(\r\n                \"ProductServiceImpl::findProductsByCategoryId -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                productsByCategoryResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return productsByCategoryResponseDTO;\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteProductById(Long id) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::deleteProductById\");\r\n\r\n        // Retrieve the product by its ID and ensure it is not deleted\r\n        Product product = productRepository.findByIdAndIsDeletedFalse(id);\r\n        if (product == null) {\r\n            throw new RecordNotFoundException(\"Product not found\");\r\n        }\r\n\r\n        // Mark the product as deleted\r\n        product.setIsDeleted(true);\r\n        productRepository.save(product);\r\n\r\n        return new ResponseDTO(String.format(\"Product with ID %d deleted successfully\", id));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteProductsByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO) throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"ProductServiceImpl::deleteProductsByIds\");\r\n\r\n        List<Long> productsIdList = deleteByIdsRequestDTO.getIdList();\r\n        // Check for Duplicate Ids in the request\r\n        ValidationUtils.checkForDuplicates(productsIdList, \"Duplicate product Ids in the request\");\r\n\r\n        // Find all products by IDs\r\n        List<Product> productsToDelete = productRepository.findAllByIdsAndIsDeletedFalse(productsIdList);\r\n\r\n        // Check whether the request ids are exists\r\n        if (productsToDelete.size() != productsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some products were not found\");\r\n        }\r\n\r\n        // No need filter\r\n        productsToDelete.stream()\r\n                .filter(product -> !Boolean.TRUE.equals(product.getIsDeleted()))\r\n                .forEach(product -> {\r\n                    product.setIsDeleted(true);\r\n                });\r\n\r\n        // Save changes\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<Product> deletedProductList = productRepository.saveAll(productsToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ProductServiceImpl::deleteProductsByIds -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                deletedProductList.size()\r\n        );\r\n\r\n        return new ResponseDTO(\"Products successfully deleted\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"ProductServiceImpl::generateImportTemplate\");\r\n\r\n        return new InputStreamResource(ImportTemplates.generateProductImportTemplate());\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportProducts(ProductQueryRequestDTO productQueryRequestDTO) throws IOException, RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::exportProducts\");\r\n\r\n        ProductResponseDTO productResponseDTO = getProductsResponse(productQueryRequestDTO, productQueryRequestDTO.getIncludeLimit());\r\n        return new InputStreamResource(ExportData.exportProducts(productResponseDTO.getProducts()));\r\n\r\n\r\n    }\r\n\r\n    //Custom Method For Saving,Updating and Creating Response for Non-Variable Products\r\n    private SaveProductResponseDTO saveOrUpdateNonVariableProduct(SaveProductRequestDTO saveProductRequestDTO, Product product, Boolean isUpdate) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::saveOrUpdateNonVariableProduct\");\r\n\r\n        // When Update from variable-> non-variable, need to remove all the association with variation relations.\r\n        // It will remove all the product - variation associations and variation - addon group associations.\r\n        if (isUpdate) {\r\n            product.getVariationRelations().clear();\r\n        }\r\n\r\n        // Validate Addon Groups existence\r\n        List<Long> addonGroupIds = saveProductRequestDTO.getAddonGroupIds();\r\n        //Utility method for checking Duplicates\r\n        ValidationUtils.checkForDuplicates(addonGroupIds, \"Duplicate addon group IDs found\");\r\n\r\n        // Check the existence of all the addon groups\r\n        Set<AddonGroup> existingAddonGroups = new HashSet<>(addonGroupRepository.findAllById(addonGroupIds));\r\n        if (existingAddonGroups.size() != addonGroupIds.size()) {\r\n            throw new RecordNotFoundException(\"Some addon groups were not found\");\r\n        }\r\n\r\n\r\n        product.setAddonGroups(existingAddonGroups);\r\n\r\n        product.setIsVariableProduct(false);\r\n        product.setWeightOrVolume(saveProductRequestDTO.getWeightOrVolume());\r\n        product.setContainerCharges(saveProductRequestDTO.getContainerCharges());\r\n        product.setItemBasePrice(saveProductRequestDTO.getItemBasePrice());\r\n        product.setProfitMargin(saveProductRequestDTO.getProfitMargin());\r\n        product.setSapCode(saveProductRequestDTO.getSapCode());\r\n        product.setServes(saveProductRequestDTO.getServes());\r\n\r\n        // Save Non-variable Product\r\n        // Note: If we are updating a product, we don't need to remove previous associations (including many-to-many with no extra attributes).\r\n        //       Since we are updating the whole product, it will take care of associations as well.\r\n        Product savedOrUpdatedProduct = productRepository.save(product);\r\n        log.info(\"ProductServiceImpl::saveOrUpdateNonVariableProduct -> Product Saved/Updated with Product Id : {}\", savedOrUpdatedProduct.getProductId());\r\n\r\n        // Map to Response DTO\r\n        SaveProductResponseDTO saveProductResponseDTO = mapper.map(savedOrUpdatedProduct, SaveProductResponseDTO.class);\r\n        saveProductResponseDTO.setId(savedOrUpdatedProduct.getProductId());\r\n        saveProductResponseDTO.setProductName(savedOrUpdatedProduct.getName());\r\n\r\n        // Set Category Group in response\r\n        SaveCategoryResponseDTO saveCategoryResponseDTO = new SaveCategoryResponseDTO();\r\n        saveCategoryResponseDTO.setId(savedOrUpdatedProduct.getCategory().getCategoryId());\r\n        saveCategoryResponseDTO.setName(savedOrUpdatedProduct.getCategory().getName());\r\n        saveProductResponseDTO.setCategoryGroup(saveCategoryResponseDTO);\r\n\r\n        // Map Product Addon Groups to Response DTO\r\n        // List of saved AddonGroups from savedOrUpdatedProduct\r\n        Set<AddonGroup> savedAddonGroups = savedOrUpdatedProduct.getAddonGroups();\r\n\r\n        List<SaveAddonGroupResponseDTO> savedProductAddonGroupResponseDTOList =\r\n                savedAddonGroups.stream()\r\n                        .map(addonGroup -> {\r\n                            SaveAddonGroupResponseDTO saveAddonGroupResponseDTO = new SaveAddonGroupResponseDTO();\r\n                            saveAddonGroupResponseDTO.setId(addonGroup.getAddonGroupId());\r\n                            saveAddonGroupResponseDTO.setName(addonGroup.getName());\r\n                            return saveAddonGroupResponseDTO;\r\n                        })\r\n                        .collect(Collectors.toList());\r\n        saveProductResponseDTO.setAddonGroups(savedProductAddonGroupResponseDTOList);\r\n\r\n        return saveProductResponseDTO;\r\n    }\r\n\r\n    //Custom Method For Saving,Updating and Creating Response for Non-Variable Products\r\n    private SaveProductResponseDTO saveOrUpdateVariableProduct(SaveProductRequestDTO saveProductRequestDTO, Product product) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::saveOrUpdateVariableProduct\");\r\n\r\n        product.setIsVariableProduct(true);\r\n        product.setWeightOrVolume(null);\r\n        product.setContainerCharges(null);\r\n        product.setItemBasePrice(null);\r\n        product.setProfitMargin(null);\r\n        product.setSapCode(null);\r\n        product.setServes(null);\r\n        product.setAddonGroups(null);\r\n\r\n        // Collect all variation IDs from the request\r\n        List<Long> requestVariationIdList = saveProductRequestDTO.getVariations().stream()\r\n                .map(SaveVariationRelationRequestDTO::getId)\r\n                .toList();\r\n\r\n        // Utility method for duplicate variation IDs\r\n        ValidationUtils.checkForDuplicates(requestVariationIdList, \"Duplicate variation IDs found\");\r\n\r\n        // Fetch all required ProductVariations and validate existence\r\n        Map<Long, Variation> productVariationMap = variationRepository.findAllById(requestVariationIdList).stream()\r\n                .collect(Collectors.toMap(Variation::getVariationId, productVariation -> productVariation));\r\n\r\n        if (productVariationMap.size() != requestVariationIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some product variation IDs were not found\");\r\n        }\r\n\r\n        // Check for variations with duplicate addon group IDs; throw exception if any are found\r\n        long duplicateCount = saveProductRequestDTO.getVariations().stream()\r\n                .filter(variation -> {\r\n                    List<Long> addonGroupIds = variation.getAddonGroupIds();\r\n                    // Use helper method here\r\n                    return addonGroupIds.size() != new HashSet<>(addonGroupIds).size();\r\n                })\r\n                .count();\r\n\r\n        if (duplicateCount > 0) {\r\n            throw new DuplicateRecordException(\"One or more product variations has duplicate addon group IDs\");\r\n        }\r\n\r\n        // Collect all addon group IDs from the variations in the saveProductRequestDTO\r\n        List<Long> allAddonGroupIdsFromVariations = saveProductRequestDTO.getVariations().stream()\r\n                .flatMap(variation -> variation.getAddonGroupIds().stream())\r\n                .toList();\r\n\r\n        // Create a set of unique addon group IDs for validation\r\n        Set<Long> addonGroupIdSet = new HashSet<>(allAddonGroupIdsFromVariations);\r\n\r\n        // Fetch all required ProductAddonGroups and map them by their ID\r\n        Map<Long, AddonGroup> productAddonGroupMap = addonGroupRepository.findAllById(addonGroupIdSet).stream()\r\n                .collect(Collectors.toMap(AddonGroup::getAddonGroupId, productAddonGroup -> productAddonGroup));\r\n\r\n        // Check if all addon groups are found; throw exception if any are missing\r\n        if (productAddonGroupMap.size() != addonGroupIdSet.size()) {\r\n            throw new RecordNotFoundException(\"Some addon groups were not found\");\r\n        }\r\n\r\n        // Create a list of VariationRelation for creating\r\n        Set<VariationRelation> variationRelations = saveProductRequestDTO.getVariations().stream()\r\n                .map(saveVariationRelationRequestDTO -> {\r\n                    Long variationId = saveVariationRelationRequestDTO.getId();\r\n                    Variation variation = productVariationMap.get(variationId);\r\n\r\n                    // Map addon group IDs to AddonGroup objects\r\n                    Set<AddonGroup> addonGroups = saveVariationRelationRequestDTO.getAddonGroupIds().stream()\r\n                            .map(productAddonGroupMap::get)\r\n                            .collect(Collectors.toSet());\r\n\r\n                    // Create a new VariationRelation and set its properties\r\n                    VariationRelation variationRelation = new VariationRelation();\r\n                    variationRelation.setProduct(product);\r\n                    variationRelation.setVariation(variation);\r\n\r\n                    // Update the variationRelation with new details\r\n                    variationRelation.setContainerCharges(saveVariationRelationRequestDTO.getContainerCharges());\r\n                    variationRelation.setProfitMargin(saveVariationRelationRequestDTO.getProfitMargin());\r\n                    variationRelation.setItemBasePrice(saveVariationRelationRequestDTO.getItemBasePrice());\r\n                    variationRelation.setWeightOrVolume(saveVariationRelationRequestDTO.getWeightOrVolume());\r\n                    variationRelation.setServes(saveVariationRelationRequestDTO.getServes());\r\n                    variationRelation.setSapCode(saveVariationRelationRequestDTO.getSapCode());\r\n                    variationRelation.setAddonGroups(addonGroups);\r\n\r\n                    return variationRelation;\r\n                })\r\n                .collect(Collectors.toSet());\r\n\r\n        // Clear Existing ProductVariationRelations and Add new ProductVariationRelations\r\n        // All the (addon group - product variation relation) associations will be removed and added again.\r\n        product.getVariationRelations().clear();\r\n        product.getVariationRelations().addAll(variationRelations);\r\n\r\n        // Save/Update The Product\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        Product savedOrUpdatedProduct = productRepository.save(product);\r\n        watch.stop();\r\n        log.info(\"ProductServiceImpl::saveOrUpdateVariableProduct -> Product Saved/Updated with Product Id : {}, Query execution time: {}\", savedOrUpdatedProduct.getProductId(), watch.getTotalTimeSeconds());\r\n\r\n        // Map to SaveProductResponseDTO\r\n        SaveProductResponseDTO saveProductResponseDTO = mapper.map(savedOrUpdatedProduct, SaveProductResponseDTO.class);\r\n        saveProductResponseDTO.setId(savedOrUpdatedProduct.getProductId());\r\n        saveProductResponseDTO.setProductName(savedOrUpdatedProduct.getName());\r\n\r\n        // Set Category Group in response\r\n        SaveCategoryResponseDTO saveCategoryResponseDTO = new SaveCategoryResponseDTO();\r\n        saveCategoryResponseDTO.setId(savedOrUpdatedProduct.getCategory().getCategoryId());\r\n        saveCategoryResponseDTO.setName(savedOrUpdatedProduct.getCategory().getName());\r\n        saveProductResponseDTO.setCategoryGroup(saveCategoryResponseDTO);\r\n\r\n        // Map ProductVariationRelations to SavedVariationRelationResponseDTO\r\n\r\n        List<SavedVariationRelationResponseDTO> savedVariationRelationResponseDTOS = savedOrUpdatedProduct.getVariationRelations().stream()\r\n                .map(productVariationRelation -> {\r\n\r\n                    // Map AddonGroup entities to SavedProductProductAddonGroupResponseDTO\r\n                    List<SaveAddonGroupResponseDTO> saveAddonGroupResponseDTOList = productVariationRelation.getAddonGroups().stream()\r\n                            .map(productAddonGroup -> SaveAddonGroupResponseDTO.builder()\r\n                                    .id(productAddonGroup.getAddonGroupId())\r\n                                    .name(productAddonGroup.getName())\r\n                                    .build())\r\n                            .collect(Collectors.toList());\r\n\r\n                    // Build and return SavedVariationRelationResponseDTO\r\n                    return SavedVariationRelationResponseDTO.builder()\r\n                            .id(productVariationRelation.getVariation().getVariationId())\r\n                            .itemBasePrice(productVariationRelation.getItemBasePrice())\r\n                            .profitMargin(productVariationRelation.getProfitMargin())\r\n                            .addonGroups(saveAddonGroupResponseDTOList)\r\n                            .build();\r\n                })\r\n                .collect(Collectors.toList());\r\n        // Set Product Variation Relations in response\r\n        saveProductResponseDTO.setVariations(savedVariationRelationResponseDTOS);\r\n\r\n        return saveProductResponseDTO;\r\n    }\r\n\r\n    private ProductResponseDTO getProductsResponse(ProductQueryRequestDTO productQueryRequestDTO, Boolean includeLimit) throws RecordNotFoundException {\r\n        log.info(\"ProductServiceImpl::getProductsResponse\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<ProductQueryOutputDTO> productQueryOutputDTOList = productRepository.findAllProducts(\r\n                productQueryRequestDTO,\r\n                includeLimit\r\n        );\r\n        watch.stop();\r\n\r\n        // This will throw a RecordNotFound exception when no data found for the export related scenarios\r\n        if (!includeLimit) {\r\n            CommonUtils.validateRecordsNotFound(productQueryOutputDTOList, \"ProductQueryOutputDTO\");\r\n        }\r\n\r\n        long totalRecords = productQueryOutputDTOList.isEmpty() ? 0 : productQueryOutputDTOList.get(0).getTotalRecords();\r\n        ProductResponseDTO productResponseDTO = new ProductResponseDTO();\r\n        productResponseDTO.setTotalRecords((int) totalRecords);\r\n        productResponseDTO.setOffset(productQueryRequestDTO.getOffset());\r\n        productResponseDTO.setLimit(productQueryRequestDTO.getLimit());\r\n        productResponseDTO.setProducts(productQueryOutputDTOList);\r\n\r\n        log.info(\r\n                \"ProductServiceImpl::getProductsResponse -> Query execution time: {}, Number of products: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                productResponseDTO.getProducts().size(),\r\n                productResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return productResponseDTO;\r\n    }\r\n}"
    },
    {
        "file_name": "TagServiceImpl.java",
        "java_code": "package com.icieos.pos.restaurant.service.product.impl;\r\n\r\nimport com.icieos.pos.restaurant.dto.ResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.DeleteByIdsRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.tag.*;\r\nimport com.icieos.pos.restaurant.entity.product.Product;\r\nimport com.icieos.pos.restaurant.entity.product.Tag;\r\nimport com.icieos.pos.restaurant.repository.product.ProductRepository;\r\nimport com.icieos.pos.restaurant.repository.product.TagRepository;\r\nimport com.icieos.pos.restaurant.service.exception.*;\r\nimport com.icieos.pos.restaurant.service.product.TagService;\r\nimport com.icieos.pos.restaurant.util.CommonUtils;\r\nimport com.icieos.pos.restaurant.util.ValidationUtils;\r\nimport com.icieos.pos.restaurant.util.excel.exportdata.ExportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportTemplates;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.ss.usermodel.Cell;\r\nimport org.modelmapper.ModelMapper;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.util.StopWatch;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.stream.Collectors;\r\n\r\nimport static com.icieos.pos.restaurant.util.excel.importdata.Validators.isExcelFile;\r\n\r\n@Service\r\n@Slf4j\r\npublic class TagServiceImpl implements TagService {\r\n\r\n    private final TagRepository tagRepository;\r\n    private final ModelMapper mapper;\r\n\r\n    public TagServiceImpl(TagRepository tagRepository, ModelMapper modelMapper) {\r\n        this.tagRepository = tagRepository;\r\n        this.mapper = modelMapper;\r\n    }\r\n\r\n    @Override\r\n    public TagResponseDTO createOrUpdateTag(TagRequestDTO tagRequestDTO, Long tagId) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"TagServiceImpl::createOrUpdateTag\");\r\n\r\n        Tag tag;\r\n        boolean isExistsProductTag = tagRepository.existsByNameIgnoreCase(tagRequestDTO.getName());\r\n        if (tagId != null) {\r\n\r\n            // Check if the Product Tag exists\r\n            tag = tagRepository.findById(tagId)\r\n                    .orElseThrow(() -> new RecordNotFoundException(\"Product tag with ID \" + tagId + \" not found\"));\r\n\r\n            // Check if the new tag name already exists(excluding the current tag)\r\n            if (isExistsProductTag && !tag.getName().equalsIgnoreCase(tagRequestDTO.getName())) {\r\n                throw new DuplicateRecordException(\"Product tag already exists\");\r\n            }\r\n\r\n            mapper.map(tagRequestDTO, tag);\r\n        } else {\r\n            if (isExistsProductTag) {\r\n                throw new DuplicateRecordException(\"Product tag already exists\");\r\n            }\r\n\r\n            tag = mapper.map(tagRequestDTO, Tag.class);\r\n        }\r\n        tag = tagRepository.save(tag);\r\n        return mapper.map(tag, TagResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public TagResponseDTO findTagById(Long id) throws RecordNotFoundException {\r\n        log.info(\"TagServiceImpl::findTagById\");\r\n\r\n        Tag tag = tagRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"ProductTag not found\"));\r\n\r\n        return mapper.map(tag, TagResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public TagListResponseDTO findAllTags(TagQueryRequestDTO tagQueryRequestDTO) throws RecordNotFoundException {\r\n        log.info(\"TagServiceImpl::findAllTags\");\r\n\r\n        return getTagsResponse(tagQueryRequestDTO, true);\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO deleteTagById(Long id) throws RecordNotFoundException {\r\n        log.info(\"TagServiceImpl::deleteTagById\");\r\n\r\n        // Fetch the Tag by ID or throw an exception if not found\r\n        Tag tag = tagRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Tag not found\"));\r\n\r\n        // Update this\r\n        List<Product> productsToUpdate = new ArrayList<>(tag.getProducts());\r\n        if (!productsToUpdate.isEmpty()) {\r\n            // Remove the association between the tag and the products\r\n            productsToUpdate.forEach(product -> product.getTags().remove(tag));\r\n            tag.getProducts().clear();\r\n            log.info(\"TagServiceImpl::deleteTag -> Save all products after disassociation Product Tag id : {}\", id);\r\n        }\r\n\r\n        // Delete the Product tag\r\n        tagRepository.delete(tag);\r\n\r\n        // Return a success response\r\n        return new ResponseDTO(String.format(\"Tag with id %d deleted successfully\", id));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteTagsByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO)\r\n            throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"TagServiceImpl::deleteTagsByIds\");\r\n\r\n        // Extract tag IDs from the requestDTO\r\n        List<Long> tagsIdList = deleteByIdsRequestDTO.getIdList();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(tagsIdList, \"Duplicate Tag IDs in the request\");\r\n\r\n        // Find the ProductTags by their IDs\r\n        List<Tag> tagsToDelete = tagRepository.findAllById(tagsIdList);\r\n\r\n        // Check if all tags were found\r\n        if (tagsToDelete.size() != tagsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some tags were not found\");\r\n        }\r\n\r\n        // Remove relationships with products\r\n        tagsToDelete.forEach(tag -> {\r\n            Set<Product> associatedProducts = tag.getProducts();\r\n            if (associatedProducts != null && !associatedProducts.isEmpty()) {\r\n                associatedProducts.forEach(product -> product.getTags().remove(tag));\r\n                tag.getProducts().clear(); // Clear the relationship in the tag\r\n            }\r\n        });\r\n\r\n        // Delete the tags\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        tagRepository.deleteAll(tagsToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\"TagServiceImpl::deleteTagsByIds -> Query execution time: {}\", watch.getTotalTimeSeconds());\r\n\r\n        return new ResponseDTO(\"Product tags deleted successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"TagServiceImpl::generateImportTemplate\");\r\n\r\n        return new InputStreamResource(ImportTemplates.generateTagImportTemplate());\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO importTags(MultipartFile tagExcelFile) throws IOException, DuplicateRecordException, InvalidFileTypeException, BadRequestException, ExcelDTOMappingValidationException, FileNotFoundCustomException, RecordNotFoundException {\r\n        log.info(\"ProductTagServiceImpl::importTags\");\r\n\r\n        // Check if file is provided and not empty\r\n        if (tagExcelFile == null || tagExcelFile.isEmpty()) {\r\n            throw new FileNotFoundCustomException(\"No file uploaded or the file is empty\");\r\n        }\r\n\r\n        // Validate file type\r\n        if (!isExcelFile(tagExcelFile)) {\r\n            throw new InvalidFileTypeException(\"Invalid file format. Please upload an Excel file.\");\r\n        }\r\n\r\n        // Existing tag names for checking duplications\r\n        Set<String> existProductTagNames = tagRepository.findAllTagNames();\r\n\r\n        // Util Method: Returns List TagRequestDTO from Excel after mapping\r\n        List<TagRequestDTO> tagRequestDTOList = ImportData.convertExcelToTagDTO(tagExcelFile, existProductTagNames);\r\n\r\n        // Map to entity list for saving\r\n        List<Tag> tagsList = tagRequestDTOList.stream()\r\n                .map(tagDto -> mapper.map(tagDto, Tag.class))\r\n                .collect(Collectors.toList());\r\n\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<Tag> savedTags = tagRepository.saveAll(tagsList);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ProductTagServiceImpl::importTags -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                savedTags.size()\r\n        );\r\n        return new ResponseDTO(\"File processed and Tags saved successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportTags(TagQueryRequestDTO tagQueryRequestDTO) throws IOException, RecordNotFoundException {\r\n        log.info(\"TagServiceImpl::exportProductTags\");\r\n\r\n        // Fetching product tags based on the query\r\n        TagListResponseDTO tagListResponseDTO = getTagsResponse(tagQueryRequestDTO, tagQueryRequestDTO.getIncludeLimit());\r\n\r\n        return new InputStreamResource(ExportData.exportTags(tagListResponseDTO.getTags()));\r\n    }\r\n\r\n    private TagListResponseDTO getTagsResponse(TagQueryRequestDTO tagQueryRequestDTO, Boolean includeLimit) throws RecordNotFoundException {\r\n        log.info(\"TagServiceImpl::getTagsResponse\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<TagQueryOutputDTO> tagQueryOutputDTOList = tagRepository.findAllTags(tagQueryRequestDTO, includeLimit);\r\n        watch.stop();\r\n\r\n        // This will throw a RecordNotFound exception when no data found for the export related scenarios\r\n        if (!includeLimit) {\r\n            CommonUtils.validateRecordsNotFound(tagQueryOutputDTOList, \"TagQueryOutputDTO\");\r\n        }\r\n\r\n        long totalRecords = tagQueryOutputDTOList.isEmpty() ? 0 : tagQueryOutputDTOList.get(0).getTotalRecords();\r\n\r\n        TagListResponseDTO tagListResponseDTO = new TagListResponseDTO();\r\n        tagListResponseDTO.setTotalRecords((int) totalRecords);\r\n        tagListResponseDTO.setOffset(tagQueryRequestDTO.getOffset());\r\n        tagListResponseDTO.setLimit(tagQueryRequestDTO.getLimit());\r\n        tagListResponseDTO.setTags(tagQueryOutputDTOList);\r\n\r\n        log.info(\"TagServiceImpl::getTagsResponse -> Query execution time: {}, Number of tags: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                tagListResponseDTO.getTags().size(),\r\n                tagListResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return tagListResponseDTO;\r\n    }\r\n}"
    },
    {
        "file_name": "VariationServiceImpl.java",
        "java_code": "package com.icieos.pos.restaurant.service.product.impl;\r\n\r\nimport com.icieos.pos.restaurant.dto.ResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.DeleteByIdsRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.SetAvailabilityStatusRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.variation.*;\r\nimport com.icieos.pos.restaurant.entity.product.Variation;\r\nimport com.icieos.pos.restaurant.repository.product.VariationRelationRepository;\r\nimport com.icieos.pos.restaurant.service.exception.*;\r\nimport com.icieos.pos.restaurant.service.product.VariationService;\r\nimport com.icieos.pos.restaurant.repository.product.VariationRepository;\r\nimport com.icieos.pos.restaurant.util.CommonUtils;\r\nimport com.icieos.pos.restaurant.util.ValidationUtils;\r\nimport com.icieos.pos.restaurant.util.excel.exportdata.ExportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportTemplates;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.ss.usermodel.Cell;\r\nimport org.modelmapper.ModelMapper;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.util.StopWatch;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.stream.Collectors;\r\n\r\nimport static com.icieos.pos.restaurant.util.excel.importdata.Validators.isExcelFile;\r\n\r\n@Service\r\n@Slf4j\r\npublic class VariationServiceImpl extends VariationService {\r\n    private final VariationRepository variationRepository;\r\n    private final VariationRelationRepository variationRelationRepository;\r\n\r\n    private final ModelMapper mapper;\r\n\r\n    public VariationServiceImpl(VariationRepository variationRepository, VariationRelationRepository variationRelationRepository, ModelMapper mapper) {\r\n        this.variationRepository = variationRepository;\r\n        this.variationRelationRepository = variationRelationRepository;\r\n        this.mapper = mapper;\r\n    }\r\n\r\n\r\n    @Override\r\n    public VariationResponseDTO createOrUpdateVariation(VariationRequestDTO variationRequestDTO, Long variationId) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"VariationServiceImpl::createOrUpdateVariation\");\r\n\r\n        Variation variation;\r\n        boolean isExistsVariation = variationRepository.existsByNameIgnoreCase(variationRequestDTO.getName());\r\n        if (variationId != null) {\r\n\r\n            // Check if the variation exists\r\n            variation = variationRepository.findById(variationId)\r\n                    .orElseThrow(() -> new RecordNotFoundException(\"Variation with ID \" + variationId + \" not found\"));\r\n\r\n            // Check if the new variation name already exists(excluding the current variation)\r\n            if (isExistsVariation && !variation.getName().equalsIgnoreCase(variationRequestDTO.getName())) {\r\n                throw new DuplicateRecordException(\"Variation already exists\");\r\n            }\r\n\r\n            mapper.map(variationRequestDTO, variation);\r\n        } else {\r\n            if (isExistsVariation) {\r\n                throw new DuplicateRecordException(\"Variation already exists\");\r\n            }\r\n\r\n            variation = mapper.map(variationRequestDTO, Variation.class);\r\n        }\r\n        variation = variationRepository.save(variation);\r\n        return mapper.map(variation, VariationResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public VariationResponseDTO updateAvailabilityStatusById(Long id, Boolean available) throws RecordNotFoundException {\r\n        log.info(\"VariationServiceImpl::updateAvailabilityStatusById\");\r\n\r\n        Variation variation = variationRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Variation not found\"));\r\n\r\n        // Get status from the request body and update it here.\r\n        if (available != null) {\r\n            variation.setAvailabilityStatus(available);\r\n            variation = variationRepository.save(variation);\r\n        }\r\n\r\n        return mapper.map(variation, VariationResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO updateAvailabilityStatusByIds(SetAvailabilityStatusRequestDTO setAvailabilityStatusRequestDTO)\r\n            throws RecordNotFoundException, DuplicateRecordException {\r\n        log.info(\"VariationServiceImpl::updateAvailabilityStatusByIds\");\r\n\r\n        List<Long> variationsIdList = setAvailabilityStatusRequestDTO.getIdList();\r\n        Boolean availabilityStatus = setAvailabilityStatusRequestDTO.getAvailabilityStatus();\r\n\r\n        // Check for duplicate variation IDs in the request\r\n        ValidationUtils.checkForDuplicates(variationsIdList, \"Duplicate variation IDs in the request\");\r\n\r\n        // Fetch variations by IDs\r\n        List<Variation> variationsToUpdate = variationRepository.findAllById(variationsIdList);\r\n\r\n        // Check if all requested variations exist\r\n        if (variationsToUpdate.size() != variationsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some variations were not found\");\r\n        }\r\n\r\n        // Filter only those variations where the availability status differs\r\n        List<Variation> filteredVariationsToUpdate = variationsToUpdate.stream()\r\n                .filter(variation -> !availabilityStatus.equals(variation.getAvailabilityStatus()))\r\n                .peek(variation -> variation.setAvailabilityStatus(availabilityStatus)).collect(Collectors.toList());\r\n\r\n        // Save only the filtered variations\r\n        if (!filteredVariationsToUpdate.isEmpty()) {\r\n            StopWatch watch = new StopWatch();\r\n            watch.start();\r\n            List<Variation> updatedVariations = variationRepository.saveAll(filteredVariationsToUpdate);\r\n            watch.stop();\r\n\r\n            log.info(\"VariationServiceImpl::setAvailabilityStatusByIds -> Query execution time: {}, Total records updated: {}\",\r\n                    watch.getTotalTimeSeconds(), updatedVariations.size());\r\n        } else {\r\n            log.info(\"VariationServiceImpl::setAvailabilityStatusByIds -> No variations had a change in availability status.\");\r\n        }\r\n\r\n        return new ResponseDTO(\"Availability status updated successfully for variations.\");\r\n    }\r\n\r\n    @Override\r\n    public VariationResponseDTO findVariationById(Long id) throws RecordNotFoundException {\r\n        log.info(\"VariationServiceImpl::findVariationById\");\r\n\r\n        Variation variation = variationRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Variation not found\"));\r\n\r\n        return mapper.map(variation, VariationResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public VariationListResponseDTO findAllVariations(VariationQueryRequestDTO variationQueryRequestDTO) throws RecordNotFoundException {\r\n        log.info(\"VariationServiceImpl::findAllVariations\");\r\n\r\n        return getVariationsResponse(\r\n                variationQueryRequestDTO,\r\n                true\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO deleteVariationById(Long id) throws RecordNotFoundException, DeletionBlockedByRelatedRecordsException {\r\n        log.info(\"VariationServiceImpl::deleteVariationById\");\r\n\r\n        // Fetch the variation by ID\r\n        Variation variation = variationRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Variation not found\"));\r\n\r\n        // Check if there are any associations with products\r\n        boolean hasAssociations = variationRelationRepository.existsByVariation(variation);\r\n\r\n        if (hasAssociations) {\r\n            // Prevent deletion if associations exist\r\n            throw new DeletionBlockedByRelatedRecordsException(\"Cannot delete variation as it has associated products.\");\r\n        }\r\n\r\n        // If no associations, proceed with deletion\r\n        variationRepository.delete(variation);\r\n\r\n        return new ResponseDTO(String.format(\"Variation with id %d deleted successfully\", id));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteVariationsByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO)\r\n            throws RecordNotFoundException, DeletionBlockedByRelatedRecordsException, DuplicateRecordException {\r\n        log.info(\"VariationServiceImpl::deleteVariationsByIds\");\r\n\r\n        // Change getVariations to getVariationsIds\r\n        List<Long> variationsIdList = deleteByIdsRequestDTO.getIdList();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(variationsIdList, \"Duplicate variation IDs in the request\");\r\n\r\n        // Find all variations by their IDs\r\n        List<Variation> variationsToDelete = variationRepository.findAllById(variationsIdList);\r\n\r\n        // Verify if all requested IDs exist\r\n        if (variationsToDelete.size() != variationsIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some variations were not found\");\r\n        }\r\n\r\n        // Check for associated products using streams and throw an exception immediately if any found\r\n        boolean hasAssociatedProducts = variationsToDelete.stream()\r\n                .anyMatch(variation -> variation.getVariationRelations() != null && !variation.getVariationRelations().isEmpty());\r\n\r\n        if (hasAssociatedProducts) {\r\n            throw new DeletionBlockedByRelatedRecordsException(\"Cannot delete variations that have associated products.\");\r\n        }\r\n\r\n        // Proceed with deleting variations\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        variationRepository.deleteAll(variationsToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"VariationServiceImpl::deleteVariationByIds -> Query execution time: {}\", watch.getTotalTimeSeconds()\r\n        );\r\n\r\n        return new ResponseDTO(\"Variations deleted successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"VariationServiceImpl::generateImportTemplate\");\r\n        return new InputStreamResource(ImportTemplates.generateVariationImportTemplate());\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO importVariations(MultipartFile variationExcelFile)\r\n            throws IOException, DuplicateRecordException, ExcelDTOMappingValidationException, InvalidFileTypeException, BadRequestException, RecordNotFoundException, FileNotFoundCustomException {\r\n        log.info(\"VariationServiceImpl::importVariations\");\r\n\r\n        // Check if file is provided and not empty\r\n        if (variationExcelFile == null || variationExcelFile.isEmpty()) {\r\n            throw new FileNotFoundCustomException(\"No file uploaded or the file is empty\");\r\n        }\r\n\r\n        // Validate file type\r\n        if (!isExcelFile(variationExcelFile)) {\r\n            throw new InvalidFileTypeException(\"Invalid file format. Please upload an Excel file.\");\r\n        }\r\n\r\n        // Existing Variation names for checking duplications\r\n        Set<String> existingVariationNames = variationRepository.findAllVariationNames();\r\n\r\n        // Util Method: Returns List VariationRequestDTO from Excel after mapping\r\n        List<VariationRequestDTO> variationRequestDTOList = ImportData.convertExcelToVariationDTO(variationExcelFile, existingVariationNames);\r\n\r\n        // Map to entity list for saving\r\n        List<Variation> variations = variationRequestDTOList.stream()\r\n                .map(variationDto -> mapper.map(variationDto, Variation.class))\r\n                .toList();\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<Variation> savedVariations = variationRepository.saveAll(variations);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"VariationServiceImpl::importVariations -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                savedVariations.size()\r\n        );\r\n        return new ResponseDTO(\"File processed and variations saved successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportVariations(VariationQueryRequestDTO requestDTO) throws RecordNotFoundException, IOException {\r\n        log.info(\"VariationServiceImpl::exportVariations\");\r\n\r\n        // Fetching variations based on the query\r\n        VariationListResponseDTO variationListResponseDTO = getVariationsResponse(requestDTO, requestDTO.getIncludeLimit());\r\n\r\n        return new InputStreamResource(ExportData.exportVariations(variationListResponseDTO.getVariations()));\r\n    }\r\n\r\n    private VariationListResponseDTO getVariationsResponse(VariationQueryRequestDTO variationQueryRequestDTO, Boolean includeLimit) throws RecordNotFoundException {\r\n        log.info(\"VariationServiceImpl::getVariationsResponse\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<VariationQueryOutputDTO> variationQueryOutputDTOList = variationRepository.findAllVariations(\r\n                variationQueryRequestDTO,\r\n                includeLimit\r\n        );\r\n        watch.stop();\r\n\r\n        // This will throw a RecordNotFound exception when no data found for the export related scenarios\r\n        if (!includeLimit) {\r\n            CommonUtils.validateRecordsNotFound(variationQueryOutputDTOList, \"VariationQueryOutputDTO\");\r\n        }\r\n\r\n        long totalRecords = variationQueryOutputDTOList.isEmpty() ? 0 : variationQueryOutputDTOList.get(0).getTotalRecords();\r\n\r\n        VariationListResponseDTO variationListResponseDTO = new VariationListResponseDTO();\r\n        variationListResponseDTO.setTotalRecords((int) totalRecords);\r\n        variationListResponseDTO.setOffset(variationQueryRequestDTO.getOffset());\r\n        variationListResponseDTO.setLimit(variationQueryRequestDTO.getLimit());\r\n        variationListResponseDTO.setVariations(variationQueryOutputDTOList);\r\n\r\n        log.info(\r\n                \"VariationServiceImpl::variationListResponseDTO -> Query execution time: {}, Number of variations: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                variationListResponseDTO.getVariations().size(),\r\n                variationListResponseDTO.getTotalRecords()\r\n        );\r\n\r\n        return variationListResponseDTO;\r\n    }\r\n}"
    },
    {
        "file_name": "ScheduleServiceImpl.java",
        "java_code": "package com.icieos.pos.restaurant.service.product.impl;\r\n\r\nimport com.icieos.pos.restaurant.dto.ResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.DeleteByIdsRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.schedule.*;\r\nimport com.icieos.pos.restaurant.entity.product.Schedule;\r\nimport com.icieos.pos.restaurant.repository.product.CategoryRepository;\r\nimport com.icieos.pos.restaurant.repository.product.ScheduleRepository;\r\nimport com.icieos.pos.restaurant.service.exception.*;\r\nimport com.icieos.pos.restaurant.service.product.ScheduleService;\r\nimport com.icieos.pos.restaurant.util.ValidationUtils;\r\nimport com.icieos.pos.restaurant.util.excel.exportdata.ExportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportTemplates;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.ss.usermodel.Cell;\r\nimport org.modelmapper.ModelMapper;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.util.StopWatch;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.util.List;\r\n\r\nimport static com.icieos.pos.restaurant.util.excel.importdata.Validators.isExcelFile;\r\n\r\n@Service\r\n@Slf4j\r\npublic class ScheduleServiceImpl implements ScheduleService {\r\n\r\n    private final ScheduleRepository scheduleRepository;\r\n    private final CategoryRepository categoryRepository;\r\n\r\n    private final ModelMapper mapper;\r\n\r\n    public ScheduleServiceImpl(ScheduleRepository scheduleRepository, CategoryRepository categoryRepository, ModelMapper modelMapper) {\r\n        this.scheduleRepository = scheduleRepository;\r\n        this.categoryRepository = categoryRepository;\r\n        this.mapper = modelMapper;\r\n    }\r\n\r\n    @Override\r\n    public ScheduleResponseDTO createOrUpdateSchedule(ScheduleRequestDTO scheduleRequestDTO, Long scheduleId) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ScheduleServiceImpl::createOrUpdateSchedule\");\r\n\r\n        Schedule schedule;\r\n        boolean isExistsSchedule = scheduleRepository.existsByNameIgnoreCase(scheduleRequestDTO.getName());\r\n        if (scheduleId != null) {\r\n\r\n            // Check if the schedule exists\r\n            schedule = scheduleRepository.findById(scheduleId)\r\n                    .orElseThrow(() -> new RecordNotFoundException(\"Schedule with ID \" + scheduleId + \" not found\"));\r\n\r\n            // Check if the new schedule name already exists(excluding the current schedule)\r\n            if (isExistsSchedule && !schedule.getName().equalsIgnoreCase(scheduleRequestDTO.getName())) {\r\n                throw new DuplicateRecordException(\"Schedule already exists\");\r\n            }\r\n\r\n            mapper.map(scheduleRequestDTO, schedule);\r\n        } else {\r\n            if (isExistsSchedule) {\r\n                throw new DuplicateRecordException(\"Schedule already exists\");\r\n            }\r\n\r\n            schedule = mapper.map(scheduleRequestDTO, Schedule.class);\r\n        }\r\n        schedule = scheduleRepository.save(schedule);\r\n        return mapper.map(schedule, ScheduleResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public ScheduleResponseDTO findScheduleById(Long id) throws RecordNotFoundException {\r\n        log.info(\"ScheduleServiceImpl::findScheduleById\");\r\n\r\n        Schedule schedule = scheduleRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Schedule not found\"));\r\n\r\n        return mapper.map(schedule, ScheduleResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public ScheduleListResponseDTO findAllSchedules() {\r\n        log.info(\"ScheduleServiceImpl::findAllSchedules\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<ScheduleQueryOutputDTO> scheduleQueryOutputDTOList = scheduleRepository.findAllSchedules();\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ScheduleServiceImpl::findAllSchedules -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                scheduleQueryOutputDTOList.size()\r\n        );\r\n\r\n        ScheduleListResponseDTO scheduleListResponseDTO = new ScheduleListResponseDTO();\r\n        scheduleListResponseDTO.setSchedules(scheduleQueryOutputDTOList);\r\n\r\n        return scheduleListResponseDTO;\r\n    }\r\n\r\n    // Change name to deleteScheduleById\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteScheduleById(Long id) throws RecordNotFoundException, DeletionBlockedByRelatedRecordsException {\r\n        log.info(\"ScheduleServiceImpl::deleteScheduleById\");\r\n\r\n        // Find the Schedule by ID\r\n        Schedule schedule = scheduleRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Schedule not found\"));\r\n\r\n        // Compare this with deleteSchedulesByIds. (hasAssociatedCategories)\r\n        boolean hasAssociatedCategories = categoryRepository.existsBySchedulesContaining(schedule);\r\n\r\n        if (hasAssociatedCategories) {\r\n            // If there are associated categories, prevent deletion\r\n            throw new DeletionBlockedByRelatedRecordsException(\"There are some Categories associated with this schedule.\");\r\n        }\r\n        // No associations, proceed with deletion\r\n        scheduleRepository.delete(schedule);\r\n\r\n        return new ResponseDTO(String.format(\"Schedule with id %d deleted successfully\", id));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteSchedulesByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO)\r\n            throws RecordNotFoundException, DeletionBlockedByRelatedRecordsException, DuplicateRecordException {\r\n        log.info(\"ScheduleServiceImpl::deleteSchedulesByIds\");\r\n\r\n        List<Long> schedulesIdList = deleteByIdsRequestDTO.getIdList();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(schedulesIdList, \"Duplicate schedule IDs in the request\");\r\n\r\n        // Find all schedules by their IDs\r\n        List<Schedule> schedulesToDelete = scheduleRepository.findAllById(schedulesIdList);\r\n\r\n        // Verify if all requested IDs exist\r\n        if (schedulesToDelete.size() != schedulesIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some schedules were not found\");\r\n        }\r\n\r\n        // Check for associated categories using streams and throw an exception immediately if any found\r\n        // Compare this with deleteSchedule. (hasAssociatedCategories)\r\n        boolean hasAssociatedCategories = schedulesToDelete.stream()\r\n                .anyMatch(schedule -> schedule.getCategories() != null && !schedule.getCategories().isEmpty());\r\n\r\n        if (hasAssociatedCategories) {\r\n            throw new DeletionBlockedByRelatedRecordsException(\r\n                    \"Cannot delete schedules that have associated categories.\"\r\n            );\r\n        }\r\n\r\n        // Proceed with deleting schedules\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        scheduleRepository.deleteAll(schedulesToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ScheduleServiceImpl::deleteSchedulesByIds -> Query execution time: {}\",\r\n                watch.getTotalTimeSeconds()\r\n        );\r\n\r\n        return new ResponseDTO(\"Schedules deleted successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"ScheduleServiceImpl::generateImportTemplate\");\r\n\r\n        return new InputStreamResource(ImportTemplates.generateScheduleImportTemplate());\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO importSchedules(MultipartFile scheduleExcelFile) throws FileNotFoundCustomException, InvalidFileTypeException, BadRequestException, ExcelDTOMappingValidationException, IOException, DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ScheduleServiceImpl::importSchedules\");\r\n\r\n        // Check if file is provided and not empty\r\n        if (scheduleExcelFile == null || scheduleExcelFile.isEmpty()) {\r\n            throw new FileNotFoundCustomException(\"No file uploaded or the file is empty\");\r\n        }\r\n        // Validate file type\r\n        if (!isExcelFile(scheduleExcelFile)) {\r\n            throw new InvalidFileTypeException(\"Invalid file format. Please upload an Excel file.\");\r\n        }\r\n        List<Schedule> existingSchedules = scheduleRepository.findAll();\r\n\r\n        // Util Method: Returns List ScheduleRequestDTO from Excel after mapping\r\n        List<ScheduleRequestDTO> scheduleRequestDTOList = ImportData.convertExcelToScheduleDTO(scheduleExcelFile, existingSchedules);\r\n\r\n        // Map DTOs to Entities\r\n        List<Schedule> scheduleList = scheduleRequestDTOList.stream()\r\n                .map(scheduleRequestDTO ->\r\n                        mapper.map(scheduleRequestDTO, Schedule.class))\r\n                .toList();\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<Schedule> savedSchedules = scheduleRepository.saveAll(scheduleList);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ScheduleServiceImpl::saveSchedulesFromExcelFile -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                savedSchedules.size()\r\n        );\r\n\r\n        return new ResponseDTO(\"File processed and schedules saved successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportSchedules() throws IOException {\r\n        log.info(\"ScheduleServiceImpl::exportSchedules\");\r\n\r\n        List<ScheduleQueryOutputDTO> scheduleQueryOutputDTOList = scheduleRepository.findAllSchedules();\r\n\r\n        return new InputStreamResource(ExportData.exportSchedules(scheduleQueryOutputDTOList));\r\n    }\r\n\r\n}"
    },
    {
        "file_name": "ScheduleServiceImpl.java",
        "java_code": "package com.icieos.pos.restaurant.service.product.impl;\r\n\r\nimport com.icieos.pos.restaurant.dto.ResponseDTO;\r\nimport com.icieos.pos.restaurant.dto.product.common.DeleteByIdsRequestDTO;\r\nimport com.icieos.pos.restaurant.dto.product.schedule.*;\r\nimport com.icieos.pos.restaurant.entity.product.Schedule;\r\nimport com.icieos.pos.restaurant.repository.product.CategoryRepository;\r\nimport com.icieos.pos.restaurant.repository.product.ScheduleRepository;\r\nimport com.icieos.pos.restaurant.service.exception.*;\r\nimport com.icieos.pos.restaurant.service.product.ScheduleService;\r\nimport com.icieos.pos.restaurant.util.ValidationUtils;\r\nimport com.icieos.pos.restaurant.util.excel.exportdata.ExportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportData;\r\nimport com.icieos.pos.restaurant.util.excel.importdata.ImportTemplates;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.ss.usermodel.Cell;\r\nimport org.modelmapper.ModelMapper;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.util.StopWatch;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.util.List;\r\n\r\nimport static com.icieos.pos.restaurant.util.excel.importdata.Validators.isExcelFile;\r\n\r\n@Service\r\n@Slf4j\r\npublic class ScheduleServiceImpl extends ScheduleService {\r\n\r\n    private final ScheduleRepository scheduleRepository;\r\n    private final CategoryRepository categoryRepository;\r\n\r\n    private final ModelMapper mapper;\r\n\r\n    public ScheduleServiceImpl(ScheduleRepository scheduleRepository, CategoryRepository categoryRepository, ModelMapper modelMapper) {\r\n        this.scheduleRepository = scheduleRepository;\r\n        this.categoryRepository = categoryRepository;\r\n        this.mapper = modelMapper;\r\n    }\r\n\r\n    @Override\r\n    public ScheduleResponseDTO createOrUpdateSchedule(ScheduleRequestDTO scheduleRequestDTO, Long scheduleId) throws DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ScheduleServiceImpl::createOrUpdateSchedule\");\r\n\r\n        Schedule schedule;\r\n        boolean isExistsSchedule = scheduleRepository.existsByNameIgnoreCase(scheduleRequestDTO.getName());\r\n        if (scheduleId != null) {\r\n\r\n            // Check if the schedule exists\r\n            schedule = scheduleRepository.findById(scheduleId)\r\n                    .orElseThrow(() -> new RecordNotFoundException(\"Schedule with ID \" + scheduleId + \" not found\"));\r\n\r\n            // Check if the new schedule name already exists(excluding the current schedule)\r\n            if (isExistsSchedule && !schedule.getName().equalsIgnoreCase(scheduleRequestDTO.getName())) {\r\n                throw new DuplicateRecordException(\"Schedule already exists\");\r\n            }\r\n\r\n            mapper.map(scheduleRequestDTO, schedule);\r\n        } else {\r\n            if (isExistsSchedule) {\r\n                throw new DuplicateRecordException(\"Schedule already exists\");\r\n            }\r\n\r\n            schedule = mapper.map(scheduleRequestDTO, Schedule.class);\r\n        }\r\n        schedule = scheduleRepository.save(schedule);\r\n        return mapper.map(schedule, ScheduleResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public ScheduleResponseDTO findScheduleById(Long id) throws RecordNotFoundException {\r\n        log.info(\"ScheduleServiceImpl::findScheduleById\");\r\n\r\n        Schedule schedule = scheduleRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Schedule not found\"));\r\n\r\n        return mapper.map(schedule, ScheduleResponseDTO.class);\r\n    }\r\n\r\n    @Override\r\n    public ScheduleListResponseDTO findAllSchedules() {\r\n        log.info(\"ScheduleServiceImpl::findAllSchedules\");\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<ScheduleQueryOutputDTO> scheduleQueryOutputDTOList = scheduleRepository.findAllSchedules();\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ScheduleServiceImpl::findAllSchedules -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                scheduleQueryOutputDTOList.size()\r\n        );\r\n\r\n        ScheduleListResponseDTO scheduleListResponseDTO = new ScheduleListResponseDTO();\r\n        scheduleListResponseDTO.setSchedules(scheduleQueryOutputDTOList);\r\n\r\n        return scheduleListResponseDTO;\r\n    }\r\n\r\n    // Change name to deleteScheduleById\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteScheduleById(Long id) throws RecordNotFoundException, DeletionBlockedByRelatedRecordsException {\r\n        log.info(\"ScheduleServiceImpl::deleteScheduleById\");\r\n\r\n        // Find the Schedule by ID\r\n        Schedule schedule = scheduleRepository.findById(id)\r\n                .orElseThrow(() -> new RecordNotFoundException(\"Schedule not found\"));\r\n\r\n        // Compare this with deleteSchedulesByIds. (hasAssociatedCategories)\r\n        boolean hasAssociatedCategories = categoryRepository.existsBySchedulesContaining(schedule);\r\n\r\n        if (hasAssociatedCategories) {\r\n            // If there are associated categories, prevent deletion\r\n            throw new DeletionBlockedByRelatedRecordsException(\"There are some Categories associated with this schedule.\");\r\n        }\r\n        // No associations, proceed with deletion\r\n        scheduleRepository.delete(schedule);\r\n\r\n        return new ResponseDTO(String.format(\"Schedule with id %d deleted successfully\", id));\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public ResponseDTO deleteSchedulesByIds(DeleteByIdsRequestDTO deleteByIdsRequestDTO)\r\n            throws RecordNotFoundException, DeletionBlockedByRelatedRecordsException, DuplicateRecordException {\r\n        log.info(\"ScheduleServiceImpl::deleteSchedulesByIds\");\r\n\r\n        List<Long> schedulesIdList = deleteByIdsRequestDTO.getIdList();\r\n\r\n        // Check for duplicate IDs in the request\r\n        ValidationUtils.checkForDuplicates(schedulesIdList, \"Duplicate schedule IDs in the request\");\r\n\r\n        // Find all schedules by their IDs\r\n        List<Schedule> schedulesToDelete = scheduleRepository.findAllById(schedulesIdList);\r\n\r\n        // Verify if all requested IDs exist\r\n        if (schedulesToDelete.size() != schedulesIdList.size()) {\r\n            throw new RecordNotFoundException(\"Some schedules were not found\");\r\n        }\r\n\r\n        // Check for associated categories using streams and throw an exception immediately if any found\r\n        // Compare this with deleteSchedule. (hasAssociatedCategories)\r\n        boolean hasAssociatedCategories = schedulesToDelete.stream()\r\n                .anyMatch(schedule -> schedule.getCategories() != null && !schedule.getCategories().isEmpty());\r\n\r\n        if (hasAssociatedCategories) {\r\n            throw new DeletionBlockedByRelatedRecordsException(\r\n                    \"Cannot delete schedules that have associated categories.\"\r\n            );\r\n        }\r\n\r\n        // Proceed with deleting schedules\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        scheduleRepository.deleteAll(schedulesToDelete);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ScheduleServiceImpl::deleteSchedulesByIds -> Query execution time: {}\",\r\n                watch.getTotalTimeSeconds()\r\n        );\r\n\r\n        return new ResponseDTO(\"Schedules deleted successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource generateImportTemplate() throws IOException {\r\n        log.info(\"ScheduleServiceImpl::generateImportTemplate\");\r\n\r\n        return new InputStreamResource(ImportTemplates.generateScheduleImportTemplate());\r\n    }\r\n\r\n    @Override\r\n    public ResponseDTO importSchedules(MultipartFile scheduleExcelFile) throws FileNotFoundCustomException, InvalidFileTypeException, BadRequestException, ExcelDTOMappingValidationException, IOException, DuplicateRecordException, RecordNotFoundException {\r\n        log.info(\"ScheduleServiceImpl::importSchedules\");\r\n\r\n        // Check if file is provided and not empty\r\n        if (scheduleExcelFile == null || scheduleExcelFile.isEmpty()) {\r\n            throw new FileNotFoundCustomException(\"No file uploaded or the file is empty\");\r\n        }\r\n        // Validate file type\r\n        if (!isExcelFile(scheduleExcelFile)) {\r\n            throw new InvalidFileTypeException(\"Invalid file format. Please upload an Excel file.\");\r\n        }\r\n        List<Schedule> existingSchedules = scheduleRepository.findAll();\r\n\r\n        // Util Method: Returns List ScheduleRequestDTO from Excel after mapping\r\n        List<ScheduleRequestDTO> scheduleRequestDTOList = ImportData.convertExcelToScheduleDTO(scheduleExcelFile, existingSchedules);\r\n\r\n        // Map DTOs to Entities\r\n        List<Schedule> scheduleList = scheduleRequestDTOList.stream()\r\n                .map(scheduleRequestDTO ->\r\n                        mapper.map(scheduleRequestDTO, Schedule.class))\r\n                .toList();\r\n\r\n        StopWatch watch = new StopWatch();\r\n        watch.start();\r\n        List<Schedule> savedSchedules = scheduleRepository.saveAll(scheduleList);\r\n        watch.stop();\r\n\r\n        log.info(\r\n                \"ScheduleServiceImpl::saveSchedulesFromExcelFile -> Query execution time: {}, Total records: {}\",\r\n                watch.getTotalTimeSeconds(),\r\n                savedSchedules.size()\r\n        );\r\n\r\n        return new ResponseDTO(\"File processed and schedules saved successfully\");\r\n    }\r\n\r\n    @Override\r\n    public InputStreamResource exportSchedules() throws IOException {\r\n        log.info(\"ScheduleServiceImpl::exportSchedules\");\r\n\r\n        List<ScheduleQueryOutputDTO> scheduleQueryOutputDTOList = scheduleRepository.findAllSchedules();\r\n\r\n        return new InputStreamResource(ExportData.exportSchedules(scheduleQueryOutputDTOList));\r\n    }\r\n\r\n}"
    },
    {
        "file_name": "ComplexCalculator.java",
        "java_code": "public class ComplexCalculator extends AdvancedMath {\r\n    public double calculate(int a, int b, String operation) {\r\n        try {\r\n            if (operation.equals(\"add\")) {\r\n                return a + b;\r\n            } else if (operation.equals(\"subtract\")) {\r\n                return a - b;\r\n            } else if (operation.equals(\"multiply\")) {\r\n                return a * b;\r\n            } else if (operation.equals(\"divide\")) {\r\n                if (b == 0) throw new ArithmeticException(\"Cannot divide by zero\");\r\n                return a / b;\r\n            } else {\r\n                throw new IllegalArgumentException(\"Invalid operation\");\r\n            }\r\n        } catch (Exception e) {\r\n            System.out.println(\"Error: \" + e.getMessage());\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "file_name": "RecursiveProcessor1.java",
        "java_code": "class RecursiveProcessor {\r\n    public void process(String data, int depth) {\r\n        recursiveProcess(data, depth);\r\n    }\r\n\r\n    private void recursiveProcess(String data, int depth) {\r\n        if (depth <= 0 || data.isEmpty()) {\r\n            System.out.println(\"Recursion terminated at depth: \" + depth);\r\n            return;\r\n        }\r\n\r\n        System.out.println(\"Processing at depth \" + depth + \" with data: \" + data);\r\n\r\n        try {\r\n            if (depth % 2 == 0) {\r\n                validateData(data);\r\n            } else {\r\n                iterateProcessing(depth);\r\n            }\r\n        } catch (IllegalArgumentException ex) {\r\n            System.err.println(\"Exception: \" + ex.getMessage());\r\n        }\r\n\r\n        recursiveProcess(data.length() > 1 ? data.substring(1) : \"\", depth - 1);\r\n\r\n        for (char ch : data.toCharArray()) {\r\n            if (Character.isDigit(ch)) {\r\n                throw new IllegalArgumentException(\"Numeric character '\" + ch + \"' found in data!\");\r\n            }\r\n        }\r\n        System.out.println(\"Data is valid for processing.\");\r\n    }\r\n}\r\n"
    }
]