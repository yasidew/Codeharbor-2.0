[
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  },
  {
    "func": "public void missingFinalModifier() {\n    public class Constants {\n        public static int MAX_SIZE = 100;\n    }\n}",
    "target": "Declare constants with `final` to prevent accidental modification."
  },
  {
    "func": "public void poorExceptionHandling() {\n    public void process() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            System.out.println(\"Something went wrong\");\n        }\n    }\n}",
    "target": "Avoid catching generic `Exception`; catch specific exception types."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Add `break` statements in switch cases to prevent unintended fall-through behavior."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when the type is already known."
  },
  {
    "func": "public void swallowException() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // Do nothing\n    }\n}",
    "target": "Do not swallow exceptions silently. Log them properly or rethrow them for debugging."
  },
  {
    "func": "public void genericExceptionCatch() {\n    try {\n        int result = 10 / 0;\n    } catch (Exception e) {\n        System.out.println(\"An error occurred\");\n    }\n}",
    "target": "Avoid catching generic Exception; catch specific exception types to handle errors properly."
  },
  {
    "func": "public void exceptionWithoutLogging() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Use proper logging frameworks instead of `printStackTrace()` for better debugging."
  },
  {
    "func": "public void redundantTryCatch() {\n    try {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error occurred\");\n        }\n    } catch (Exception e) {\n        System.out.println(\"Another error occurred\");\n    }\n}",
    "target": "Avoid redundant nested try-catch blocks; handle errors in a single well-defined block."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader file = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    }\n}",
    "target": "Use `finally` blocks to close resources to prevent resource leaks."
  },
  {
    "func": "public void improperResourceHandling() {\n    FileReader file = new FileReader(\"file.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Use try-with-resources to ensure proper closing of resources and prevent memory leaks."
  },
  {
    "func": "public void throwingExceptionInFinally() {\n    try {\n        System.out.println(\"Processing\");\n    } finally {\n        throw new RuntimeException(\"Finally block exception\");\n    }\n}",
    "target": "Do not throw exceptions in `finally` blocks; it suppresses original exceptions."
  },
  {
    "func": "public void exceptionStackTraceNotLogged() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Division by zero\");\n    }\n}",
    "target": "Log the exception stack trace to understand the cause of errors."
  },
  {
    "func": "public void improperCheckedExceptionHandling() {\n    public void process() throws IOException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Handle checked exceptions properly using try-catch instead of propagating them unnecessarily."
  },
  {
    "func": "public void usingThrowableInsteadOfException() {\n    try {\n        int x = 10 / 0;\n    } catch (Throwable t) {\n        System.out.println(\"Something went wrong\");\n    }\n}",
    "target": "Avoid catching `Throwable`; catch specific exceptions instead."
  },
  {
    "func": "public void notRethrowingCaughtException() {\n    try {\n        riskyMethod();\n    } catch (IOException e) {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Consider rethrowing exceptions when needed instead of just logging them."
  },
  {
    "func": "public void improperExceptionPropagation() {\n    public void method() throws Exception {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Throw specific exceptions instead of generic `Exception` for better debugging."
  },
  {
    "func": "public void exceptionLoggingWithSensitiveInfo() {\n    try {\n        authenticateUser();\n    } catch (AuthenticationException e) {\n        System.out.println(\"Login failed for user: \" + e.getMessage());\n    }\n}",
    "target": "Avoid logging sensitive user information in exception messages."
  },
  {
    "func": "public void catchingNullPointerWithoutFixing() {\n    try {\n        String s = null;\n        s.length();\n    } catch (NullPointerException e) {\n        System.out.println(\"Null pointer encountered\");\n    }\n}",
    "target": "Fix the root cause of `NullPointerException` instead of just catching it."
  },
  {
    "func": "public void exceptionSuppression() {\n    try {\n        throw new IOException(\"File error\");\n    } catch (IOException e) {\n        throw new RuntimeException(\"Wrapped error\");\n    }\n}",
    "target": "Preserve original exceptions using `initCause()` or exception chaining."
  },
  {
    "func": "public void multipleCatchBlocksWithSameCode() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        System.out.println(\"Math error\");\n    } catch (Exception e) {\n        System.out.println(\"Math error\");\n    }\n}",
    "target": "Avoid redundant catch blocks with the same handling logic."
  },
  {
    "func": "public void notValidatingInput() {\n    public void process(int input) {\n        int result = 100 / input;\n    }\n}",
    "target": "Validate user input to prevent divide-by-zero and other runtime exceptions."
  },
  {
    "func": "public void missingLoggingInCatchBlock() {\n    try {\n        int result = 10 / 0;\n    } catch (ArithmeticException e) {\n        // No logging\n    }\n}",
    "target": "Log exceptions properly to aid debugging and application monitoring."
  },
  {
    "func": "public void tooManyCheckedExceptions() {\n    public void readData() throws IOException, SQLException, FileNotFoundException {\n        FileReader file = new FileReader(\"file.txt\");\n    }\n}",
    "target": "Reduce the number of checked exceptions thrown by refactoring or handling exceptions internally."
  },
  {
    "func": "public void loggingInFinallyBlock() {\n    try {\n        riskyOperation();\n    } finally {\n        System.out.println(\"Process complete\");\n    }\n}",
    "target": "Avoid logging in `finally` blocks unless necessary to ensure accurate exception reporting."
  },
  {
    "func": "public void resourceNotClosed() {\n    FileReader file = new FileReader(\"data.txt\");\n    BufferedReader br = new BufferedReader(file);\n    System.out.println(br.readLine());\n}",
    "target": "Close resources explicitly or use try-with-resources to prevent memory leaks."
  },
  {
    "func": "public void noErrorMessage() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {\n        throw new RuntimeException();\n    }\n}",
    "target": "Provide meaningful error messages when throwing exceptions."
  },
  {
    "func": "public void incorrectErrorHierarchy() {\n    public class CustomException extends Throwable {}\n}",
    "target": "Do not extend `Throwable` directly; extend `Exception` or `RuntimeException` instead."
  },
  {
    "func": "public void improperUseOfAssertions() {\n    assert 10 > 20 : \"This should never happen\";\n}",
    "target": "Assertions should be used only for development debugging, not in production code."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        int x = 10 / 0;\n    } catch (ArithmeticException e) {}\n}",
    "target": "Do not leave catch blocks empty; always handle or log exceptions."
  },
  {
    "func": "public void usingSystemExitInExceptionHandling() {\n    try {\n        System.out.println(10 / 0);\n    } catch (Exception e) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid calling `System.exit()` in exception handling as it can terminate the JVM unexpectedly."
  },
  {
    "func": "public void deepNestingExample(int num) {\n    if (num > 0) {\n        if (num < 10) {\n            if (num % 2 == 0) {\n                if (num > 5) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; use guard clauses or refactor into smaller methods."
  },
  {
    "func": "public void longMethodExample() {\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < 50; j++) {\n            for (int k = 0; k < 20; k++) {\n                System.out.println(i + j + k);\n            }\n        }\n    }\n}",
    "target": "Refactor long methods into smaller ones to improve maintainability and readability."
  },
  {
    "func": "public int duplicateComputation(int x) {\n    return (x * x) + (x * x) + (x * x);\n}",
    "target": "Avoid redundant computations; store computed values in variables."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Hello\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public boolean unnecessaryBooleanCheck(boolean flag) {\n    if (flag == true) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Avoid redundant boolean checks; simply return `flag`."
  },
  {
    "func": "public void excessiveMethodParameters(int a, int b, int c, int d, int e, int f, int g, int h) {\n    System.out.println(a + b + c + d + e + f + g + h);\n}",
    "target": "Avoid too many parameters; use an object or builder pattern."
  },
  {
    "func": "public void excessiveStaticMethods() {\n    static int counter = 0;\n    public static void increment() { counter++; }\n    public static void decrement() { counter--; }\n}",
    "target": "Limit static methods and variables to prevent global state pollution."
  },
  {
    "func": "public void unoptimizedLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Cache `list.size()` in a variable to avoid redundant method calls."
  },
  {
    "func": "public void ineffectiveDataStructure() {\n    List<Integer> list = new ArrayList<>();\n    Set<Integer> set = new HashSet<>(list);\n    for (Integer num : list) {\n        if (set.contains(num)) {\n            System.out.println(num);\n        }\n    }\n}",
    "target": "Avoid redundant collections; use `Set` directly."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Log: \" + i);\n    }\n}",
    "target": "Limit excessive logging; use logging levels and batch processing."
  },
  {
    "func": "public void improperNullCheck(String value) {\n    if (value.equals(\"test\")) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Use `Objects.equals(value, \"test\")` to prevent `NullPointerException`."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader file = new FileReader(\"data.txt\");\n    file.read();\n}",
    "target": "Use try-with-resources to close resources properly."
  },
  {
    "func": "public void missingDefaultSwitchCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always provide a default case in switch statements."
  },
  {
    "func": "public void redundantReturn() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Simplify return statements: `return condition;`."
  },
  {
    "func": "public void hardCodedDelay() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded delays; use configuration or scheduled tasks."
  },
  {
    "func": "public void inefficientIteration(List<String> list) {\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop: `for (String item : list) {}`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` to indicate method overrides and prevent accidental mistakes."
  },
  {
    "func": "public void unnecessaryTypeCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary type casting when types are known."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    int y = 20;\n    return x;\n}",
    "target": "Remove unused variables to improve code clarity."
  },
  {
    "func": "public void unusedImport() {\n    import java.util.Date;\n}",
    "target": "Remove unused imports to keep code clean."
  },
  {
    "func": "public void inefficientLoopArray() {\n    for (int i = 0; i < array.length; i++) {\n        System.out.println(array[i]);\n    }\n}",
    "target": "Use `for-each` loop for array iteration."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths; use configuration properties."
  },
  {
    "func": "public void redundantParentheses() {\n    if ((x > 10) && (y < 5)) {\n        System.out.println(\"Valid\");\n    }\n}",
    "target": "Remove unnecessary parentheses for better readability."
  },
  {
    "func": "public void inefficientMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    if (map.containsKey(\"key\")) {\n        String value = map.get(\"key\");\n    }\n}",
    "target": "Use `map.getOrDefault()` instead of redundant `containsKey()`."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Log message\");\n}",
    "target": "Use a logging framework instead of `System.out.println()`."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Processing\");\n    System.out.println(\"Processing\");\n}",
    "target": "Avoid duplicate code; use a helper method."
  },
  {
    "func": "public void multipleReturnStatements() {\n    if (x > 0) return true;\n    else return false;\n}",
    "target": "Use a single return statement for clarity."
  },
  {
    "func": "public void longConstructor() {\n    public MyClass(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Avoid long constructors; use builder pattern."
  },
  {
    "func": "public void nonFinalStaticVariables() {\n    static String name = \"Test\";\n}",
    "target": "Mark static constants as `final` to prevent unintended modifications."
  },
  {
    "func": "public void inconsistentNamingConvention() {\n    int VarName = 5;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions: use camelCase for variables (`varName`)."
  },
  {
    "func": "public class IncorrectClassNaming {\n    public void method() {}\n}",
    "target": "Class names should use PascalCase (`IncorrectClassNaming`)."
  },
  {
    "func": "public void missingBraces() {\n    if (x > 0) \n        System.out.println(\"Positive\");\n}",
    "target": "Always use curly braces `{}` even for single-line statements to prevent bugs."
  },
  {
    "func": "public void methodWithLongLines() {\n    System.out.println(\"This is a very long line that exceeds the recommended line length, making the code harder to read and maintain.\");\n}",
    "target": "Keep line length under 80-120 characters for better readability."
  },
  {
    "func": "public void methodWithHardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations; use properties or environment variables."
  },
  {
    "func": "public void redundantElse() {\n    if (condition) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant `else` statements: `return condition;`."
  },
  {
    "func": "public void inconsistentExceptionHandling() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid `printStackTrace()` in production; use logging frameworks instead."
  },
  {
    "func": "public void missingDocumentation() {\n    public void processData() {}\n}",
    "target": "Add Javadoc comments to public methods and classes for better maintainability."
  },
  {
    "func": "public void unusedPrivateMethod() {\n    private void helperMethod() {}\n}",
    "target": "Remove unused private methods to keep code clean and maintainable."
  },
  {
    "func": "public void methodWithMultipleResponsibilities() {\n    void saveData() {\n        validateInput();\n        connectToDatabase();\n        executeQuery();\n    }\n}",
    "target": "Follow **Single Responsibility Principle (SRP)**: Each method should have a single purpose."
  },
  {
    "func": "public void methodWithTooManyReturnStatements(int num) {\n    if (num > 10) return 1;\n    if (num < 0) return -1;\n    return 0;\n}",
    "target": "Avoid multiple return statements; refactor using conditional logic."
  },
  {
    "func": "public void mixedUseOfTabsAndSpaces() {\n\tif (x > 0) {\n        System.out.println(\"Mix of tabs and spaces\");\n    }\n}",
    "target": "Use consistent indentation: either spaces or tabs (Java standard is 4 spaces)."
  },
  {
    "func": "public void deeplyNestedLoop() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(i + j + k + l);\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting; refactor using helper methods or recursion."
  },
  {
    "func": "public void missingDefaultCase(int status) {\n    switch (status) {\n        case 1: System.out.println(\"Started\"); break;\n        case 2: System.out.println(\"Stopped\"); break;\n    }\n}",
    "target": "Always include a default case in switch statements."
  },
  {
    "func": "public void methodWithSideEffects() {\n    private int counter = 0;\n    public int getCounter() {\n        return counter++;\n    }\n}",
    "target": "Avoid methods that modify state unexpectedly."
  },
  {
    "func": "public void staticInitializationWithInstanceVariable() {\n    private String name;\n    static {\n        name = \"Test\";\n    }\n}",
    "target": "Avoid modifying instance variables inside static blocks."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {}\n}",
    "target": "Never leave catch blocks empty; log or handle the exception properly."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public void excessiveUseOfInstanceVariables() {\n    private int a, b, c, d, e, f, g, h, i, j, k;\n}",
    "target": "Avoid excessive instance variables; consider grouping related fields into objects."
  },
  {
    "func": "public void inefficientLoopOverMap() {\n    for (String key : map.keySet()) {\n        System.out.println(key + \" -> \" + map.get(key));\n    }\n}",
    "target": "Use `for (Map.Entry<String, String> entry : map.entrySet())` for efficiency."
  },
  {
    "func": "public void useOfVectorInsteadOfArrayList() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector`, unless thread-safety is required."
  },
  {
    "func": "public void useOfHashtableInsteadOfHashMap() {\n    Hashtable<String, String> data = new Hashtable<>();\n}",
    "target": "Use `HashMap` instead of `Hashtable`, unless thread-safety is required."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    class Child extends Parent {\n        public void execute() {}\n    }\n}",
    "target": "Use `@Override` annotation to prevent accidental method mismatches."
  },
  {
    "func": "public void missingEqualsAndHashCode() {\n    class Employee {\n        private String name;\n    }\n}",
    "target": "Override `equals()` and `hashCode()` when defining objects for proper behavior in collections."
  },
  {
    "func": "public void complexBooleanExpression() {\n    if ((a > 10 && b < 20) || (c == 5 && d > 2) || (e != 0 && f < 100)) {}\n}",
    "target": "Simplify complex boolean expressions for readability."
  },
  {
    "func": "public void staticVariableWithNonFinal() {\n    static String appName = \"TestApp\";\n}",
    "target": "Mark static variables as `final` if their values should not change."
  },
  {
    "func": "public void callingConstructorInLoop() {\n    for (int i = 0; i < 10; i++) {\n        new Object();\n    }\n}",
    "target": "Avoid object creation inside loops; consider object reuse."
  },
  {
    "func": "public void directThreadCreation() {\n    new Thread(() -> System.out.println(\"Running\")).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating threads."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"data\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for string concatenation in loops."
  },
  {
    "func": "public void inefficientListIteration() {\n    List<String> data = getData();\n    for (int i = 0; i < data.size(); i++) {\n        System.out.println(data.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (String item : data)`) or streams for efficiency."
  },
  {
    "func": "public void unoptimizedMapSearch() {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n    if (names.contains(\"Bob\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use a `Set` instead of a `List` for membership checks to improve performance."
  },
  {
    "func": "public void overuseOfThreads() {\n    for (int i = 0; i < 100; i++) {\n        new Thread(() -> processTask()).start();\n    }\n}",
    "target": "Use `ExecutorService` instead of creating multiple threads manually."
  },
  {
    "func": "public void outdatedDateAPI() {\n    Date date = new Date();\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n    System.out.println(formatter.format(date));\n}",
    "target": "Use `java.time` package instead of `Date` and `SimpleDateFormat`."
  },
  {
    "func": "public void usingLegacyFileAPI() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n}",
    "target": "Use `Files.newInputStream(Paths.get(\"data.txt\"))` instead of `FileInputStream`."
  },
  {
    "func": "public void redundantObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        Integer num = new Integer(i);\n    }\n}",
    "target": "Avoid redundant object creation; use `Integer.valueOf(i)` instead."
  },
  {
    "func": "public void inefficientBigDecimalUsage() {\n    BigDecimal value = new BigDecimal(0.1);\n}",
    "target": "Use `BigDecimal.valueOf(0.1)` instead of the constructor to avoid precision errors."
  },
  {
    "func": "public void unnecessarySynchronizedBlock() {\n    synchronized (this) {\n        process();\n    }\n}",
    "target": "Avoid unnecessary synchronization in non-concurrent code to improve performance."
  },
  {
    "func": "public void unnecessaryTryCatch() {\n    try {\n        int result = 10 / 2;\n    } catch (Exception e) {\n        System.out.println(\"Handled\");\n    }\n}",
    "target": "Do not use try-catch for operations that do not throw exceptions."
  },
  {
    "func": "public void missingCacheImplementation() {\n    public String fetchData(String key) {\n        return database.query(key);\n    }\n}",
    "target": "Use caching (e.g., `ConcurrentHashMap` or external caches like Redis) for frequently accessed data."
  },
  {
    "func": "public void inefficientJSONParsing() {\n    JSONObject obj = new JSONObject(jsonString);\n    String value = obj.getString(\"key\");\n}",
    "target": "Use Jackson or Gson streaming API for large JSON data instead of `JSONObject`."
  },
  {
    "func": "public void missingPagination() {\n    public List<User> fetchAllUsers() {\n        return database.getUsers();\n    }\n}",
    "target": "Always implement pagination for large database queries to avoid memory overload."
  },
  {
    "func": "public void excessiveSessionStorage() {\n    session.setAttribute(\"user\", user);\n}",
    "target": "Avoid storing large objects in session; use a distributed cache instead."
  },
  {
    "func": "public void blockingIOCall() {\n    System.out.println(\"Processing...\");\n    Thread.sleep(5000);\n}",
    "target": "Avoid blocking calls in asynchronous environments; use `CompletableFuture` or reactive programming."
  },
  {
    "func": "public void overuseOfStaticVariables() {\n    public static int counter = 0;\n}",
    "target": "Avoid excessive use of static variables; use dependency injection where applicable."
  },
  {
    "func": "public void expensiveDatabaseOperationsInLoop() {\n    for (User user : users) {\n        database.update(user);\n    }\n}",
    "target": "Batch database updates instead of calling them in loops."
  },
  {
    "func": "public void overcomplicatedBooleanLogic() {\n    if ((a > 10 && b < 5) || (c == 5 && d != 0)) {}\n}",
    "target": "Simplify boolean expressions for readability and maintainability."
  },
  {
    "func": "public void hardcodedBusinessRules() {\n    public double calculateDiscount(double amount) {\n        if (amount > 100) return amount * 0.1;\n        return 0;\n    }\n}",
    "target": "Externalize business rules into configuration files or a rules engine."
  },
  {
    "func": "public void missingFeatureFlags() {\n    public void launchNewFeature() {\n        System.out.println(\"New Feature Enabled\");\n    }\n}",
    "target": "Use feature flags to control new features dynamically."
  },
  {
    "func": "public void ignoringBackwardCompatibility() {\n    public void newMethod() {\n        // Removed old method\n    }\n}",
    "target": "Ensure backward compatibility when modifying APIs."
  },
  {
    "func": "public void unnecessaryObjectPooling() {\n    public class ConnectionPool {\n        private List<Connection> pool = new ArrayList<>();\n    }\n}",
    "target": "Use modern connection pools like HikariCP instead of manual object pooling."
  },
  {
    "func": "public void notUsingEnumForConstants() {\n    public static final String STATUS_ACTIVE = \"ACTIVE\";\n}",
    "target": "Use `enum` instead of static constants for predefined values."
  },
  {
    "func": "public void complexNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (i * j > 20) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Flatten nested loops where possible for better performance."
  },
  {
    "func": "public void outdatedSecurityPractices() {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Avoid outdated SSL/TLS versions; use TLS 1.2 or higher."
  },
  {
    "func": "public void uncheckedTypeCasting() {\n    Object obj = \"string\";\n    Integer num = (Integer) obj;\n}",
    "target": "Use generics to avoid unsafe type casting."
  },
  {
    "func": "public void inefficientSortingAlgorithm() {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use `Arrays.sort()` or `Collections.sort()` for optimized sorting."
  },
  {
    "func": "public void missingLogging() {\n    public void process() {\n        doSomething();\n    }\n}",
    "target": "Always include logging for critical operations."
  },
  {
    "func": "public void missingFinallyBlock() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Always use a `finally` block or try-with-resources to close resources properly."
  },
  {
    "func": "public int magicNumberExample(int input) {\n    if (input == 42) {\n        return 1;\n    }\n    return 0;\n}",
    "target": "Avoid magic numbers. Use named constants instead."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(\"Processing: \" + input);\n}",
    "target": "Validate and sanitize user input to prevent injection attacks."
  },
  {
    "func": "public void ignoringThreadInterruption() {\n    while (true) {\n        // Do some work\n    }\n}",
    "target": "Check for `Thread.interrupted()` in loops to allow graceful termination."
  },
  {
    "func": "public void inefficientListSorting(List<String> list) {\n    Collections.sort(list, (a, b) -> a.compareTo(b));\n}",
    "target": "Use `list.sort(Comparator.naturalOrder())` instead of `Collections.sort()`."
  },
  {
    "func": "public void inefficientStreamUsage(List<String> data) {\n    List<String> filtered = new ArrayList<>();\n    for (String d : data) {\n        if (d.startsWith(\"A\")) {\n            filtered.add(d);\n        }\n    }\n}",
    "target": "Use `data.stream().filter(d -> d.startsWith(\"A\")).collect(Collectors.toList())` for better performance."
  },
  {
    "func": "public void poorLoggingPractice() {\n    System.out.println(\"An error occurred: \" + e.getMessage());\n}",
    "target": "Use a logging framework (e.g., SLF4J, Log4J) instead of `System.out.println()`."
  },
  {
    "func": "public void insecureRandom() {\n    int random = (int) (Math.random() * 100);\n}",
    "target": "Use `SecureRandom` instead of `Math.random()` for security-sensitive operations."
  },
  {
    "func": "public void usingLegacyCollections() {\n    Vector<Integer> numbers = new Vector<>();\n}",
    "target": "Use `ArrayList` instead of `Vector` unless thread safety is required."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000; i++) {\n        System.out.println(\"Processing: \" + i);\n    }\n}",
    "target": "Avoid excessive logging inside loops to prevent performance issues."
  },
  {
    "func": "public void inefficientNestedIfStatements(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                System.out.println(\"Valid\");\n            }\n        }\n    }\n}",
    "target": "Flatten nested `if` conditions for better readability and maintainability."
  },
  {
    "func": "public void insecureSQLQuery(String user) {\n    String query = \"SELECT * FROM users WHERE username = '\" + user + \"'\";\n}",
    "target": "Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void redundantSynchronizedBlock() {\n    synchronized (this) {\n        synchronized (this) {\n            process();\n        }\n    }\n}",
    "target": "Avoid redundant synchronized blocks to improve performance."
  },
  {
    "func": "public void usingDeprecatedAPI() {\n    Date date = new Date();\n    int year = date.getYear();\n}",
    "target": "Avoid deprecated methods. Use `LocalDate` instead of `Date`."
  },
  {
    "func": "public void redundantNullCheck(String value) {\n    if (value != null && value.length() > 0) {\n        System.out.println(value);\n    }\n}",
    "target": "Use `!value.isEmpty()` instead of redundant null checks."
  },
  {
    "func": "public void missingDefaultCase(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\"); break;\n        case 2: System.out.println(\"Two\"); break;\n    }\n}",
    "target": "Always include a `default` case in switch statements."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        process();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Catch specific exceptions instead of generic `Exception`."
  },
  {
    "func": "public void missingOverrideAnnotation() {\n    public void toString() {\n        return \"MyObject\";\n    }\n}",
    "target": "Use `@Override` annotation for overridden methods."
  },
  {
    "func": "public void missingCloseOnStream() {\n    BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n}",
    "target": "Use try-with-resources to ensure streams are closed properly."
  },
  {
    "func": "public void inefficientMapIteration() {\n    Map<String, String> map = new HashMap<>();\n    for (String key : map.keySet()) {\n        System.out.println(key + \": \" + map.get(key));\n    }\n}",
    "target": "Use `entrySet()` iteration instead of calling `map.get(key)` multiple times."
  },
  {
    "func": "public void incorrectEqualsComparison() {\n    String a = \"hello\";\n    String b = \"hello\";\n    if (a == b) {\n        System.out.println(\"Equal\");\n    }\n}",
    "target": "Use `.equals()` instead of `==` for string comparison."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    public void process() {}\n}",
    "target": "Remove unused imports to improve code readability."
  },
  {
    "func": "public void usingHardcodedFilePaths() {\n    File file = new File(\"C:/data/file.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configuration files."
  },
  {
    "func": "public void inefficientArrayCopy() {\n    int[] src = {1, 2, 3};\n    int[] dest = new int[3];\n    for (int i = 0; i < src.length; i++) {\n        dest[i] = src[i];\n    }\n}",
    "target": "Use `System.arraycopy()` instead of manual copying for better performance."
  },
  {
    "func": "public void ignoringCloseMethod() {\n    Connection conn = DriverManager.getConnection(url);\n    Statement stmt = conn.createStatement();\n}",
    "target": "Always close database connections and statements."
  },
  {
    "func": "public void missingJavaDoc() {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Include JavaDoc comments for public methods."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Do not hardcode credentials. Use environment variables or secure storage."
  },
  {
    "func": "public void unnecessaryDoubleCheckLocking() {\n    if (instance == null) {\n        synchronized (this) {\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n}",
    "target": "Use `volatile` or `enum Singleton` for safe and efficient singleton implementation."
  },
  {
    "func": "public void missingBreakInSwitch(int value) {\n    switch (value) {\n        case 1: System.out.println(\"One\");\n        case 2: System.out.println(\"Two\");\n        default: System.out.println(\"Unknown\");\n    }\n}",
    "target": "Missing `break` in switch cases can lead to unintended fall-through behavior."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"x\";\n    }\n}",
    "target": "Use `StringBuilder` instead of `+` for repeated string concatenation."
  },
  {
    "func": "public void excessiveTryCatch() {\n    try {\n        try {\n            process();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid nested `try-catch` blocks as they reduce readability and maintainability."
  },
  {
    "func": "public void ignoringCaseInStringComparison() {\n    if (userInput == \"ADMIN\") {\n        System.out.println(\"Access granted\");\n    }\n}",
    "target": "Use `.equalsIgnoreCase()` when comparing case-insensitive strings."
  },
  {
    "func": "public void missingThreadPoolUsage() {\n    new Thread(() -> process()).start();\n}",
    "target": "Use `ExecutorService` instead of manually creating new threads for better resource management."
  },
  {
    "func": "public void inefficientResourceClosing() {\n    Connection conn = DriverManager.getConnection(url);\n    conn.close();\n}",
    "target": "Close resources in a `finally` block or use try-with-resources."
  },
  {
    "func": "public void unnecessaryFinalModifier() {\n    public final void process() {\n        System.out.println(\"Processing...\");\n    }\n}",
    "target": "Avoid using `final` on methods unless necessary for security or immutability."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < list.size(); i++) {\n        process(list.get(i));\n    }\n}",
    "target": "Use enhanced for-loop (`for (Item i : list)`) to improve readability and avoid repeated `size()` calls."
  },
  {
    "func": "public void usingSystemExit() {\n    if (error) {\n        System.exit(1);\n    }\n}",
    "target": "Avoid `System.exit()` in applications; use exception handling instead."
  },
  {
    "func": "public void longMethodExample() {\n    public void process() {\n        // 200+ lines of logic\n    }\n}",
    "target": "Refactor long methods into smaller, well-defined functions to improve readability."
  },
  {
    "func": "public void incorrectHashMapUsage() {\n    Map<String, String> map = new HashMap<>();\n    map.put(null, \"value\");\n}",
    "target": "Avoid using `null` as a key in HashMap to prevent `NullPointerException` risks."
  },
  {
    "func": "public void missingSynchronization() {\n    private int counter;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Use `synchronized`, `AtomicInteger`, or `Lock` to prevent race conditions."
  },
  {
    "func": "public void usingStackTraceForFlowControl() {\n    try {\n        process();\n    } catch (Exception e) {\n        System.out.println(\"Error\");\n    }\n}",
    "target": "Do not use exceptions for normal control flow; handle errors explicitly."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove unnecessary `else` after a `return` statement for cleaner code."
  },
  {
    "func": "public void missingOverrideForHashCode() {\n    public boolean equals(Object obj) {\n        return obj instanceof User;\n    }\n}",
    "target": "Always override `hashCode()` when overriding `equals()` to maintain consistency."
  },
  {
    "func": "public void insecureClassLoading(String className) {\n    Class<?> clazz = Class.forName(className);\n}",
    "target": "Ensure class names are validated before loading them dynamically to prevent security risks."
  },
  {
    "func": "public void usingHardcodedSalt() {\n    String salt = \"123456\";\n}",
    "target": "Use a cryptographic salt generated dynamically instead of hardcoded values."
  },
  {
    "func": "public void missingTimeoutOnNetworkCall() {\n    URLConnection conn = new URL(url).openConnection();\n}",
    "target": "Always set timeouts (`setConnectTimeout`, `setReadTimeout`) to prevent hangs."
  },
  {
    "func": "public void poorUseOfReflection() {\n    Method method = obj.getClass().getMethod(\"execute\");\n    method.invoke(obj);\n}",
    "target": "Limit reflection usage as it impacts performance and maintainability."
  },
  {
    "func": "public void unnecessaryBooleanComparison() {\n    if (isValid == true) {\n        return true;\n    }\n}",
    "target": "Avoid redundant comparisons; use `if (isValid)` instead of `if (isValid == true)`."
  },
  {
    "func": "public void redundantExceptionWrapping() {\n    try {\n        process();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}",
    "target": "Do not rewrap exceptions unnecessarily; handle them or log appropriately."
  },
  {
    "func": "public void inefficientSetContainsCheck() {\n    List<String> list = new ArrayList<>();\n    if (list.contains(\"value\")) {\n        System.out.println(\"Found\");\n    }\n}",
    "target": "Use `HashSet` instead of `List` for faster `contains()` lookups."
  },
  {
    "func": "public void missingDependencyInjection() {\n    private DatabaseService dbService = new DatabaseService();\n}",
    "target": "Use dependency injection frameworks like Spring instead of manual object instantiation."
  },
  {
    "func": "public void excessiveMethodChaining() {\n    return object.getA().getB().getC().getD().getE();\n}",
    "target": "Avoid long method chains; use intermediate variables to improve readability."
  },
  {
    "func": "public void poorExceptionHierarchy() {\n    try {\n        riskyOperation();\n    } catch (IOException | SQLException e) {\n        throw new Exception(\"General error\");\n    }\n}",
    "target": "Catch specific exceptions instead of using a generic `Exception`."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    for (int i = 0; i < 1000; i++) {\n        String s = new String(\"Hello\");\n    }\n}",
    "target": "Avoid unnecessary object creation; use string literals where possible."
  },
  {
    "func": "public void usingRawTypes() {\n    List list = new ArrayList();\n    list.add(\"string\");\n}",
    "target": "Avoid raw types; use generics (`List<String>` instead of `List`)."
  },
  {
    "func": "public void missingAPIVersioning() {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}",
    "target": "Always version APIs (e.g., `/api/v1/users`) to maintain backward compatibility."
  },
  {
    "func": "public void leakingSensitiveDataInLogs() {\n    LOGGER.info(\"User password: \" + password);\n}",
    "target": "Do not log sensitive data such as passwords or API keys."
  },
  {
    "func": "public String insecureSQL(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid string concatenation in SQL queries. Use prepared statements to prevent SQL injection."
  },
  {
    "func": "public void weakCryptography(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(password.getBytes());\n    byte[] digest = md.digest();\n}",
    "target": "Avoid using MD5 for hashing. Use a stronger hashing algorithm like SHA-256 or bcrypt."
  },
  {
    "func": "public void hardcodedSecret() {\n    String apiKey = \"12345-ABCDE\";\n}",
    "target": "Avoid hardcoding secrets in code. Use environment variables or a secure vault."
  },
  {
    "func": "public void unusedVariable() {\n    int x = 10;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused variables to improve code clarity and maintainability."
  },
  {
    "func": "public void tooManyParameters(int a, int b, int c, int d, int e, int f, int g) {\n    System.out.println(a + b + c + d + e + f + g);\n}",
    "target": "Avoid methods with too many parameters. Consider using an object to group parameters."
  },
  {
    "func": "public void deepNesting() {\n    if (condition1) {\n        if (condition2) {\n            if (condition3) {\n                if (condition4) {\n                    System.out.println(\"Too deep\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive nesting for better readability. Refactor into separate methods."
  },
  {
    "func": "public void insecureFileHandling() {\n    File file = new File(\"/tmp/data.txt\");\n    FileReader reader = new FileReader(file);\n}",
    "target": "Use proper validation when handling files to prevent security vulnerabilities."
  },
  {
    "func": "public void emptyExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty exception handling blocks. Provide meaningful error-handling logic."
  },
  {
    "func": "public void inconsistentNaming() {\n    int VarName = 10;\n    System.out.println(VarName);\n}",
    "target": "Follow Java naming conventions. Use camelCase for variables and methods."
  },
  {
    "func": "public void weakRandomGenerator() {\n    Random random = new Random();\n    int num = random.nextInt();\n}",
    "target": "Use SecureRandom for cryptographic security instead of java.util.Random."
  },
  {
    "func": "public void uncheckedCast(Object obj) {\n    String str = (String) obj;\n}",
    "target": "Ensure safe type casting. Use instanceof before casting."
  },
  {
    "func": "public void hardcodedFilePath() {\n    String path = \"C:\\\\Users\\\\Admin\\\\data.txt\";\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void redundantElse(int x) {\n    if (x > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> list = new ArrayList<>();\n    while (true) {\n        list.add(\"leak\");\n    }\n}",
    "target": "Avoid unbounded memory usage. Implement limits or cleanup mechanisms."
  },
  {
    "func": "public void missingExceptionMessage() {\n    throw new Exception();\n}",
    "target": "Provide meaningful exception messages for debugging."
  },
  {
    "func": "public void inefficientLoop() {\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            process(data[i], data[j]);\n        }\n    }\n}",
    "target": "Optimize nested loops to avoid performance bottlenecks."
  },
  {
    "func": "public void improperObjectInitialization() {\n    MyClass obj = new MyClass();\n    obj.value = 10;\n}",
    "target": "Use proper constructors to initialize objects to avoid inconsistent states."
  },
  {
    "func": "public void unencryptedCommunication() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n}",
    "target": "Use HTTPS instead of HTTP for secure communication."
  },
  {
    "func": "public void improperFilePermissions() {\n    File file = new File(\"/data.txt\");\n    file.setReadable(true, false);\n}",
    "target": "Avoid setting overly permissive file permissions."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid string concatenation in loops. Use StringBuilder for better performance."
  },
  {
    "func": "public void missingInputValidation(String input) {\n    System.out.println(input);\n}",
    "target": "Validate input to ensure it meets expected format and constraints."
  },
  {
    "func": "public void riskyReflection() {\n    Class<?> clazz = Class.forName(\"java.lang.Runtime\");\n    Method method = clazz.getMethod(\"exec\", String.class);\n}",
    "target": "Avoid reflection for executing commands. It can introduce security risks."
  },
  {
    "func": "public void uncheckedArrayAccess() {\n    int[] numbers = {1, 2, 3};\n    System.out.println(numbers[3]);\n}",
    "target": "Ensure array indices are within bounds to prevent runtime errors."
  },
  {
    "func": "public void missingResourceClosing() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    byte[] data = fis.readAllBytes();\n}",
    "target": "Always close resources like files and sockets to prevent leaks."
  },
  {
    "func": "public void insecureDeserialization(String input) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(input.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid using Java deserialization for untrusted input. Use safer serialization formats like JSON."
  },
  {
    "func": "public void redundantCode() {\n    System.out.println(\"Hello\");\n    System.out.println(\"Hello\");\n}",
    "target": "Remove redundant code to improve efficiency and maintainability."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive logging as it can reduce performance and clutter logs."
  },
  {
    "func": "public void blockingOperation() {\n    Thread.sleep(10000);\n}",
    "target": "Avoid blocking operations in performance-critical applications."
  },
  {
    "func": "public void unsafePathConstruction(String base, String filename) {\n    String path = base + \"/\" + filename;\n}",
    "target": "Validate paths to prevent directory traversal vulnerabilities."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    System.out.println(\"Hello World\");\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void longMethod() {\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n    for (int j = 0; j < 10; j++) {\n        sum -= j;\n    }\n    System.out.println(sum);\n    for (int k = 0; k < 10; k++) {\n        sum += k;\n    }\n    System.out.println(sum);\n}",
    "target": "Method is too long and difficult to read. Consider splitting into smaller functions."
  },
  {
    "func": "public void inconsistentIndentation() {\n  int x = 10;\n    if (x > 5) {\n  System.out.println(\"X is greater than 5\");\n    }\n}",
    "target": "Use consistent indentation for better code readability."
  },
  {
    "func": "public void magicNumbers() {\n    int discount = 5;\n    int price = 100 - discount;\n}",
    "target": "Avoid using magic numbers. Define them as constants with meaningful names."
  },
  {
    "func": "public void excessiveComments() {\n    // This is a loop that prints numbers\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code instead."
  },
  {
    "func": "public void redundantVariable() {\n    int value = 100;\n    int anotherValue = value;\n    System.out.println(anotherValue);\n}",
    "target": "Avoid redundant variables. Use variables only when necessary."
  },
  {
    "func": "public void redundantElseStatement(int num) {\n    if (num > 0) {\n        return;\n    } else {\n        System.out.println(\"Negative number\");\n    }\n}",
    "target": "Avoid redundant else statements after return."
  },
  {
    "func": "public void unclearVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n}",
    "target": "Use descriptive variable names for better readability."
  },
  {
    "func": "public void deepNestingExample() {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if (d > 0) {\n                    System.out.println(\"Deep nesting\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. It reduces code readability and maintainability."
  },
  {
    "func": "public void inconsistentSpacing() {\n    int x= 10;\n    System.out.println( x );\n}",
    "target": "Use consistent spacing to improve readability."
  },
  {
    "func": "public void inconsistentBraceStyle() {\n    if (x > 0) {\n        System.out.println(\"Positive\"); }\n    else\n    {\n        System.out.println(\"Negative\");\n    }\n}",
    "target": "Use consistent brace styles for better readability."
  },
  {
    "func": "public void unclearFunctionPurpose() {\n    int result = processData(10, 20);\n    System.out.println(result);\n}",
    "target": "Use clear function names and comments to indicate purpose."
  },
  {
    "func": "public void hardcodedConfig() {\n    String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n}",
    "target": "Avoid hardcoded configurations. Use environment variables or config files."
  },
  {
    "func": "public void inlineSQLQuery() {\n    Statement stmt = connection.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM users WHERE id = 1\");\n}",
    "target": "Avoid inline SQL queries. Use parameterized queries for security."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always handle exceptions properly."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 100; i++) {\n        result += i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation in loops."
  },
  {
    "func": "public void deadCode() {\n    return;\n    System.out.println(\"This will never run\");\n}",
    "target": "Remove unreachable code to keep the codebase clean."
  },
  {
    "func": "public void unnecessaryCasting() {\n    Object obj = \"Hello\";\n    String str = (String) obj;\n}",
    "target": "Avoid unnecessary casting. Use generics or type inference where possible."
  },
  {
    "func": "public void emptyIfStatement() {\n    if (x > 0) {\n    }\n}",
    "target": "Avoid empty if statements. Remove or provide meaningful conditions."
  },
  {
    "func": "public void redundantMethodCall() {\n    int x = getNumber();\n    int y = getNumber();\n}",
    "target": "Avoid redundant method calls. Cache results when applicable."
  },
  {
    "func": "public void missingFinalKeyword() {\n    class Data {\n        int value = 10;\n    }\n}",
    "target": "Use 'final' for constants to prevent accidental modification."
  },
  {
    "func": "public void usingDeprecatedMethod() {\n    Date date = new Date();\n    date.getYear();\n}",
    "target": "Avoid using deprecated methods. Use modern alternatives."
  },
  {
    "func": "public void nonThreadSafeCode() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure thread safety using synchronized methods or atomic variables."
  },
  {
    "func": "public void missingToStringOverride() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override 'toString()' method to provide meaningful object representation."
  },
  {
    "func": "public void inconsistentLogging() {\n    System.out.println(\"Error occurred\");\n}",
    "target": "Use a logging framework instead of System.out.println."
  },
  {
    "func": "public void missingBreakInSwitch() {\n    switch (x) {\n        case 1:\n            System.out.println(\"One\");\n        case 2:\n            System.out.println(\"Two\");\n    }\n}",
    "target": "Ensure each case in a switch statement has a break to prevent fall-through."
  },
  {
    "func": "public void insecureCookie() {\n    Cookie cookie = new Cookie(\"session\", \"123\");\n    response.addCookie(cookie);\n}",
    "target": "Set HttpOnly and Secure flags for cookies to enhance security."
  },
  {
    "func": "public void ineffectiveCatch() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Do not use printStackTrace in production. Use proper logging."
  },
  {
    "func": "public void redundantReturn() {\n    return x == 10 ? true : false;\n}",
    "target": "Simplify redundant return statements. Use 'return x == 10;'."
  },
  {
    "func": "public void deepNestingExample() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (k % 2 == 0) {\n                    if (k % 3 == 0) {\n                        if (k % 5 == 0) {\n                            System.out.println(\"Deeply nested logic\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting in loops and conditions. Extract logic into separate methods."
  },
  {
    "func": "public void excessiveConditionals(int a, int b, int c) {\n    if (a > 0) {\n        if (b > 0) {\n            if (c > 0) {\n                if ((a + b) > c) {\n                    if ((a * c) > b) {\n                        System.out.println(\"Excessive nested conditions\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Reduce excessive conditional nesting by using guard clauses or boolean methods."
  },
  {
    "func": "public void deepWhileNesting() {\n    int i = 0;\n    while (i < 10) {\n        int j = 0;\n        while (j < 10) {\n            int k = 0;\n            while (k < 10) {\n                if (i + j + k > 20) {\n                    System.out.println(\"Deep nested while loops\");\n                }\n                k++;\n            }\n            j++;\n        }\n        i++;\n    }\n}",
    "target": "Avoid excessive while-loop nesting. Consider flattening logic."
  },
  {
    "func": "public void nestedSwitch(int num) {\n    switch (num) {\n        case 1:\n            switch (num % 2) {\n                case 0:\n                    switch (num % 3) {\n                        case 0:\n                            System.out.println(\"Nested switch statements\");\n                            break;\n                    }\n                    break;\n            }\n            break;\n    }\n}",
    "target": "Avoid deeply nested switch statements. Use lookup tables or enums."
  },
  {
    "func": "public void multipleLoops(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            for (int k = 0; k < arr.length; k++) {\n                for (int l = 0; l < arr.length; l++) {\n                    System.out.println(\"Too many loop levels\");\n                }\n            }\n        }\n    }\n}",
    "target": "Refactor deeply nested loops. Consider breaking them into helper methods."
  },
  {
    "func": "public void excessiveSwitch(int num) {\n    switch (num) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n            System.out.println(\"Excessive switch cases\");\n            break;\n    }\n}",
    "target": "Reduce switch case complexity using maps or polymorphism."
  },
  {
    "func": "public void recursiveFunction(int x) {\n    if (x == 0) return;\n    recursiveFunction(x - 1);\n    recursiveFunction(x - 2);\n    recursiveFunction(x - 3);\n}",
    "target": "Avoid inefficient recursive functions. Use memoization or iteration."
  },
  {
    "func": "public void multipleBooleanConditions(boolean a, boolean b, boolean c, boolean d, boolean e) {\n    if (a && b && (c || d) && (e || a) && !(b && c)) {\n        System.out.println(\"Complex boolean logic\");\n    }\n}",
    "target": "Break down complex boolean expressions for clarity."
  },
  {
    "func": "public void hardcodedThreadSleep() {\n    try {\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid hardcoded sleep values. Use scheduled executors for better control."
  },
  {
    "func": "public void redundantLoop() {\n    for (int i = 0; i < 10; i++) {\n        if (i < 5) {\n            for (int j = 0; j < 5; j++) {\n                System.out.println(i + j);\n            }\n        }\n    }\n}",
    "target": "Optimize loops to avoid redundant iterations."
  },
  {
    "func": "public void inefficientExceptionHandling() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        try {\n            riskyRecovery();\n        } catch (Exception ex) {\n            System.out.println(\"Nested exception handling\");\n        }\n    }\n}",
    "target": "Avoid deeply nested exception handling. Use centralized error management."
  },
  {
    "func": "public void tooManyNestedObjects() {\n    class Outer {\n        class Inner1 {\n            class Inner2 {\n                class Inner3 {\n                    void print() {\n                        System.out.println(\"Too many nested objects\");\n                    }\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid excessive class nesting. Flatten structure for better readability."
  },
  {
    "func": "public void largeIfElseChain(int x) {\n    if (x == 1) {\n    } else if (x == 2) {\n    } else if (x == 3) {\n    } else if (x == 4) {\n    } else if (x == 5) {\n    } else {\n    }\n}",
    "target": "Refactor large if-else chains using maps or strategy patterns."
  },
  {
    "func": "public void longMethodExample() {\n    int sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += i;\n        if (sum % 2 == 0) {\n            sum -= 2;\n            if (sum % 3 == 0) {\n                sum += 3;\n                if (sum % 5 == 0) {\n                    sum += 5;\n                }\n            }\n        }\n    }\n}",
    "target": "Break long methods into smaller, single-responsibility methods."
  },
  {
    "func": "public String sqlInjectionVulnerable(String userInput) {\n    String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n    return query;\n}",
    "target": "Avoid SQL injection by using parameterized queries (PreparedStatement)."
  },
  {
    "func": "public void insecureXSS(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\"name\");\n    response.getWriter().println(\"Hello, \" + input);\n}",
    "target": "Sanitize user input to prevent Cross-Site Scripting (XSS). Use OWASP ESAPI or Java’s encodeForHTML."
  },
  {
    "func": "public void hardcodedApiKey() {\n    String apiKey = \"sk_live_1234567890abcdef\";\n    System.out.println(apiKey);\n}",
    "target": "Avoid hardcoded API keys. Use environment variables or secure vaults."
  },
  {
    "func": "public void weakPasswordHashing(String password) {\n    String hash = new BigInteger(1, MessageDigest.getInstance(\"MD5\").digest(password.getBytes())).toString(16);\n}",
    "target": "Avoid MD5 hashing. Use PBKDF2, bcrypt, or Argon2 instead."
  },
  {
    "func": "public void commandInjection(String userInput) throws IOException {\n    Runtime.getRuntime().exec(\"ping \" + userInput);\n}",
    "target": "Avoid command injection by validating and sanitizing input."
  },
  {
    "func": "public void openRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String redirectUrl = request.getParameter(\"redirect\");\n    response.sendRedirect(redirectUrl);\n}",
    "target": "Validate redirect URLs to prevent Open Redirect attacks."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String username = \"admin\";\n    String password = \"password123\";\n}",
    "target": "Avoid hardcoded credentials. Store them securely using environment variables."
  },
  {
    "func": "public void insecureDeserialization(String serializedObject) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedObject)));\n    Object obj = ois.readObject();\n}",
    "target": "Avoid insecure deserialization. Use whitelisting and signed objects."
  },
  {
    "func": "public void informationExposure(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.getWriter().println(\"Server version: \" + System.getProperty(\"java.version\"));\n}",
    "target": "Avoid exposing server details in responses. Use generic error messages."
  },
  {
    "func": "public void weakEncryption(String data) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"12345678\".getBytes(), \"DES\"));\n}",
    "target": "Avoid weak encryption algorithms like DES. Use AES with at least 256-bit keys."
  },
  {
    "func": "public void weakRandomPassword() {\n    String password = String.valueOf(new Random().nextInt(999999));\n}",
    "target": "Avoid insecure random number generation for passwords. Use SecureRandom instead."
  },
  {
    "func": "public void loggingSensitiveData(String password) {\n    Logger.getLogger(\"AuthLogger\").info(\"User password: \" + password);\n}",
    "target": "Avoid logging sensitive information such as passwords or API keys."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    int attempts = Integer.parseInt(request.getParameter(\"attempts\"));\n    if (attempts > 5) {\n        System.out.println(\"Potential brute-force attack!\");\n    }\n}",
    "target": "Implement rate limiting to prevent brute-force attacks."
  },
  {
    "func": "public void missingSecureFlag(HttpServletResponse response) {\n    Cookie cookie = new Cookie(\"session\", \"abc123\");\n    response.addCookie(cookie);\n}",
    "target": "Set the Secure and HttpOnly flags on cookies to prevent session hijacking."
  },
  {
    "func": "public void unsafeFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file uploads to prevent unrestricted file uploads."
  },
  {
    "func": "public void directoryTraversal(String filename) throws IOException {\n    File file = new File(\"/safe/\" + filename);\n    FileInputStream fis = new FileInputStream(file);\n}",
    "target": "Prevent directory traversal attacks by validating filenames."
  },
  {
    "func": "public void missingTLSVerification() throws Exception {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n        }\n    };\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new SecureRandom());\n}",
    "target": "Avoid disabling SSL verification as it makes the system vulnerable to MITM attacks."
  },
  {
    "func": "public void missingAuthorization(HttpServletRequest request) {\n    String userRole = request.getParameter(\"role\");\n    if (userRole.equals(\"admin\")) {\n        performAdminAction();\n    }\n}",
    "target": "Ensure proper authorization checks beyond user role values from input."
  },
  {
    "func": "public void memoryLeak() {\n    List<String> cache = new ArrayList<>();\n    while (true) {\n        cache.add(\"Data\" + new Random().nextInt());\n    }\n}",
    "target": "Avoid unbounded memory allocation. Use eviction policies."
  },
  {
    "func": "public void missingInputValidation(HttpServletRequest request) {\n    String username = request.getParameter(\"username\");\n    process(username);\n}",
    "target": "Sanitize and validate all user input to prevent injection attacks."
  },
  {
    "func": "public void unsafeJNI() {\n    System.loadLibrary(\"maliciousLibrary\");\n}",
    "target": "Avoid unsafe JNI calls that may introduce system-level vulnerabilities."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    response.sendRedirect(request.getParameter(\"next\"));\n}",
    "target": "Validate redirect URLs to prevent phishing attacks."
  },
  {
    "func": "public void insufficientSessionTimeout(HttpSession session) {\n    session.setMaxInactiveInterval(-1);\n}",
    "target": "Set session timeouts to prevent session hijacking."
  },
  {
    "func": "public void brokenAccessControl(HttpServletRequest request) {\n    String userId = request.getParameter(\"id\");\n    String query = \"SELECT * FROM users WHERE id = \" + userId;\n}",
    "target": "Ensure authorization checks to prevent IDOR (Insecure Direct Object Reference) attacks."
  },
  {
    "func": "public void noLoggingOnFailures(HttpServletRequest request) {\n    try {\n        processLogin(request);\n    } catch (Exception e) {\n        // Do nothing\n    }\n}",
    "target": "Log failed authentication attempts to detect potential attacks."
  },
  {
    "func": "public void missingSecureRandom() {\n    int code = new Random().nextInt(999999);\n}",
    "target": "Use SecureRandom instead of Random for security-sensitive values."
  },
  {
    "func": "public class MagicNumbers {\n    public static final int MAX_RETRIES = 3;\n    public void retryOperation() {\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Retrying...\");\n        }\n    }\n}",
    "target": "Avoid magic numbers. Define constants with meaningful names."
  },
  {
    "func": "public class GlobalVariables {\n    public static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid excessive global state. Use encapsulation and instance variables."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        stepOne(); stepTwo(); stepThree(); stepFour(); stepFive(); stepSix();\n    }\n}",
    "target": "Avoid long methods. Split into smaller, well-named methods."
  },
  {
    "func": "public class NestedLoops {\n    public void processData() {\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                for (int k = 0; k < 10; k++) {\n                    System.out.println(i + j + k);\n                }\n            }\n        }\n    }\n}",
    "target": "Deeply nested loops reduce readability and efficiency. Refactor using helper functions."
  },
  {
    "func": "public class StaticAccess {\n    public static void logMessage(String message) {\n        System.out.println(message);\n    }\n}",
    "target": "Minimize static method usage in non-utility classes. Use dependency injection."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n    public void methodSix() {}\n}",
    "target": "Avoid large classes with multiple responsibilities. Follow Single Responsibility Principle (SRP)."
  },
  {
    "func": "public class HardcodedValues {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded values. Use configuration files or environment variables."
  },
  {
    "func": "public class LoggingBestPractices {\n    public void process() {\n        System.out.println(\"Error occurred!\");\n    }\n}",
    "target": "Use logging frameworks (e.g., SLF4J, Log4J) instead of System.out.println()."
  },
  {
    "func": "public class ThreadSleepUsage {\n    public void waitProcess() throws InterruptedException {\n        Thread.sleep(5000);\n    }\n}",
    "target": "Avoid Thread.sleep() for synchronization. Use proper synchronization mechanisms like wait/notify."
  },
  {
    "func": "public class ExceptionHandling {\n    public void readFile() {\n        try {\n            File file = new File(\"data.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Catch specific exceptions instead of generic Exception."
  },
  {
    "func": "public class ImmutableObjects {\n    public String name;\n    public ImmutableObjects(String name) {\n        this.name = name;\n    }\n}",
    "target": "Favor immutable objects by making fields final and private."
  },
  {
    "func": "public class RedundantCode {\n    public boolean isPositive(int number) {\n        if (number > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
    "target": "Avoid redundant conditions. Use return statements efficiently."
  },
  {
    "func": "public class ImproperStringConcatenation {\n    public String concatenate(String a, String b) {\n        return a + b;\n    }\n}",
    "target": "Use StringBuilder for multiple string concatenations to improve performance."
  },
  {
    "func": "public class InconsistentNaming {\n    public int CalculateSum(int numOne, int numTwo) {\n        return numOne + numTwo;\n    }\n}",
    "target": "Follow consistent naming conventions (camelCase for methods, PascalCase for classes)."
  },
  {
    "func": "public class ImproperResourceHandling {\n    public void readFile() throws IOException {\n        FileReader fr = new FileReader(\"data.txt\");\n    }\n}",
    "target": "Use try-with-resources to ensure proper resource closure."
  },
  {
    "func": "public class ImproperExceptionMessage {\n    public void divide(int a, int b) {\n        if (b == 0) {\n            throw new RuntimeException(\"Error\");\n        }\n    }\n}",
    "target": "Provide meaningful exception messages for better debugging."
  },
  {
    "func": "public class LongParameterList {\n    public void process(int a, int b, int c, int d, int e, int f, int g) {}\n}",
    "target": "Reduce long parameter lists. Use objects to group related parameters."
  },
  {
    "func": "public class NullPointerRisk {\n    public void printLength(String text) {\n        System.out.println(text.length());\n    }\n}",
    "target": "Avoid NullPointerException by checking for null values."
  },
  {
    "func": "public class ImproperCollectionUsage {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics (List<String> instead of List) to improve type safety."
  },
  {
    "func": "public class AvoidExcessiveInheritance {\n    class A {}\n    class B extends A {}\n    class C extends B {}\n    class D extends C {}\n}",
    "target": "Avoid deep inheritance chains. Favor composition over inheritance."
  },
  {
    "func": "public class AvoidInstanceof {\n    public void process(Object obj) {\n        if (obj instanceof String) {\n            System.out.println(((String) obj).length());\n        }\n    }\n}",
    "target": "Avoid instanceof checks. Use polymorphism and method overriding."
  },
  {
    "func": "public class AvoidRawTypes {\n    public List list = new ArrayList();\n}",
    "target": "Avoid raw types. Use parameterized generics (List<String>)."
  },
  {
    "func": "public class IncorrectDataStructures {\n    public void process() {\n        Map<Integer, String> map = new Hashtable<>();\n    }\n}",
    "target": "Use ConcurrentHashMap instead of Hashtable for better concurrency performance."
  },
  {
    "func": "public class ImproperSingleton {\n    private static ImproperSingleton instance;\n    public static ImproperSingleton getInstance() {\n        if (instance == null) {\n            instance = new ImproperSingleton();\n        }\n        return instance;\n    }\n}",
    "target": "Use thread-safe singleton patterns like Enum Singleton or Double-Checked Locking."
  },
  {
    "func": "public class ImproperLazyInitialization {\n    private static Logger logger;\n    public static Logger getLogger() {\n        if (logger == null) {\n            logger = new Logger();\n        }\n        return logger;\n    }\n}",
    "target": "Ensure thread safety when initializing shared resources."
  },
  {
    "func": "public class AvoidEmptyCatch {\n    public void readFile() {\n        try {\n            FileReader reader = new FileReader(\"data.txt\");\n        } catch (IOException e) {}\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public class OvercomplicatedBooleanCheck {\n    public boolean isValid(int x) {\n        return (x > 0) ? true : false;\n    }\n}",
    "target": "Simplify boolean expressions. Return directly."
  },
  {
    "func": "public class AvoidExcessiveComments {\n    public int add(int a, int b) {\n        // This function adds two numbers\n        return a + b;\n    }\n}",
    "target": "Avoid excessive comments. Write self-explanatory code."
  },
  {
    "func": "public class RedundantHelper {\n    public void process() {\n        System.out.println(\"Processing...\");\n    }\n    public void helper() {\n        process();\n    }\n}",
    "target": "Avoid redundant helper methods that don't add value (YAGNI)."
  },
  {
    "func": "public class DuplicateCode {\n    public void methodOne() {\n        System.out.println(\"Processing data\");\n    }\n    public void methodTwo() {\n        System.out.println(\"Processing data\");\n    }\n}",
    "target": "Avoid duplicate code. Extract common functionality into reusable methods (DRY)."
  },
  {
    "func": "public class ViolationSRP {\n    public void generateReport() {\n        fetchData();\n        processData();\n        printReport();\n    }\n}",
    "target": "Separate data fetching, processing, and reporting into separate classes (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class HardcodedConfig {\n    public void connect() {\n        String dbUrl = \"jdbc:mysql://localhost:3306/mydb\";\n    }\n}",
    "target": "Avoid hardcoded configuration values. Use environment variables or external configs."
  },
  {
    "func": "public class OverengineeredClass {\n    public void unnecessaryFeature() {\n        // Future functionality placeholder\n    }\n}",
    "target": "Don't add features that aren’t currently needed (YAGNI)."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of tightly coupling classes (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LargeConstructor {\n    public LargeConstructor(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large constructors. Use builder patterns for better readability."
  },
  {
    "func": "public class ImproperInheritance extends BaseClass {\n    public void customMethod() {\n        // Only slightly different from base\n    }\n}",
    "target": "Avoid unnecessary inheritance. Favor composition over inheritance."
  },
  {
    "func": "public class SwitchStatement {\n    public void process(int type) {\n        switch (type) {\n            case 1: System.out.println(\"Type A\"); break;\n            case 2: System.out.println(\"Type B\"); break;\n            default: System.out.println(\"Unknown\");\n        }\n    }\n}",
    "target": "Replace switch statements with polymorphism where applicable (OCP - Open/Closed Principle)."
  },
  {
    "func": "public class LargeClass {\n    public void methodOne() {}\n    public void methodTwo() {}\n    public void methodThree() {}\n    public void methodFour() {}\n    public void methodFive() {}\n}",
    "target": "Refactor large classes into smaller, more focused classes (SRP)."
  },
  {
    "func": "public class IncorrectAbstraction {\n    public class Animal {}\n    public class Dog extends Animal {}\n    public class Car extends Animal {}\n}",
    "target": "Ensure proper abstraction. Avoid incorrect hierarchies (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class EnumInsteadOfConstants {\n    public static final int RED = 1;\n    public static final int BLUE = 2;\n}",
    "target": "Use enums instead of constant integer values for better maintainability."
  },
  {
    "func": "public class MutableGlobalState {\n    public static int counter = 0;\n}",
    "target": "Avoid mutable global state. Use encapsulation and controlled access."
  },
  {
    "func": "public class InconsistentDataStructures {\n    private List<String> names;\n    private Map<String, String> nameMappings;\n}",
    "target": "Use consistent data structures to improve maintainability."
  },
  {
    "func": "public class MultipleReturnTypes {\n    public Object getValue(int type) {\n        if (type == 1) return \"String\";\n        else return 42;\n    }\n}",
    "target": "Avoid returning different types from the same method. Use a well-defined return type."
  },
  {
    "func": "public class UnusedMethod {\n    public void unused() {}\n}",
    "target": "Remove unused methods to keep code clean and maintainable."
  },
  {
    "func": "public class InefficientLoop {\n    public void process(List<String> items) {\n        for (String item : items) {\n            if (items.contains(item)) {\n                System.out.println(item);\n            }\n        }\n    }\n}",
    "target": "Avoid redundant checks inside loops. Optimize performance."
  },
  {
    "func": "public class ImproperLogging {\n    public void logError() {\n        System.out.println(\"Error occurred\");\n    }\n}",
    "target": "Use a proper logging framework instead of System.out.println()."
  },
  {
    "func": "public class StaticUtility {\n    public static void process() {}\n}",
    "target": "Avoid excessive static methods unless in a utility class."
  },
  {
    "func": "public class UnoptimizedCollections {\n    public void process() {\n        List list = new ArrayList();\n    }\n}",
    "target": "Use generics for better type safety and readability."
  },
  {
    "func": "public class HardcodedPaths {\n    public void loadFile() {\n        File file = new File(\"C:\\\\data\\\\file.txt\");\n    }\n}",
    "target": "Avoid hardcoded file paths. Use relative paths or configurations."
  },
  {
    "func": "public class OveruseOfComments {\n    public void process() {\n        // This method processes data\n    }\n}",
    "target": "Write self-explanatory code instead of excessive comments."
  },
  {
    "func": "public class OverloadedConstructors {\n    public OverloadedConstructors() {}\n    public OverloadedConstructors(int a) {}\n    public OverloadedConstructors(int a, int b) {}\n}",
    "target": "Avoid excessive constructor overloading. Use builder patterns."
  },
  {
    "func": "public class SingletonMisuse {\n    private static SingletonMisuse instance;\n    public static SingletonMisuse getInstance() {\n        if (instance == null) {\n            instance = new SingletonMisuse();\n        }\n        return instance;\n    }\n}",
    "target": "Ensure thread safety in singleton implementations."
  },
  {
    "func": "public class LongBooleanChecks {\n    public boolean isEligible(int age, boolean isEmployed, boolean hasLicense) {\n        return age > 18 && isEmployed && hasLicense;\n    }\n}",
    "target": "Avoid long boolean conditions. Use descriptive helper methods."
  },
  {
    "func": "public class ExcessiveLayers {\n    public void fetchData() {\n        repository.getService().fetch().process();\n    }\n}",
    "target": "Avoid excessive layers in method calls. Keep it simple."
  },
  {
    "func": "public class HardcodedSQL {\n    public void query() {\n        String sql = \"SELECT * FROM users WHERE id = 1\";\n    }\n}",
    "target": "Avoid hardcoded SQL queries. Use parameterized queries or ORM."
  },
  {
    "func": "public class PoorNaming {\n    public void x() {}\n}",
    "target": "Use meaningful method and variable names for readability."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to reduce clutter and improve maintainability."
  },
  {
    "func": "public class LargeMethod {\n    public void process() {\n        fetch();\n        validate();\n        transform();\n        save();\n    }\n}",
    "target": "Break large methods into smaller, focused methods (SRP - Single Responsibility Principle)."
  },
  {
    "func": "public class ImproperInheritance {\n    public class Vehicle {}\n    public class Bicycle extends Vehicle {\n        public void fly() {}\n    }\n}",
    "target": "Ensure subclass behaviors align with parent class expectations (LSP - Liskov Substitution Principle)."
  },
  {
    "func": "public class ViolationOCP {\n    public void process(String type) {\n        if (type.equals(\"A\")) {}\n        else if (type.equals(\"B\")) {}\n    }\n}",
    "target": "Avoid modifying existing classes for new behaviors. Use polymorphism (OCP - Open/Closed Principle)."
  },
  {
    "func": "public interface FatInterface {\n    void methodA();\n    void methodB();\n    void methodC();\n    void methodD();\n}",
    "target": "Split large interfaces into smaller, focused ones (ISP - Interface Segregation Principle)."
  },
  {
    "func": "public class HardcodedLogic {\n    public double calculateTax(double amount) {\n        return amount * 0.15;\n    }\n}",
    "target": "Avoid hardcoded business logic. Make it configurable or use dependency injection."
  },
  {
    "func": "public class TightCoupling {\n    private Logger logger = new Logger();\n}",
    "target": "Use dependency injection instead of directly instantiating dependencies (DIP - Dependency Inversion Principle)."
  },
  {
    "func": "public class LongMethod {\n    public void process() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i);\n        }\n    }\n}",
    "target": "Refactor long methods by extracting logic into smaller methods (KISS)."
  },
  {
    "func": "public class NestedIfElse {\n    public void process(int x) {\n        if (x > 0) {\n            if (x < 100) {\n                if (x % 2 == 0) {\n                    System.out.println(\"Even\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Use guard clauses or early returns (KISS)."
  },
  {
    "func": "public class RedundantNullCheck {\n    public void process(String data) {\n        if (data != null && !data.isEmpty()) {}\n    }\n}",
    "target": "Avoid redundant null checks. Use Optional or proper default values."
  },
  {
    "func": "public class CatchingGenericException {\n    public void riskyMethod() {\n        try {\n            riskyOperation();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions instead."
  },
  {
    "func": "public class MethodWithMultipleReturns {\n    public int process(int x) {\n        if (x > 10) return 1;\n        if (x < 5) return -1;\n        return 0;\n    }\n}",
    "target": "Minimize multiple return statements to improve readability."
  },
  {
    "func": "public class StaticUtilityClass {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}",
    "target": "Avoid excessive static utility methods. Use dependency injection where possible."
  },
  {
    "func": "public class ComplexConditionals {\n    public boolean isValid(User user) {\n        return user.isActive() && user.hasValidSubscription() && user.getAge() > 18;\n    }\n}",
    "target": "Avoid complex conditionals. Use named methods to improve readability."
  },
  {
    "func": "public class MagicNumbers {\n    public double calculateDiscount(double amount) {\n        return amount * 0.07;\n    }\n}",
    "target": "Avoid magic numbers. Use constants with meaningful names."
  },
  {
    "func": "public class ImproperThreadHandling {\n    public void process() {\n        new Thread(() -> System.out.println(\"Running\"));\n    }\n}",
    "target": "Avoid manually creating threads. Use thread pools for better performance."
  },
  {
    "func": "public class DirectDatabaseCall {\n    public void fetchData() {\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\");\n    }\n}",
    "target": "Use connection pooling instead of direct database connections."
  },
  {
    "func": "public class InefficientStringConcatenation {\n    public void process() {\n        String result = \"\";\n        for (int i = 0; i < 1000; i++) {\n            result += i;\n        }\n    }\n}",
    "target": "Use StringBuilder for efficient string concatenation."
  },
  {
    "func": "public class UncheckedUserInput {\n    public void process(String input) {\n        System.out.println(\"User input: \" + input);\n    }\n}",
    "target": "Sanitize and validate user input to prevent security vulnerabilities."
  },
  {
    "func": "public class OvercomplicatedFactory {\n    public static Service getService(String type) {\n        if (type.equals(\"A\")) return new ServiceA();\n        else if (type.equals(\"B\")) return new ServiceB();\n        else return null;\n    }\n}",
    "target": "Use dependency injection instead of overcomplicated factory methods."
  },
  {
    "func": "public class ViolationOfDIP {\n    public class EmailService {\n        public void sendEmail() {}\n    }\n    public class Notification {\n        private EmailService emailService = new EmailService();\n    }\n}",
    "target": "Depend on abstractions, not concrete implementations (DIP)."
  },
  {
    "func": "public class UnusedImports {\n    import java.util.List;\n    import java.util.Map;\n}",
    "target": "Remove unused imports to keep the code clean."
  },
  {
    "func": "public class OverloadedMethods {\n    public void process(int a) {}\n    public void process(double a) {}\n    public void process(String a) {}\n}",
    "target": "Avoid excessive method overloading when not necessary."
  },
  {
    "func": "public class UnoptimizedSorting {\n    public void sort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr.length - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n}",
    "target": "Use built-in sorting algorithms like Arrays.sort() instead of custom implementations."
  },
  {
    "func": "public class LargeParameterList {\n    public void process(int a, int b, int c, int d, int e, int f) {}\n}",
    "target": "Reduce large parameter lists. Use objects or parameter objects instead."
  },
  {
    "func": "public class LoggingWithoutLevels {\n    public void log() {\n        System.out.println(\"Log message\");\n    }\n}",
    "target": "Use logging frameworks with levels instead of System.out."
  },
  {
    "func": "public class HardcodedEmail {\n    public void sendEmail() {\n        String email = \"admin@example.com\";\n    }\n}",
    "target": "Avoid hardcoded email addresses. Use configurations instead."
  },
  {
    "func": "public void duplicateCodeExample() {\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n    System.out.println(\"Logging in\");\n    authenticateUser();\n    System.out.println(\"Logging out\");\n}",
    "target": "Avoid duplicate code. Refactor repeated logic into a reusable method."
  },
  {
    "func": "public void longParameterList(String name, int age, double salary, String address, String phone, boolean isActive, int departmentId, String email) {\n    System.out.println(name + \" \" + age);\n}",
    "target": "Too many parameters in a method reduce readability. Consider using a data object or a builder pattern."
  },
  {
    "func": "public String getUserInfo(String userId) {\n    if(userId.equals(\"admin\")) {\n        return \"Administrator\";\n    } else if(userId.equals(\"user1\")) {\n        return \"User One\";\n    } else if(userId.equals(\"user2\")) {\n        return \"User Two\";\n    } else {\n        return \"Unknown User\";\n    }\n}",
    "target": "Excessive if-else statements reduce maintainability. Use a map or a switch-case structure."
  },
  {
    "func": "public void badLogging() {\n    System.out.println(\"User login: \" + username + \" at \" + LocalDateTime.now());\n}",
    "target": "Avoid logging sensitive information like usernames. Use secure logging mechanisms with masking."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "String concatenation in loops is inefficient. Use StringBuilder instead."
  },
  {
    "func": "public void noExceptionHandling() {\n    int result = 10 / 0;\n    System.out.println(result);\n}",
    "target": "Handle exceptions properly to prevent runtime crashes."
  },
  {
    "func": "public void unclosedResource() {\n    FileReader reader = new FileReader(\"file.txt\");\n    reader.read();\n}",
    "target": "Always close resources after use. Use try-with-resources for proper resource management."
  },
  {
    "func": "public void exposedAPIKey() {\n    String apiKey = \"12345-abcdef-67890\";\n    sendRequest(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Use environment variables or a secure vault."
  },
  {
    "func": "public void deeplyNestedCode(int num) {\n    if (num > 0) {\n        if (num < 100) {\n            if (num % 2 == 0) {\n                if (num % 5 == 0) {\n                    System.out.println(\"Valid number\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting. Refactor using guard clauses or early exits."
  },
  {
    "func": "public void reflectionSecurity() throws Exception {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Reflection can be exploited for security vulnerabilities. Use it cautiously and restrict untrusted input."
  },
  {
    "func": "public void missingNullCheck(String input) {\n    System.out.println(input.length());\n}",
    "target": "Check for null values before dereferencing objects to avoid NullPointerExceptions."
  },
  {
    "func": "public void staticState() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. It can cause race conditions in multi-threaded applications."
  },
  {
    "func": "public void inefficientLoops(List<String> items) {\n    for (int i = 0; i < items.size(); i++) {\n        System.out.println(items.get(i));\n    }\n}",
    "target": "Use enhanced for-loops instead of indexed loops for better readability and performance."
  },
  {
    "func": "public void catchingGenericException() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "target": "Avoid catching generic exceptions. Catch specific exceptions for better error handling."
  },
  {
    "func": "public void redundantElseReturn(int x) {\n    if (x > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "target": "Remove redundant else statements after return for cleaner code."
  },
  {
    "func": "public void unoptimizedCollectionSearch(List<String> names, String target) {\n    for (String name : names) {\n        if (name.equals(target)) {\n            return;\n        }\n    }\n}",
    "target": "Use a HashSet for efficient lookups instead of iterating through a list."
  },
  {
    "func": "public void nonFinalConstants() {\n    static String CONFIG_PATH = \"/etc/config\";\n}",
    "target": "Use final for constants to prevent accidental modifications."
  },
  {
    "func": "public void insecureDeserialization(String data) {\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = ois.readObject();\n}",
    "target": "Untrusted deserialization can lead to security vulnerabilities. Validate input before deserializing objects."
  },
  {
    "func": "public void missingTimeout() {\n    HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com\").openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void incorrectBitwiseComparison() {\n    if (x & 1 == 1) {\n        System.out.println(\"Odd number\");\n    }\n}",
    "target": "Use (x & 1) != 0 instead of (x & 1 == 1) for correct bitwise operations."
  },
  {
    "func": "public void tightCoupling() {\n    Database db = new Database();\n    db.connect();\n}",
    "target": "Avoid tight coupling. Use dependency injection to improve testability and maintainability."
  },
  {
    "func": "public void overuseOfStatics() {\n    static Logger logger = new Logger();\n}",
    "target": "Avoid using static instances for shared objects. Use dependency injection frameworks."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Date;\n    public void method() {\n        List<String> items = new ArrayList<>();\n    }\n}",
    "target": "Remove unused imports to reduce clutter and improve performance."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"/user/home/config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void insecureRandom() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic purposes."
  },
  {
    "func": "public void missingEqualsContract() {\n    class User {\n        String name;\n    }\n}",
    "target": "Override equals() and hashCode() when defining custom objects to ensure correct behavior in collections."
  },
  {
    "func": "public void globalState() {\n    static List<String> users = new ArrayList<>();\n}",
    "target": "Avoid shared global state. It can cause unexpected side effects in multi-threaded environments."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void inefficientListTraversal() {\n    List<String> list = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        System.out.println(list.get(i));\n    }\n}",
    "target": "Use an enhanced for-loop or iterator to avoid performance overhead with indexed access in lists."
  },
  {
    "func": "public void insecureHashing(String password) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash = md.digest(password.getBytes());\n}",
    "target": "Avoid using MD5 for hashing. Use SHA-256 or bcrypt for secure password storage."
  },
  {
    "func": "public void inefficientStringConcat() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += \"Iteration: \" + i;\n    }\n}",
    "target": "Use StringBuilder instead of string concatenation inside loops to improve performance."
  },
  {
    "func": "public void blockingNetworkCall() {\n    URL url = new URL(\"http://example.com\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.connect();\n}",
    "target": "Always set a timeout for network connections to prevent indefinite blocking."
  },
  {
    "func": "public void excessiveMemoryAllocation() {\n    int[] largeArray = new int[100000000];\n}",
    "target": "Avoid large memory allocations. Consider using streaming or paginated processing."
  },
  {
    "func": "public void SQLInjection(String userInput) {\n    String query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";\n    executeQuery(query);\n}",
    "target": "Use prepared statements instead of string concatenation to prevent SQL injection attacks."
  },
  {
    "func": "public void inefficientSorting(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[i] > array[j]) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n}",
    "target": "Use optimized sorting algorithms like Arrays.sort() instead of bubble sort for better performance."
  },
  {
    "func": "public void weakEncryption(String plaintext) {\n    Cipher cipher = Cipher.getInstance(\"DES\");\n}",
    "target": "DES is a weak encryption algorithm. Use AES-256 for better security."
  },
  {
    "func": "public void unclosedDatabaseConnection() {\n    Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);\n    Statement stmt = conn.createStatement();\n    stmt.executeQuery(\"SELECT * FROM users\");\n}",
    "target": "Always close database connections after use to prevent resource leaks."
  },
  {
    "func": "public void outdatedLibraryUsage() {\n    java.util.Vector<String> list = new java.util.Vector<>();\n}",
    "target": "Avoid using Vector. Use ArrayList instead for better performance and modern compatibility."
  },
  {
    "func": "public void resourceLeak() {\n    FileInputStream fis = new FileInputStream(\"data.txt\");\n    fis.read();\n}",
    "target": "Use try-with-resources to automatically close streams and prevent memory leaks."
  },
  {
    "func": "public void deprecatedAPICall() {\n    java.util.Date date = new java.util.Date();\n    int year = date.getYear();\n}",
    "target": "Avoid using deprecated Date API. Use java.time.LocalDateTime instead."
  },
  {
    "func": "public void threadUnsafeStaticVar() {\n    static int counter = 0;\n    counter++;\n}",
    "target": "Avoid shared mutable state in static variables. Use synchronized blocks or atomic variables."
  },
  {
    "func": "public void excessiveLogging() {\n    for (int i = 0; i < 1000000; i++) {\n        System.out.println(\"Log entry: \" + i);\n    }\n}",
    "target": "Avoid excessive logging in loops. Use log levels and batch logging."
  },
  {
    "func": "public void weakRandomNumber() {\n    Random rand = new Random();\n    int otp = rand.nextInt(9999);\n}",
    "target": "Use SecureRandom instead of Random for cryptographic operations."
  },
  {
    "func": "public void inefficientLoopExitCondition() {\n    while (i < array.length) {\n        if (array[i] == target) {\n            return;\n        }\n    }\n}",
    "target": "Ensure proper loop exit conditions to avoid infinite loops."
  },
  {
    "func": "public void exposedInternalField() {\n    public String password;\n}",
    "target": "Avoid exposing sensitive fields directly. Use private fields with getters/setters."
  },
  {
    "func": "public void unnecessaryObjectCreation() {\n    String str = new String(\"Hello\");\n}",
    "target": "Avoid unnecessary object creation. Use String literals where possible."
  },
  {
    "func": "public void hardcodedCredentials() {\n    String password = \"admin123\";\n}",
    "target": "Avoid hardcoded credentials in source code. Use secure vaults or environment variables."
  },
  {
    "func": "public void emptyCatchBlock() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n    }\n}",
    "target": "Avoid empty catch blocks. Always log or handle exceptions properly."
  },
  {
    "func": "public void inefficientSetOperations() {\n    List<String> list = new ArrayList<>();\n    for (String item : list) {\n        if (!list.contains(item)) {\n            list.add(item);\n        }\n    }\n}",
    "target": "Use a HashSet for faster element lookup and better performance."
  },
  {
    "func": "public void unrestrictedReflection() {\n    Class<?> cls = Class.forName(\"java.lang.Runtime\");\n    Method method = cls.getDeclaredMethod(\"exec\", String.class);\n    method.setAccessible(true);\n    method.invoke(cls.newInstance(), \"rm -rf /\");\n}",
    "target": "Unrestricted reflection is dangerous. Restrict access to critical classes and methods."
  },
  {
    "func": "public void hardcodedFilePath() {\n    File file = new File(\"C:\\\\Users\\\\Admin\\\\config.txt\");\n}",
    "target": "Avoid hardcoded file paths. Use configuration files or environment variables."
  },
  {
    "func": "public void nonOptimalDataStructure() {\n    LinkedList<Integer> list = new LinkedList<>();\n    for (int i = 0; i < 1000; i++) {\n        list.add(i);\n    }\n}",
    "target": "Use ArrayList instead of LinkedList for faster indexed access."
  },
  {
    "func": "public void missingBreakInSwitch(int day) {\n    switch (day) {\n        case 1: System.out.println(\"Monday\");\n        case 2: System.out.println(\"Tuesday\");\n    }\n}",
    "target": "Use break statements in switch cases to prevent fall-through logic errors."
  },
  {
    "func": "public void excessiveThreadCreation() {\n    for (int i = 0; i < 1000; i++) {\n        new Thread(() -> System.out.println(\"Thread running\")).start();\n    }\n}",
    "target": "Avoid excessive thread creation. Use thread pools for better performance."
  },
  {
    "func": "public void poorErrorMessage() {\n    throw new Exception(\"Error\");\n}",
    "target": "Provide meaningful error messages to improve debugging and logging."
  },
  {
    "func": "public void insecureCommunication() {\n    URL url = new URL(\"http://example.com\");\n}",
    "target": "Avoid insecure HTTP connections. Use HTTPS for secure communication."
  },
  {
    "func": "public void insecureS3BucketAccess() {\n    AmazonS3 s3 = AmazonS3ClientBuilder.standard().build();\n    s3.putObject(\"my-bucket\", \"public-file.txt\", \"Sensitive Data\");\n}",
    "target": "Ensure S3 buckets are private by default. Use IAM roles and policies to manage access."
  },
  {
    "func": "public void hardcodedAPIKey() {\n    String apiKey = \"sk_1234567890abcdef\";\n    callAPI(apiKey);\n}",
    "target": "Avoid hardcoding API keys in source code. Store them securely in environment variables or vaults."
  },
  {
    "func": "public void unrestrictedCORS() {\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
    "target": "Avoid using wildcard CORS policies. Restrict domains to trusted origins."
  },
  {
    "func": "public void missingRateLimiting(HttpServletRequest request) {\n    if (request.getParameter(\"token\").equals(\"valid\")) {\n        processRequest();\n    }\n}",
    "target": "Implement rate limiting to prevent API abuse. Use tools like AWS API Gateway or nginx."
  },
  {
    "func": "public void unvalidatedRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String url = request.getParameter(\"redirect\");\n    response.sendRedirect(url);\n}",
    "target": "Validate and restrict redirect URLs to prevent open redirect vulnerabilities."
  },
  {
    "func": "public void insufficientTLSValidation() throws Exception {\n    SSLContext ctx = SSLContext.getInstance(\"SSL\");\n}",
    "target": "Always enforce TLS 1.2+ for secure communication. Avoid using generic SSL protocols."
  },
  {
    "func": "public void sensitiveDataExposure() {\n    System.out.println(\"User password: \" + user.getPassword());\n}",
    "target": "Avoid logging sensitive data. Mask or redact credentials before logging."
  },
  {
    "func": "public void missingJWTValidation(String token) {\n    Claims claims = Jwts.parser().parseClaimsJws(token).getBody();\n}",
    "target": "Always validate JWT signatures and expiration times before using claims."
  },
  {
    "func": "public void overlyPermissiveIAMPolicy() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Use the principle of least privilege in IAM policies. Avoid wildcard permissions."
  },
  {
    "func": "public void exposingStackTraces(Exception e) {\n    e.printStackTrace();\n}",
    "target": "Avoid exposing stack traces in production. Log errors securely without revealing internal details."
  },
  {
    "func": "public void missingLoggingForSecurityEvents(HttpServletRequest request) {\n    if (request.getParameter(\"user\").equals(\"admin\")) {\n        processRequest();\n    }\n}",
    "target": "Implement proper security logging for authentication attempts, access failures, and privilege escalations."
  },
  {
    "func": "public void insecureGraphQLEndpoint(String query) {\n    executeGraphQLQuery(query);\n}",
    "target": "Sanitize GraphQL queries to prevent injection attacks and enforce query complexity limits."
  },
  {
    "func": "public void unrestrictedFileUpload(HttpServletRequest request) throws IOException {\n    Part filePart = request.getPart(\"file\");\n    filePart.write(\"/uploads/\" + filePart.getSubmittedFileName());\n}",
    "target": "Validate file types and enforce size limits on file uploads to prevent malware execution."
  },
  {
    "func": "public void unencryptedSensitiveData() {\n    byte[] encrypted = new byte[] {1, 2, 3};\n    storeData(encrypted);\n}",
    "target": "Ensure sensitive data is encrypted at rest using AES-256 and stored securely."
  },
  {
    "func": "public void missingCSRFProtection(HttpServletRequest request) {\n    if (request.getParameter(\"action\").equals(\"delete\")) {\n        deleteUser();\n    }\n}",
    "target": "Enforce CSRF protection using tokens to prevent cross-site request forgery."
  },
  {
    "func": "public void unsafeDeserialization(String data) {\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data.getBytes()));\n    Object obj = in.readObject();\n}",
    "target": "Avoid Java deserialization of untrusted data. Use JSON-based formats instead."
  },
  {
    "func": "public void missingOAuthScopeValidation(OAuth2Authentication auth) {\n    if (auth.getAuthorities().contains(\"ROLE_USER\")) {\n        processRequest();\n    }\n}",
    "target": "Validate OAuth scopes and restrict access to only required resources."
  },
  {
    "func": "public void weakSessionID() {\n    String sessionId = UUID.randomUUID().toString();\n}",
    "target": "Use secure, cryptographically random session IDs instead of UUIDs."
  },
  {
    "func": "public void unrestrictedAdminEndpoint() {\n    if (request.getParameter(\"role\").equals(\"admin\")) {\n        grantAdminAccess();\n    }\n}",
    "target": "Restrict admin endpoints to authenticated and authorized users only."
  },
  {
    "func": "public void missingXSSProtection(HttpServletRequest request, HttpServletResponse response) {\n    response.getWriter().write(\"<h1>\" + request.getParameter(\"title\") + \"</h1>\");\n}",
    "target": "Sanitize user input before rendering in the frontend to prevent XSS attacks."
  },
  {
    "func": "public void leakingAWSSecrets() {\n    String awsSecret = \"AKIAIOSFODNN7EXAMPLE\";\n}",
    "target": "Never store AWS secrets in source code. Use environment variables or AWS Secrets Manager."
  },
  {
    "func": "public void missingDatabaseEncryption() {\n    String sql = \"INSERT INTO users (ssn) VALUES ('123-45-6789')\";\n}",
    "target": "Encrypt sensitive database fields like SSNs using industry-standard encryption."
  },
  {
    "func": "public void unrestrictedOpenAPI(HttpServletRequest request) {\n    String endpoint = request.getParameter(\"endpoint\");\n    callAPI(endpoint);\n}",
    "target": "Enforce authentication and authorization checks on API endpoints."
  },
  {
    "func": "public void insufficientCloudLogging() {\n    System.out.println(\"User login: \" + user.getUsername());\n}",
    "target": "Implement centralized logging using AWS CloudWatch, Azure Monitor, or GCP Logging."
  },
  {
    "func": "public void missingSecurityHeaders(HttpServletResponse response) {\n    response.setHeader(\"X-Frame-Options\", \"\");\n}",
    "target": "Set security headers like X-Frame-Options, X-Content-Type-Options, and Content-Security-Policy."
  },
  {
    "func": "public void overexposedKubernetesSecrets() {\n    String secret = readKubernetesSecret(\"default\");\n}",
    "target": "Restrict Kubernetes secrets access using RBAC and avoid exposing secrets in logs."
  },
  {
    "func": "public void vulnerableGCPStorage() {\n    Storage storage = StorageOptions.getDefaultInstance().getService();\n    storage.create(BlobInfo.newBuilder(\"my-public-bucket\", \"file.txt\").build(), data);\n}",
    "target": "Ensure Google Cloud Storage buckets have restricted public access."
  },
  {
    "func": "public void unsafeIAMUser() {\n    String policy = \"{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\": \\\"*\\\", \\\"Resource\\\": \\\"*\\\" }\";\n}",
    "target": "Avoid using IAM users with overly broad permissions. Follow the principle of least privilege."
  },
  {
    "func": "public void longMethodExample() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n    int d = c * 2;\n    int e = d - 5;\n    int f = e / 3;\n    int g = f + 7;\n    int h = g * 2;\n    int i = h - 8;\n    System.out.println(i);\n}",
    "target": "Avoid excessively long methods. Split functionality into smaller, reusable methods."
  },
  {
    "func": "public void ambiguousVariableNames() {\n    int a = 10;\n    int b = 20;\n    int c = a + b;\n    System.out.println(c);\n}",
    "target": "Use meaningful variable names instead of single-letter names for better readability."
  },
  {
    "func": "public void inconsistentMethodNaming() {\n    public void fetchUser() {}\n    public void GetUserData() {}\n    public void retrieve_user() {}\n}",
    "target": "Use consistent naming conventions (camelCase) for methods to improve readability."
  },
  {
    "func": "public void unusedImports() {\n    import java.util.List;\n    import java.util.ArrayList;\n    public void method() {\n        System.out.println(\"Hello\");\n    }\n}",
    "target": "Remove unused imports to reduce code clutter and improve maintainability."
  },
  {
    "func": "public void deeplyNestedLoops() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                for (int l = 0; l < 10; l++) {\n                    System.out.println(\"Nested loop\");\n                }\n            }\n        }\n    }\n}",
    "target": "Avoid deep nesting of loops; refactor with helper methods or break logic into smaller parts."
  },
  {
    "func": "public synchronized void improperLocking() {\n    synchronized(this) {\n        synchronized(this) {\n            System.out.println(\"Nested locks\");\n        }\n    }\n}",
    "target": "Avoid nested synchronization to prevent deadlocks and maintain concurrency safety."
  },
  {
    "func": "public void sharedMutableState() {\n    private static int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Avoid shared mutable state across threads. Use thread-safe data structures or synchronization."
  },
  {
    "func": "public void missingThreadSafety() {\n    private int counter = 0;\n    public void increment() {\n        counter++;\n    }\n}",
    "target": "Ensure proper synchronization or atomic operations when modifying shared data in multithreading."
  },
  {
    "func": "public void blockingOperationInThread() {\n    public void process() {\n        while (true) {\n            // Simulating a long-running task\n        }\n    }\n}",
    "target": "Avoid infinite loops in threads without exit conditions; implement proper thread interruption."
  },
  {
    "func": "public void nonDaemonThread() {\n    Thread t = new Thread(() -> {\n        while (true) {\n            System.out.println(\"Running\");\n        }\n    });\n    t.start();\n}",
    "target": "Set background threads as daemon threads to prevent them from blocking application shutdown."
  },
  {
    "func": "public void inefficientStringConcatenation() {\n    String result = \"\";\n    for (int i = 0; i < 1000; i++) {\n        result += i;\n    }\n}",
    "target": "Avoid using `+` for string concatenation in loops; use `StringBuilder` for better performance."
  },
  {
    "func": "public void nonThreadSafeCollection() {\n    private List<Integer> list = new ArrayList<>();\n    public void addItem(int item) {\n        list.add(item);\n    }\n}",
    "target": "Use thread-safe collections like `CopyOnWriteArrayList` or `ConcurrentHashMap` for shared data."
  },
  {
    "func": "public void unnecessaryNullChecks() {\n    public void process(String input) {\n        if (input != null) {\n            if (input.length() > 0) {\n                System.out.println(input);\n            }\n        }\n    }\n}",
    "target": "Reduce redundant null checks to improve code clarity and maintainability."
  },
  {
    "func": "public void missingDefaultCaseInSwitch(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"One\");\n            break;\n        case 2:\n            System.out.println(\"Two\");\n            break;\n    }\n}",
    "target": "Always include a default case in switch statements to handle unexpected inputs."
  },
  {
    "func": "public void inefficientFileReading() {\n    FileReader fr = new FileReader(\"file.txt\");\n    int i;\n    while ((i = fr.read()) != -1) {\n        System.out.print((char) i);\n    }\n}",
    "target": "Use buffered file reading (`BufferedReader`) to improve I/O performance."
  },
  {
    "func": "public void redundantElseAfterReturn() {\n    public int check(int value) {\n        if (value > 10) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
    "target": "Remove redundant `else` after `return` for cleaner and more maintainable code."
  },
  {
    "func": "public void unnecessaryCheckedException() throws IOException {\n    public void method() throws IOException {\n        System.out.println(\"No need for exception\");\n    }\n}",
    "target": "Avoid declaring unnecessary checked exceptions when they are not thrown."
  },
  {
    "func": "public void redundantBooleanComparisons() {\n    public boolean isTrue(boolean flag) {\n        return flag == true;\n    }\n}",
    "target": "Avoid redundant boolean comparisons; use `return flag;` directly."
  },
  {
    "func": "public void ignoringInterruptedException() {\n    public void sleepThread() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // Ignoring exception\n        }\n    }\n}",
    "target": "Handle `InterruptedException` properly instead of ignoring it."
  }
]
